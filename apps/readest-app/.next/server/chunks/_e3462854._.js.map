{"version":3,"sources":["../../../../../node_modules/.pnpm/%40tauri-apps%2Bapi%402.9.1/node_modules/%40tauri-apps/api/path.js","../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-fs%402.4.5/node_modules/%40tauri-apps/plugin-fs/dist-js/index.js","../../../../../apps/readest-app/src/utils/path.ts","../../../../../apps/readest-app/src/utils/file.ts","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/native.js","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/rng.js","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/regex.js","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/validate.js","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/stringify.js","../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/v4.js","../../../../../apps/readest-app/src/types/book.ts","../../../../../apps/readest-app/src/libs/document.ts","../../../../../apps/readest-app/src/utils/book.ts","../../../../../apps/readest-app/src/utils/rtl.ts","../../../../../apps/readest-app/src/utils/md5.ts","../../../../../apps/readest-app/src/services/appService.ts","../../../../../apps/readest-app/src/utils/indexedDBCache.ts","../../../../../apps/readest-app/src/utils/cachedFetch.ts","../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-http%402.5.6/node_modules/%40tauri-apps/plugin-http/dist-js/index.js","../../../../../apps/readest-app/src/utils/serializer.ts","../../../../../apps/readest-app/src/utils/txt.ts","../../../../../apps/readest-app/src/services/errors.ts","../../../../../apps/readest-app/src/utils/font.ts","../../../../../apps/readest-app/src/utils/svg.ts"],"sourcesContent":["import { invoke } from './core.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * The path module provides utilities for working with file and directory paths.\n *\n * This package is also accessible with `window.__TAURI__.path` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n *\n * It is recommended to allowlist only the APIs you use for optimal bundle size and security.\n * @module\n */\n/**\n * @since 2.0.0\n */\nvar BaseDirectory;\n(function (BaseDirectory) {\n    /**\n     * @see {@link audioDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Audio\"] = 1] = \"Audio\";\n    /**\n     * @see {@link cacheDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Cache\"] = 2] = \"Cache\";\n    /**\n     * @see {@link configDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Config\"] = 3] = \"Config\";\n    /**\n     * @see {@link dataDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Data\"] = 4] = \"Data\";\n    /**\n     * @see {@link localDataDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"LocalData\"] = 5] = \"LocalData\";\n    /**\n     * @see {@link documentDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Document\"] = 6] = \"Document\";\n    /**\n     * @see {@link downloadDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Download\"] = 7] = \"Download\";\n    /**\n     * @see {@link pictureDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Picture\"] = 8] = \"Picture\";\n    /**\n     * @see {@link publicDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Public\"] = 9] = \"Public\";\n    /**\n     * @see {@link videoDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Video\"] = 10] = \"Video\";\n    /**\n     * @see {@link resourceDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Resource\"] = 11] = \"Resource\";\n    /**\n     * @see {@link tempDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Temp\"] = 12] = \"Temp\";\n    /**\n     * @see {@link appConfigDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"AppConfig\"] = 13] = \"AppConfig\";\n    /**\n     * @see {@link appDataDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"AppData\"] = 14] = \"AppData\";\n    /**\n     * @see {@link appLocalDataDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"AppLocalData\"] = 15] = \"AppLocalData\";\n    /**\n     * @see {@link appCacheDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"AppCache\"] = 16] = \"AppCache\";\n    /**\n     * @see {@link appLogDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"AppLog\"] = 17] = \"AppLog\";\n    /**\n     * @see {@link desktopDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Desktop\"] = 18] = \"Desktop\";\n    /**\n     * @see {@link executableDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Executable\"] = 19] = \"Executable\";\n    /**\n     * @see {@link fontDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Font\"] = 20] = \"Font\";\n    /**\n     * @see {@link homeDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Home\"] = 21] = \"Home\";\n    /**\n     * @see {@link runtimeDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Runtime\"] = 22] = \"Runtime\";\n    /**\n     * @see {@link templateDir} for more information.\n     */\n    BaseDirectory[BaseDirectory[\"Template\"] = 23] = \"Template\";\n})(BaseDirectory || (BaseDirectory = {}));\n/**\n * Returns the path to the suggested directory for your app's config files.\n * Resolves to `${configDir}/${bundleIdentifier}`, where `bundleIdentifier` is the [`identifier`](https://v2.tauri.app/reference/config/#identifier) value configured in `tauri.conf.json`.\n * @example\n * ```typescript\n * import { appConfigDir } from '@tauri-apps/api/path';\n * const appConfigDirPath = await appConfigDir();\n * ```\n *\n * @since 1.2.0\n */\nasync function appConfigDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.AppConfig\n    });\n}\n/**\n * Returns the path to the suggested directory for your app's data files.\n * Resolves to `${dataDir}/${bundleIdentifier}`, where `bundleIdentifier` is the [`identifier`](https://v2.tauri.app/reference/config/#identifier) value configured in `tauri.conf.json`.\n * @example\n * ```typescript\n * import { appDataDir } from '@tauri-apps/api/path';\n * const appDataDirPath = await appDataDir();\n * ```\n *\n * @since 1.2.0\n */\nasync function appDataDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.AppData\n    });\n}\n/**\n * Returns the path to the suggested directory for your app's local data files.\n * Resolves to `${localDataDir}/${bundleIdentifier}`, where `bundleIdentifier` is the [`identifier`](https://v2.tauri.app/reference/config/#identifier) value configured in `tauri.conf.json`.\n * @example\n * ```typescript\n * import { appLocalDataDir } from '@tauri-apps/api/path';\n * const appLocalDataDirPath = await appLocalDataDir();\n * ```\n *\n * @since 1.2.0\n */\nasync function appLocalDataDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.AppLocalData\n    });\n}\n/**\n * Returns the path to the suggested directory for your app's cache files.\n * Resolves to `${cacheDir}/${bundleIdentifier}`, where `bundleIdentifier` is the [`identifier`](https://v2.tauri.app/reference/config/#identifier) value configured in `tauri.conf.json`.\n * @example\n * ```typescript\n * import { appCacheDir } from '@tauri-apps/api/path';\n * const appCacheDirPath = await appCacheDir();\n * ```\n *\n * @since 1.2.0\n */\nasync function appCacheDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.AppCache\n    });\n}\n/**\n * Returns the path to the user's audio directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_MUSIC_DIR`.\n * - **macOS:** Resolves to `$HOME/Music`.\n * - **Windows:** Resolves to `{FOLDERID_Music}`.\n * @example\n * ```typescript\n * import { audioDir } from '@tauri-apps/api/path';\n * const audioDirPath = await audioDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function audioDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Audio\n    });\n}\n/**\n * Returns the path to the user's cache directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_CACHE_HOME` or `$HOME/.cache`.\n * - **macOS:** Resolves to `$HOME/Library/Caches`.\n * - **Windows:** Resolves to `{FOLDERID_LocalAppData}`.\n * @example\n * ```typescript\n * import { cacheDir } from '@tauri-apps/api/path';\n * const cacheDirPath = await cacheDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function cacheDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Cache\n    });\n}\n/**\n * Returns the path to the user's config directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_CONFIG_HOME` or `$HOME/.config`.\n * - **macOS:** Resolves to `$HOME/Library/Application Support`.\n * - **Windows:** Resolves to `{FOLDERID_RoamingAppData}`.\n * @example\n * ```typescript\n * import { configDir } from '@tauri-apps/api/path';\n * const configDirPath = await configDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function configDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Config\n    });\n}\n/**\n * Returns the path to the user's data directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_DATA_HOME` or `$HOME/.local/share`.\n * - **macOS:** Resolves to `$HOME/Library/Application Support`.\n * - **Windows:** Resolves to `{FOLDERID_RoamingAppData}`.\n * @example\n * ```typescript\n * import { dataDir } from '@tauri-apps/api/path';\n * const dataDirPath = await dataDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function dataDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Data\n    });\n}\n/**\n * Returns the path to the user's desktop directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_DESKTOP_DIR`.\n * - **macOS:** Resolves to `$HOME/Desktop`.\n * - **Windows:** Resolves to `{FOLDERID_Desktop}`.\n * @example\n * ```typescript\n * import { desktopDir } from '@tauri-apps/api/path';\n * const desktopPath = await desktopDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function desktopDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Desktop\n    });\n}\n/**\n * Returns the path to the user's document directory.\n * @example\n * ```typescript\n * import { documentDir } from '@tauri-apps/api/path';\n * const documentDirPath = await documentDir();\n * ```\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_DOCUMENTS_DIR`.\n * - **macOS:** Resolves to `$HOME/Documents`.\n * - **Windows:** Resolves to `{FOLDERID_Documents}`.\n *\n * @since 1.0.0\n */\nasync function documentDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Document\n    });\n}\n/**\n * Returns the path to the user's download directory.\n *\n * #### Platform-specific\n *\n * - **Linux**: Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_DOWNLOAD_DIR`.\n * - **macOS**: Resolves to `$HOME/Downloads`.\n * - **Windows**: Resolves to `{FOLDERID_Downloads}`.\n * @example\n * ```typescript\n * import { downloadDir } from '@tauri-apps/api/path';\n * const downloadDirPath = await downloadDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function downloadDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Download\n    });\n}\n/**\n * Returns the path to the user's executable directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_BIN_HOME/../bin` or `$XDG_DATA_HOME/../bin` or `$HOME/.local/bin`.\n * - **macOS:** Not supported.\n * - **Windows:** Not supported.\n * @example\n * ```typescript\n * import { executableDir } from '@tauri-apps/api/path';\n * const executableDirPath = await executableDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function executableDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Executable\n    });\n}\n/**\n * Returns the path to the user's font directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_DATA_HOME/fonts` or `$HOME/.local/share/fonts`.\n * - **macOS:** Resolves to `$HOME/Library/Fonts`.\n * - **Windows:** Not supported.\n * @example\n * ```typescript\n * import { fontDir } from '@tauri-apps/api/path';\n * const fontDirPath = await fontDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function fontDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Font\n    });\n}\n/**\n * Returns the path to the user's home directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$HOME`.\n * - **macOS:** Resolves to `$HOME`.\n * - **Windows:** Resolves to `{FOLDERID_Profile}`.\n * @example\n * ```typescript\n * import { homeDir } from '@tauri-apps/api/path';\n * const homeDirPath = await homeDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function homeDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Home\n    });\n}\n/**\n * Returns the path to the user's local data directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_DATA_HOME` or `$HOME/.local/share`.\n * - **macOS:** Resolves to `$HOME/Library/Application Support`.\n * - **Windows:** Resolves to `{FOLDERID_LocalAppData}`.\n * @example\n * ```typescript\n * import { localDataDir } from '@tauri-apps/api/path';\n * const localDataDirPath = await localDataDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function localDataDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.LocalData\n    });\n}\n/**\n * Returns the path to the user's picture directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_PICTURES_DIR`.\n * - **macOS:** Resolves to `$HOME/Pictures`.\n * - **Windows:** Resolves to `{FOLDERID_Pictures}`.\n * @example\n * ```typescript\n * import { pictureDir } from '@tauri-apps/api/path';\n * const pictureDirPath = await pictureDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function pictureDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Picture\n    });\n}\n/**\n * Returns the path to the user's public directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_PUBLICSHARE_DIR`.\n * - **macOS:** Resolves to `$HOME/Public`.\n * - **Windows:** Resolves to `{FOLDERID_Public}`.\n * @example\n * ```typescript\n * import { publicDir } from '@tauri-apps/api/path';\n * const publicDirPath = await publicDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function publicDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Public\n    });\n}\n/**\n * Returns the path to the application's resource directory.\n * To resolve a resource path, see {@linkcode resolveResource}.\n *\n * ## Platform-specific\n *\n * Although we provide the exact path where this function resolves to,\n * this is not a contract and things might change in the future\n *\n * - **Windows:** Resolves to the directory that contains the main executable.\n * - **Linux:** When running in an AppImage, the `APPDIR` variable will be set to\n *   the mounted location of the app, and the resource dir will be `${APPDIR}/usr/lib/${exe_name}`.\n *   If not running in an AppImage, the path is `/usr/lib/${exe_name}`.\n *   When running the app from `src-tauri/target/(debug|release)/`, the path is `${exe_dir}/../lib/${exe_name}`.\n * - **macOS:** Resolves to `${exe_dir}/../Resources` (inside .app).\n * - **iOS:** Resolves to `${exe_dir}/assets`.\n * - **Android:** Currently the resources are stored in the APK as assets so it's not a normal file system path,\n *   we return a special URI prefix `asset://localhost/` here that can be used with the [file system plugin](https://tauri.app/plugin/file-system/),\n *\n * @example\n * ```typescript\n * import { resourceDir } from '@tauri-apps/api/path';\n * const resourceDirPath = await resourceDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function resourceDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Resource\n    });\n}\n/**\n * Resolve the path to a resource file.\n * @example\n * ```typescript\n * import { resolveResource } from '@tauri-apps/api/path';\n * const resourcePath = await resolveResource('script.sh');\n * ```\n *\n * @param resourcePath The path to the resource.\n * Must follow the same syntax as defined in `tauri.conf.json > bundle > resources`, i.e. keeping subfolders and parent dir components (`../`).\n * @returns The full path to the resource.\n *\n * @since 1.0.0\n */\nasync function resolveResource(resourcePath) {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Resource,\n        path: resourcePath\n    });\n}\n/**\n * Returns the path to the user's runtime directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `$XDG_RUNTIME_DIR`.\n * - **macOS:** Not supported.\n * - **Windows:** Not supported.\n * @example\n * ```typescript\n * import { runtimeDir } from '@tauri-apps/api/path';\n * const runtimeDirPath = await runtimeDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function runtimeDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Runtime\n    });\n}\n/**\n * Returns the path to the user's template directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_TEMPLATES_DIR`.\n * - **macOS:** Not supported.\n * - **Windows:** Resolves to `{FOLDERID_Templates}`.\n * @example\n * ```typescript\n * import { templateDir } from '@tauri-apps/api/path';\n * const templateDirPath = await templateDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function templateDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Template\n    });\n}\n/**\n * Returns the path to the user's video directory.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to [`xdg-user-dirs`](https://www.freedesktop.org/wiki/Software/xdg-user-dirs/)' `XDG_VIDEOS_DIR`.\n * - **macOS:** Resolves to `$HOME/Movies`.\n * - **Windows:** Resolves to `{FOLDERID_Videos}`.\n * @example\n * ```typescript\n * import { videoDir } from '@tauri-apps/api/path';\n * const videoDirPath = await videoDir();\n * ```\n *\n * @since 1.0.0\n */\nasync function videoDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Video\n    });\n}\n/**\n * Returns the path to the suggested directory for your app's log files.\n *\n * #### Platform-specific\n *\n * - **Linux:** Resolves to `${configDir}/${bundleIdentifier}/logs`.\n * - **macOS:** Resolves to `${homeDir}/Library/Logs/{bundleIdentifier}`\n * - **Windows:** Resolves to `${configDir}/${bundleIdentifier}/logs`.\n * @example\n * ```typescript\n * import { appLogDir } from '@tauri-apps/api/path';\n * const appLogDirPath = await appLogDir();\n * ```\n *\n * @since 1.2.0\n */\nasync function appLogDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.AppLog\n    });\n}\n/**\n * Returns a temporary directory.\n * @example\n * ```typescript\n * import { tempDir } from '@tauri-apps/api/path';\n * const temp = await tempDir();\n * ```\n *\n * @since 2.0.0\n */\nasync function tempDir() {\n    return invoke('plugin:path|resolve_directory', {\n        directory: BaseDirectory.Temp\n    });\n}\n/**\n * Returns the platform-specific path segment separator:\n * - `\\` on Windows\n * - `/` on POSIX\n *\n * @since 2.0.0\n */\nfunction sep() {\n    return window.__TAURI_INTERNALS__.plugins.path.sep;\n}\n/**\n * Returns the platform-specific path segment delimiter:\n * - `;` on Windows\n * - `:` on POSIX\n *\n * @since 2.0.0\n */\nfunction delimiter() {\n    return window.__TAURI_INTERNALS__.plugins.path.delimiter;\n}\n/**\n * Resolves a sequence of `paths` or `path` segments into an absolute path.\n * @example\n * ```typescript\n * import { resolve, appDataDir } from '@tauri-apps/api/path';\n * const appDataDirPath = await appDataDir();\n * const path = await resolve(appDataDirPath, '..', 'users', 'tauri', 'avatar.png');\n * ```\n *\n * @since 1.0.0\n */\nasync function resolve(...paths) {\n    return invoke('plugin:path|resolve', { paths });\n}\n/**\n * Normalizes the given `path`, resolving `'..'` and `'.'` segments and resolve symbolic links.\n * @example\n * ```typescript\n * import { normalize, appDataDir } from '@tauri-apps/api/path';\n * const appDataDirPath = await appDataDir();\n * const path = await normalize(`${appDataDirPath}/../users/tauri/avatar.png`);\n * ```\n *\n * @since 1.0.0\n */\nasync function normalize(path) {\n    return invoke('plugin:path|normalize', { path });\n}\n/**\n *  Joins all given `path` segments together using the platform-specific separator as a delimiter, then normalizes the resulting path.\n * @example\n * ```typescript\n * import { join, appDataDir } from '@tauri-apps/api/path';\n * const appDataDirPath = await appDataDir();\n * const path = await join(appDataDirPath, 'users', 'tauri', 'avatar.png');\n * ```\n *\n * @since 1.0.0\n */\nasync function join(...paths) {\n    return invoke('plugin:path|join', { paths });\n}\n/**\n * Returns the parent directory of a given `path`. Trailing directory separators are ignored.\n * @example\n * ```typescript\n * import { dirname } from '@tauri-apps/api/path';\n * const dir = await dirname('/path/to/somedir/');\n * assert(dir === '/path/to');\n * ```\n *\n * @since 1.0.0\n */\nasync function dirname(path) {\n    return invoke('plugin:path|dirname', { path });\n}\n/**\n * Returns the extension of the `path`.\n * @example\n * ```typescript\n * import { extname } from '@tauri-apps/api/path';\n * const ext = await extname('/path/to/file.html');\n * assert(ext === 'html');\n * ```\n *\n * @since 1.0.0\n */\nasync function extname(path) {\n    return invoke('plugin:path|extname', { path });\n}\n/**\n * Returns the last portion of a `path`. Trailing directory separators are ignored.\n * @example\n * ```typescript\n * import { basename } from '@tauri-apps/api/path';\n * const base = await basename('path/to/app.conf');\n * assert(base === 'app.conf');\n * ```\n * @param ext An optional file extension to be removed from the returned path.\n *\n * @since 1.0.0\n */\nasync function basename(path, ext) {\n    return invoke('plugin:path|basename', { path, ext });\n}\n/**\n * Returns whether the path is absolute or not.\n * @example\n * ```typescript\n * import { isAbsolute } from '@tauri-apps/api/path';\n * assert(await isAbsolute('/home/tauri'));\n * ```\n *\n * @since 1.0.0\n */\nasync function isAbsolute(path) {\n    return invoke('plugin:path|is_absolute', { path });\n}\n\nexport { BaseDirectory, appCacheDir, appConfigDir, appDataDir, appLocalDataDir, appLogDir, audioDir, basename, cacheDir, configDir, dataDir, delimiter, desktopDir, dirname, documentDir, downloadDir, executableDir, extname, fontDir, homeDir, isAbsolute, join, localDataDir, normalize, pictureDir, publicDir, resolve, resolveResource, resourceDir, runtimeDir, sep, tempDir, templateDir, videoDir };\n","export { BaseDirectory } from '@tauri-apps/api/path';\nimport { Resource, invoke, Channel } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Access the file system.\n *\n * ## Security\n *\n * This module prevents path traversal, not allowing parent directory accessors to be used\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/ | path API}.\n *\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\n *\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:scope\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:allow-exists\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\n *\n * The available variables are:\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\n *\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nvar SeekMode;\n(function (SeekMode) {\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\n})(SeekMode || (SeekMode = {}));\nfunction parseFileInfo(r) {\n    return {\n        isFile: r.isFile,\n        isDirectory: r.isDirectory,\n        isSymlink: r.isSymlink,\n        size: r.size,\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\n        atime: r.atime !== null ? new Date(r.atime) : null,\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\n        readonly: r.readonly,\n        fileAttributes: r.fileAttributes,\n        dev: r.dev,\n        ino: r.ino,\n        mode: r.mode,\n        nlink: r.nlink,\n        uid: r.uid,\n        gid: r.gid,\n        rdev: r.rdev,\n        blksize: r.blksize,\n        blocks: r.blocks\n    };\n}\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\n/** Converts a big-endian eight byte array to number  */\nfunction fromBytes(buffer) {\n    const bytes = new Uint8ClampedArray(buffer);\n    const size = bytes.byteLength;\n    let x = 0;\n    for (let i = 0; i < size; i++) {\n        // eslint-disable-next-line security/detect-object-injection\n        const byte = bytes[i];\n        x *= 0x100;\n        x += byte;\n    }\n    return x;\n}\n/**\n *  The Tauri abstraction for reading and writing files.\n *\n * @since 2.0.0\n */\nclass FileHandle extends Resource {\n    /**\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async read(buffer) {\n        if (buffer.byteLength === 0) {\n            return 0;\n        }\n        const data = await invoke('plugin:fs|read', {\n            rid: this.rid,\n            len: buffer.byteLength\n        });\n        // Rust side will never return an empty array for this command and\n        // ensure there is at least 8 elements there.\n        //\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\n        // at the end of returned array to avoid serialization overhead of separate values.\n        const nread = fromBytes(data.slice(-8));\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        buffer.set(bytes.slice(0, bytes.length - 8));\n        return nread === 0 ? null : nread;\n    }\n    /**\n     * Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     *\n     * @example\n     * ```typescript\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\n     *\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async seek(offset, whence) {\n        return await invoke('plugin:fs|seek', {\n            rid: this.rid,\n            offset,\n            whence\n        });\n    }\n    /**\n     * Returns a {@linkcode FileInfo } for this file.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\n     * const fileInfo = await file.stat();\n     * console.log(fileInfo.isFile); // true\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async stat() {\n        const res = await invoke('plugin:fs|fstat', {\n            rid: this.rid\n        });\n        return parseFileInfo(res);\n    }\n    /**\n     * Truncates or extends this file, to reach the specified `len`.\n     * If `len` is not specified then the entire file contents are truncated.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // truncate the entire file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.truncate();\n     *\n     * // truncate part of the file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(7);\n     * const data = new Uint8Array(32);\n     * await file.read(data);\n     * console.log(new TextDecoder().decode(data)); // Hello W\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async truncate(len) {\n        await invoke('plugin:fs|ftruncate', {\n            rid: this.rid,\n            len\n        });\n    }\n    /**\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\n     * `data.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * @example\n     * ```typescript\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\n     * const bytesWritten = await file.write(data); // 11\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async write(data) {\n        return await invoke('plugin:fs|write', {\n            rid: this.rid,\n            data\n        });\n    }\n}\n/**\n * Creates a file if none exists or truncates an existing file and resolves to\n *  an instance of {@linkcode FileHandle }.\n *\n * @example\n * ```typescript\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n * await file.write(new TextEncoder().encode(\"Hello world\"));\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function create(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|create', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\n * file does not need to previously exist if using the `create` or `createNew`\n * open options. It is the callers responsibility to close the file when finished\n * with it.\n *\n * @example\n * ```typescript\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\n * // Do work with file\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function open(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|open', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function copyFile(fromPath, toPath, options) {\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:')\n        || (toPath instanceof URL && toPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|copy_file', {\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\n        options\n    });\n}\n/**\n * Creates a new directory with the specified path.\n * @example\n * ```typescript\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function mkdir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|mkdir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads the directory given by path and returns an array of `DirEntry`.\n * @example\n * ```typescript\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * import { join } from '@tauri-apps/api/path';\n * const dir = \"users\"\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\n * processEntriesRecursively(dir, entries);\n * async function processEntriesRecursively(parent, entries) {\n *   for (const entry of entries) {\n *     console.log(`Entry: ${entry.name}`);\n *     if (entry.isDirectory) {\n *        const dir = await join(parent, entry.name);\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\n *     }\n *   }\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function readDir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|read_dir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads and resolves to the entire contents of a file as an array of bytes.\n * TextDecoder can be used to transform the bytes to string if required.\n * @example\n * ```typescript\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\n * ```\n *\n * @since 2.0.0\n */\nasync function readFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n}\n/**\n * Reads and returns the entire contents of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function readTextFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_text_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\n * for await (const line of lines) {\n *   console.log(line);\n * }\n * ```\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\n * iterator so you can lazily read the next line whenever you want.\n *\n * @since 2.0.0\n */\nasync function readTextFileLines(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const pathStr = path instanceof URL ? path.toString() : path;\n    return await Promise.resolve({\n        path: pathStr,\n        rid: null,\n        async next() {\n            if (this.rid === null) {\n                this.rid = await invoke('plugin:fs|read_text_file_lines', {\n                    path: pathStr,\n                    options\n                });\n            }\n            const arr = await invoke('plugin:fs|read_text_file_lines_next', { rid: this.rid });\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n            // Rust side will never return an empty array for this command and\n            // ensure there is at least one elements there.\n            //\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\n            // at the end of returned array to avoid serialization overhead of separate values.\n            const done = bytes[bytes.byteLength - 1] === 1;\n            if (done) {\n                // a full iteration is over, reset rid for next iteration\n                this.rid = null;\n                return { value: null, done };\n            }\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength - 1));\n            return {\n                value: line,\n                done\n            };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    });\n}\n/**\n * Removes the named file or directory.\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\n * @example\n * ```typescript\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function remove(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|remove', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\n * If newpath already exists and is not a directory, rename() replaces it.\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\n *\n * On Unix, this operation does not follow symlinks at either path.\n *\n * @example\n * ```typescript\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function rename(oldPath, newPath, options) {\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:')\n        || (newPath instanceof URL && newPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|rename', {\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\n        options\n    });\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\n *\n * @example\n * ```typescript\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function stat(path, options) {\n    const res = await invoke('plugin:fs|stat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\n * symlink, information for the symlink will be returned instead of what it\n * points to.\n *\n * @example\n * ```typescript\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function lstat(path, options) {\n    const res = await invoke('plugin:fs|lstat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Truncates or extends the specified file, to reach the specified `len`.\n * If `len` is `0` or not specified, then the entire file contents are truncated.\n *\n * @example\n * ```typescript\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // truncate the entire file\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\n *\n * // truncate part of the file\n * const filePath = \"file.txt\";\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\n * console.log(data);  // \"Hello W\"\n * ```\n *\n * @since 2.0.0\n */\nasync function truncate(path, len, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|truncate', {\n        path: path instanceof URL ? path.toString() : path,\n        len,\n        options\n    });\n}\n/**\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n *\n * let encoder = new TextEncoder();\n * let data = encoder.encode(\"Hello World\");\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function writeFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    if (data instanceof ReadableStream) {\n        const file = await open(path, {\n            read: false,\n            create: true,\n            write: true,\n            ...options\n        });\n        const reader = data.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                await file.write(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n            await file.close();\n        }\n    }\n    else {\n        await invoke('plugin:fs|write_file', data, {\n            headers: {\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n                options: JSON.stringify(options)\n            }\n        });\n    }\n}\n/**\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\n    @example\n  * ```typescript\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n  *\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\n  * ```\n  *\n  * @since 2.0.0\n  */\nasync function writeTextFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const encoder = new TextEncoder();\n    await invoke('plugin:fs|write_text_file', encoder.encode(data), {\n        headers: {\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n            options: JSON.stringify(options)\n        }\n    });\n}\n/**\n * Check if a path exists.\n * @example\n * ```typescript\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Check if the `$APPDATA/avatar.png` file exists\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\n * ```\n *\n * @since 2.0.0\n */\nasync function exists(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|exists', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\nclass Watcher extends Resource {\n}\nasync function watchInternal(paths, cb, options) {\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new Channel();\n    onEvent.onmessage = cb;\n    const rid = await invoke('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options,\n        onEvent\n    });\n    const watcher = new Watcher(rid);\n    return () => {\n        void watcher.close();\n    };\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes (after a delay) on files or directories.\n *\n * @since 2.0.0\n */\nasync function watch(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        delayMs: 2000,\n        ...options\n    });\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes on files or directories.\n *\n * @since 2.0.0\n */\nasync function watchImmediate(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        ...options,\n        delayMs: undefined\n    });\n}\n/**\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\n *\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\n *\n * @example\n * ```typescript\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Get the size of the `$APPDATA/tauri` directory.\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\n * console.log(dirSize); // 1024\n * ```\n *\n * @since 2.1.0\n */\nasync function size(path) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|size', {\n        path: path instanceof URL ? path.toString() : path\n    });\n}\n\nexport { FileHandle, SeekMode, copyFile, create, exists, lstat, mkdir, open, readDir, readFile, readTextFile, readTextFileLines, remove, rename, size, stat, truncate, watch, watchImmediate, writeFile, writeTextFile };\n","import { join } from '@tauri-apps/api/path';\nimport { isContentURI, isFileURI, isValidURL } from './misc';\n\nexport const getFilename = (fileOrUri: string) => {\n  if (isValidURL(fileOrUri) || isContentURI(fileOrUri) || isFileURI(fileOrUri)) {\n    fileOrUri = decodeURI(fileOrUri);\n  }\n  const normalizedPath = fileOrUri.replace(/\\\\/g, '/');\n  const parts = normalizedPath.split('/');\n  const lastPart = parts.pop()!;\n  return lastPart.split('?')[0]!;\n};\n\nexport const getBaseFilename = (filename: string) => {\n  const normalizedPath = filename.replace(/\\\\/g, '/');\n  const name = normalizedPath.split('/').pop() || '';\n\n  const parts = name.split('.');\n  if (parts.length <= 1) {\n    return name;\n  }\n\n  return parts.slice(0, -1).join('.');\n};\n\nexport const getDirPath = (filePath: string) => {\n  const normalizedPath = filePath.replace(/\\\\/g, '/');\n  const parts = normalizedPath.split('/');\n  parts.pop();\n  return parts.join('/');\n};\n\nexport const joinPaths = async (...paths: string[]) => {\n  return await join(...paths);\n};\n","import { FileHandle, open, BaseDirectory, SeekMode } from '@tauri-apps/plugin-fs';\nimport { getOSPlatform } from './misc';\n\nclass DeferredBlob extends Blob {\n  #dataPromise: Promise<ArrayBuffer>;\n  #type: string;\n\n  constructor(dataPromise: Promise<ArrayBuffer>, type: string) {\n    super();\n    this.#dataPromise = dataPromise;\n    this.#type = type;\n  }\n\n  override async arrayBuffer() {\n    const data = await this.#dataPromise;\n    return data;\n  }\n\n  override async text() {\n    const data = await this.#dataPromise;\n    return new TextDecoder().decode(data);\n  }\n\n  override stream() {\n    return new ReadableStream({\n      start: async (controller) => {\n        const data = await this.#dataPromise;\n        const reader = new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(data));\n            controller.close();\n          },\n        }).getReader();\n        const pump = () =>\n          reader.read().then(({ done, value }): Promise<void> => {\n            if (done) {\n              controller.close();\n              return Promise.resolve();\n            }\n            controller.enqueue(value);\n            return pump();\n          });\n        return pump();\n      },\n    });\n  }\n\n  override get type() {\n    return this.#type;\n  }\n}\n\nexport interface ClosableFile extends File {\n  open(): Promise<this>;\n  close(): Promise<void>;\n}\n\nexport class NativeFile extends File implements ClosableFile {\n  #handle: FileHandle | null = null;\n  #fp: string;\n  #name: string;\n  #baseDir: BaseDirectory | null;\n  #lastModified: number = 0;\n  #size: number = -1;\n  #type: string = '';\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 1024;\n  static MAX_CACHE_ITEMS_SIZE = 50;\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map();\n  #pendingReads: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  constructor(fp: string, name?: string, baseDir: BaseDirectory | null = null, type = '') {\n    super([], name || fp, { type });\n    this.#fp = fp;\n    this.#baseDir = baseDir;\n    this.#name = name || fp;\n  }\n\n  async open() {\n    this.#handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    const stats = await this.#handle.stat();\n    this.#size = stats.size;\n    this.#lastModified = stats.mtime ? stats.mtime.getTime() : Date.now();\n    return this;\n  }\n\n  async close() {\n    if (this.#handle) {\n      await this.#handle.close();\n      this.#handle = null;\n    }\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async stat() {\n    return this.#handle?.stat();\n  }\n\n  async seek(offset: number, whence: SeekMode): Promise<number> {\n    if (!this.#handle) {\n      throw new Error('File handle is not open');\n    }\n    return this.#handle.seek(offset, whence);\n  }\n\n  // exclusive reading of the end: [start, end)\n  async readData(start: number, end: number): Promise<ArrayBuffer> {\n    start = Math.max(0, start);\n    end = Math.max(start, Math.min(this.size, end));\n    const size = end - start;\n\n    if (size > NativeFile.MAX_CACHE_CHUNK_SIZE) {\n      const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n      try {\n        await handle.seek(start, SeekMode.Start);\n        const buffer = new Uint8Array(size);\n        await handle.read(buffer);\n        return buffer.buffer;\n      } finally {\n        await handle.close();\n      }\n    }\n\n    const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n      const buffer = this.#cache.get(chunkStart)!;\n      return start >= chunkStart && end <= chunkStart + buffer.byteLength;\n    });\n\n    if (cachedChunkStart !== undefined) {\n      this.#updateAccessOrder(cachedChunkStart);\n      const buffer = this.#cache.get(cachedChunkStart)!;\n      const offset = start - cachedChunkStart;\n      return buffer.slice(offset, offset + size);\n    }\n\n    const readKey = `${start}-${end}`;\n    const pendingRead = this.#pendingReads.get(readKey);\n\n    if (pendingRead) {\n      return pendingRead;\n    }\n\n    const readPromise = this.#readAndCacheChunkSafe(start, size);\n    this.#pendingReads.set(readKey, readPromise);\n\n    try {\n      return await readPromise;\n    } finally {\n      this.#pendingReads.delete(readKey);\n    }\n  }\n\n  async #readAndCacheChunkSafe(start: number, size: number): Promise<ArrayBuffer> {\n    const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    try {\n      const chunkStart = Math.max(0, start - 1024);\n      const chunkEnd = Math.min(this.size, start + NativeFile.MAX_CACHE_CHUNK_SIZE);\n      const chunkSize = chunkEnd - chunkStart;\n\n      await handle.seek(chunkStart, SeekMode.Start);\n      const buffer = new Uint8Array(chunkSize);\n      await handle.read(buffer);\n\n      // Only one thread reaches here per unique range\n      this.#cache.set(chunkStart, buffer.buffer);\n      this.#updateAccessOrder(chunkStart);\n      this.#ensureCacheSize();\n\n      const offset = start - chunkStart;\n      return buffer.buffer.slice(offset, offset + size);\n    } finally {\n      await handle.close();\n    }\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > NativeFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.readData(start, end);\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override stream(): ReadableStream<Uint8Array<ArrayBuffer>> {\n    const CHUNK_SIZE = 1024 * 1024;\n    let offset = 0;\n\n    return new ReadableStream<Uint8Array<ArrayBuffer>>({\n      pull: async (controller) => {\n        if (!this.#handle) {\n          controller.error(new Error('File handle is not open'));\n          return;\n        }\n\n        if (offset >= this.size) {\n          controller.close();\n          return;\n        }\n\n        const end = Math.min(offset + CHUNK_SIZE, this.size);\n        const buffer = new Uint8Array(end - offset);\n\n        await this.#handle.seek(offset, SeekMode.Start);\n        const bytesRead = await this.#handle.read(buffer);\n\n        if (bytesRead === null || bytesRead === 0) {\n          controller.close();\n          return;\n        }\n\n        controller.enqueue(buffer.subarray(0, bytesRead));\n        offset += bytesRead;\n      },\n\n      cancel: async () => {\n        await this.#handle?.close();\n      },\n    });\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n\nexport class RemoteFile extends File implements ClosableFile {\n  url: string;\n  #name: string;\n  #lastModified: number;\n  #size: number = -1;\n  #type: string = '';\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map(); // LRU cache\n  #pendingFetches: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 128;\n  static MAX_CACHE_ITEMS_SIZE: number = 128;\n\n  constructor(url: string, name?: string, type = '', lastModified = Date.now()) {\n    const basename = url.split('/').pop() || 'remote-file';\n    super([], name || basename, { type, lastModified });\n    this.url = url;\n    this.#name = name || basename;\n    this.#type = type;\n    this.#lastModified = lastModified;\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async _open_with_head() {\n    const response = await fetch(this.url, { method: 'HEAD' });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-length'));\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async _open_with_range() {\n    const response = await fetch(this.url, { headers: { Range: `bytes=${0}-${1023}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-range')?.split('/')[1]);\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async open() {\n    // FIXME: currently HEAD request in asset protocol is not supported on Android\n    if (getOSPlatform() === 'android') {\n      return this._open_with_range();\n    } else {\n      return this._open_with_head();\n    }\n  }\n\n  async close(): Promise<void> {\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  async fetchRangePart(start: number, end: number) {\n    start = Math.max(0, start);\n    end = Math.min(this.size - 1, end);\n    // console.log(`Fetching range: ${start}-${end}, size: ${end - start + 1}`);\n    const response = await fetch(this.url, { headers: { Range: `bytes=${start}-${end}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch range: ${response.status}`);\n    }\n    return response.arrayBuffer();\n  }\n\n  // inclusive reading of the end: [start, end]\n  async fetchRange(start: number, end: number): Promise<ArrayBuffer> {\n    const rangeSize = end - start + 1;\n    const MAX_RANGE_LEN = 1024 * 1000;\n\n    if (rangeSize > MAX_RANGE_LEN) {\n      const buffers: ArrayBuffer[] = [];\n      for (let currentStart = start; currentStart <= end; currentStart += MAX_RANGE_LEN) {\n        const currentEnd = Math.min(currentStart + MAX_RANGE_LEN - 1, end);\n        buffers.push(await this.fetchRangePart(currentStart, currentEnd));\n      }\n      const totalSize = buffers.reduce((sum, buffer) => sum + buffer.byteLength, 0);\n      const combinedBuffer = new Uint8Array(totalSize);\n      let offset = 0;\n      for (const buffer of buffers) {\n        combinedBuffer.set(new Uint8Array(buffer), offset);\n        offset += buffer.byteLength;\n      }\n      return combinedBuffer.buffer;\n    } else if (rangeSize > RemoteFile.MAX_CACHE_CHUNK_SIZE) {\n      return this.fetchRangePart(start, end);\n    } else {\n      const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n        const buffer = this.#cache.get(chunkStart)!;\n        const bufferSize = buffer.byteLength;\n        return start >= chunkStart && end <= chunkStart + bufferSize;\n      });\n      if (cachedChunkStart !== undefined) {\n        this.#updateAccessOrder(cachedChunkStart);\n        const buffer = this.#cache.get(cachedChunkStart)!;\n        const offset = start - cachedChunkStart;\n        return buffer.slice(offset, offset + rangeSize);\n      }\n\n      const fetchKey = `${start}-${end}`;\n      const pendingFetch = this.#pendingFetches.get(fetchKey);\n\n      if (pendingFetch) {\n        return pendingFetch;\n      }\n\n      const fetchPromise = this.#fetchAndCacheChunkSafe(start, end, rangeSize);\n      this.#pendingFetches.set(fetchKey, fetchPromise);\n      try {\n        return await fetchPromise;\n      } finally {\n        this.#pendingFetches.delete(fetchKey);\n      }\n    }\n  }\n\n  async #fetchAndCacheChunkSafe(\n    start: number,\n    end: number,\n    rangeSize: number,\n  ): Promise<ArrayBuffer> {\n    const chunkStart = Math.max(0, start - 1024);\n    const chunkEnd = Math.max(end, start + RemoteFile.MAX_CACHE_CHUNK_SIZE - 1024 - 1);\n    const buffer = await this.fetchRangePart(chunkStart, chunkEnd);\n\n    // Only one thread reaches here per unique range\n    this.#cache.set(chunkStart, buffer);\n    this.#updateAccessOrder(chunkStart);\n    this.#ensureCacheSize();\n\n    const offset = start - chunkStart;\n    return buffer.slice(offset, offset + rangeSize);\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > RemoteFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.fetchRange(start, end - 1);\n\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n","import { randomUUID } from 'crypto';\nexport default { randomUUID };\n","import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n","import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { BookMetadata } from '@/libs/document';\nimport { TTSHighlightOptions } from '@/services/tts/types';\nimport { AnnotationToolType } from './annotator';\n\nexport type BookFormat =\n  | 'EPUB'\n  | 'PDF'\n  | 'MOBI'\n  | 'AZW'\n  | 'AZW3'\n  | 'CBZ'\n  | 'FB2'\n  | 'FBZ'\n  | 'TXT'\n  | 'MD';\nexport type BookNoteType = 'bookmark' | 'annotation' | 'excerpt';\nexport type HighlightStyle = 'highlight' | 'underline' | 'squiggly';\nexport type HighlightColor = 'red' | 'yellow' | 'green' | 'blue' | 'violet';\n\nexport const FIXED_LAYOUT_FORMATS: Set<BookFormat> = new Set(['PDF', 'CBZ']);\n\nexport interface Book {\n  // if Book is a remote book we just lazy load the book content via url\n  url?: string;\n  // if Book is a transient local book we can load the book content via filePath\n  filePath?: string;\n  // For local storage mode: relative path from storage root (e.g., \"fiction/book.epub\")\n  relativePath?: string;\n  // Absolute file path in the file system (for path reconciliation)\n  absolutePath?: string;\n  // Partial md5 hash of the book file, used as the unique identifier\n  hash: string;\n  // Metadata md5 hash, used to aggregate different versions of the same book\n  metaHash?: string;\n  format: BookFormat;\n  title: string; // editable title from metadata\n  sourceTitle?: string; // parsed when the book is imported and used to locate the file\n  author: string;\n  group?: string; // deprecated in favor of groupId and groupName\n  groupId?: string;\n  groupName?: string;\n  tags?: string[];\n  coverImageUrl?: string | null;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n\n  uploadedAt?: number | null;\n  downloadedAt?: number | null;\n  coverDownloadedAt?: number | null;\n  syncedAt?: number | null;\n\n  lastUpdated?: number; // deprecated in favor of updatedAt\n  progress?: [number, number]; // Add progress field: [current, total], 1-based page number\n  primaryLanguage?: string;\n\n  metadata?: BookMetadata;\n}\n\nexport interface BookGroupType {\n  id: string;\n  name: string;\n}\n\nexport interface PageInfo {\n  current: number;\n  next?: number;\n  total: number;\n}\n\n// Remaining time of the book in minutes\nexport interface TimeInfo {\n  section: number;\n  total: number;\n}\n\nexport interface BookNote {\n  bookHash?: string;\n  metaHash?: string;\n  id: string;\n  type: BookNoteType;\n  cfi: string;\n  text?: string;\n  style?: HighlightStyle;\n  color?: HighlightColor;\n  note: string;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n}\n\nexport interface BooknoteGroup {\n  id: number;\n  href: string;\n  label: string;\n  booknotes: BookNote[];\n}\n\nexport type WritingMode = 'auto' | 'horizontal-tb' | 'horizontal-rl' | 'vertical-rl';\n\nexport interface BookLayout {\n  marginTopPx: number;\n  marginBottomPx: number;\n  marginLeftPx: number;\n  marginRightPx: number;\n  marginPx?: number; // deprecated\n  compactMarginTopPx: number;\n  compactMarginBottomPx: number;\n  compactMarginLeftPx: number;\n  compactMarginRightPx: number;\n  compactMarginPx?: number; // deprecated\n  gapPercent: number;\n  scrolled: boolean;\n  disableClick: boolean;\n  fullscreenClickArea: boolean;\n  swapClickArea: boolean;\n  disableDoubleClick: boolean;\n  volumeKeysToFlip: boolean;\n  continuousScroll: boolean;\n  maxColumnCount: number;\n  maxInlineSize: number;\n  maxBlockSize: number;\n  animated: boolean;\n  isEink: boolean;\n  writingMode: WritingMode;\n  vertical: boolean;\n  rtl: boolean;\n  scrollingOverlap: number;\n  allowScript: boolean;\n}\n\nexport interface BookStyle {\n  zoomLevel: number;\n  paragraphMargin: number;\n  lineHeight: number;\n  wordSpacing: number;\n  letterSpacing: number;\n  textIndent: number;\n  fullJustification: boolean;\n  hyphenation: boolean;\n  invertImgColorInDark: boolean;\n  theme: string;\n  overrideFont: boolean;\n  overrideLayout: boolean;\n  overrideColor: boolean;\n  backgroundTextureId: string;\n  backgroundOpacity: number;\n  backgroundSize: string;\n  codeHighlighting: boolean;\n  codeLanguage: string;\n  userStylesheet: string;\n  userUIStylesheet: string;\n\n  // fixed-layout specific\n  zoomMode: 'fit-page' | 'fit-width' | 'original-size' | 'custom';\n  spreadMode: 'auto' | 'none';\n  keepCoverSpread: boolean;\n}\n\nexport interface BookFont {\n  serifFont: string;\n  sansSerifFont: string;\n  monospaceFont: string;\n  defaultFont: string;\n  defaultCJKFont: string;\n  defaultFontSize: number;\n  minimumFontSize: number;\n  fontWeight: number;\n}\n\nexport type ConvertChineseVariant =\n  | 'none'\n  | 's2t'\n  | 't2s'\n  | 's2tw'\n  | 's2hk'\n  | 's2twp'\n  | 'tw2s'\n  | 'hk2s'\n  | 'tw2sp';\n\nexport interface BookLanguage {\n  replaceQuotationMarks: boolean;\n  convertChineseVariant: ConvertChineseVariant;\n}\n\nexport interface ViewConfig {\n  sideBarTab: string;\n  uiLanguage: string;\n  sortedTOC: boolean;\n\n  doubleBorder: boolean;\n  borderColor: string;\n\n  showHeader: boolean;\n  showFooter: boolean;\n  showRemainingTime: boolean;\n  showRemainingPages: boolean;\n  showProgressInfo: boolean;\n  tapToToggleFooter: boolean;\n  showBarsOnScroll: boolean;\n  showMarginsOnScroll: boolean;\n  progressStyle: 'percentage' | 'fraction';\n  progressInfoMode: 'remaining' | 'progress' | 'all' | 'none';\n}\n\nexport interface TTSConfig {\n  ttsRate: number;\n  ttsVoice: string;\n  ttsLocation: string;\n  showTTSBar: boolean;\n  ttsHighlightOptions: TTSHighlightOptions;\n}\n\nexport interface TranslatorConfig {\n  translationEnabled: boolean;\n  translationProvider: string;\n  translateTargetLang: string;\n  showTranslateSource: boolean;\n  ttsReadAloudText: string;\n}\n\nexport interface NoteExportConfig {\n  includeTitle: boolean;\n  includeAuthor: boolean;\n  includeDate: boolean;\n  includeChapterTitles: boolean;\n  includeQuotes: boolean;\n  includeNotes: boolean;\n  includeTimestamp: boolean;\n  includeChapterSeparator: boolean;\n  noteSeparator: string;\n  useCustomTemplate: boolean;\n  customTemplate: string;\n}\n\nexport interface AnnotatorConfig {\n  enableAnnotationQuickActions: boolean;\n  annotationQuickAction: AnnotationToolType | null;\n  copyToNotebook: boolean;\n  noteExportConfig: NoteExportConfig;\n}\n\nexport interface ScreenConfig {\n  screenOrientation: 'auto' | 'portrait' | 'landscape';\n}\n\nexport type ProofreadScope = 'selection' | 'book' | 'library';\n\nexport interface ProofreadRule {\n  id: string;\n  scope: ProofreadScope;\n  pattern: string;\n  replacement: string;\n  cfi?: string;\n  sectionHref?: string;\n  enabled: boolean;\n  isRegex: boolean;\n  order: number; // Lower numbers apply first\n  wholeWord?: boolean; // Match whole words only (uses \\b word boundaries)\n  caseSensitive?: boolean; // Case-sensitive matching (default true)\n  onlyForTTS?: boolean; // Only replace text for TTS, not in the book display (only for book/library scope)\n}\n\nexport interface ProofreadRulesConfig {\n  proofreadRules?: ProofreadRule[];\n}\n\nexport interface ViewSettings\n  extends BookLayout,\n  BookStyle,\n  BookFont,\n  BookLanguage,\n  ViewConfig,\n  TTSConfig,\n  TranslatorConfig,\n  ScreenConfig,\n  ProofreadRulesConfig,\n  AnnotatorConfig { }\n\nexport interface BookProgress {\n  location: string;\n  sectionId: number;\n  sectionHref: string;\n  sectionLabel: string;\n  section: PageInfo;\n  pageinfo: PageInfo;\n  timeinfo: TimeInfo;\n  range: Range;\n}\n\nexport interface BookSearchConfig {\n  scope: 'book' | 'section';\n  matchCase: boolean;\n  matchWholeWords: boolean;\n  matchDiacritics: boolean;\n  index?: number;\n  query?: string;\n  acceptNode?: (node: Node) => number;\n\n  // pre-cached search results\n  results?: BookSearchResult[] | BookSearchMatch[] | null;\n}\n\nexport interface SearchExcerpt {\n  pre: string;\n  match: string;\n  post: string;\n}\n\nexport interface BookSearchMatch {\n  cfi: string;\n  excerpt: SearchExcerpt;\n}\n\nexport interface BookSearchResult {\n  index?: number;\n  label: string;\n  subitems: BookSearchMatch[];\n  progress?: number;\n}\n\nexport interface BookConfig {\n  bookHash?: string;\n  metaHash?: string;\n  progress?: [number, number]; // [current pagenum, total pagenum], 1-based page number\n  location?: string; // CFI of the current location\n  xpointer?: string; // XPointer of the current location (for Koreader interoperability)\n  booknotes?: BookNote[];\n  searchConfig?: Partial<BookSearchConfig>;\n  viewSettings?: Partial<ViewSettings>;\n\n  lastSyncedAtConfig?: number;\n  lastSyncedAtNotes?: number;\n\n  updatedAt: number;\n}\n\nexport interface BookDataRecord {\n  id: string;\n  book_hash: string;\n  meta_hash?: string;\n  user_id: string;\n  updated_at: number | null;\n  deleted_at: number | null;\n}\n\nexport interface BooksGroup {\n  id: string;\n  name: string;\n  displayName: string;\n  books: Book[];\n\n  updatedAt: number;\n}\nexport interface BookContent {\n  book: Book;\n  file: File;\n}\n","import { BookFormat } from '@/types/book';\nimport { Contributor, Identifier, LanguageMap } from '@/utils/book';\nimport * as epubcfi from 'foliate-js/epubcfi.js';\n\nexport const CFI = epubcfi;\n\nexport type DocumentFile = File;\n\nexport type Location = {\n  current: number;\n  next: number;\n  total: number;\n};\n\nexport interface TOCItem {\n  id: number;\n  label: string;\n  href: string;\n  cfi?: string;\n  location?: Location;\n  subitems?: TOCItem[];\n}\n\nexport interface SectionItem {\n  id: string;\n  cfi: string;\n  size: number;\n  linear: string;\n  location?: Location;\n  pageSpread?: 'left' | 'right' | 'center' | '';\n\n  createDocument: () => Promise<Document>;\n}\n\nexport type BookMetadata = {\n  // NOTE: the title and author fields should be formatted\n  title: string | LanguageMap;\n  author: string | Contributor;\n  language: string | string[];\n  editor?: string;\n  publisher?: string;\n  published?: string;\n  description?: string;\n  subject?: string | string[] | Contributor;\n  identifier?: string;\n  altIdentifier?: string | string[] | Identifier;\n\n  subtitle?: string;\n  series?: string;\n  seriesIndex?: number;\n  seriesTotal?: number;\n\n  coverImageFile?: string;\n  coverImageUrl?: string;\n  coverImageBlobUrl?: string;\n};\n\nexport interface BookDoc {\n  metadata: BookMetadata;\n  rendition?: {\n    layout?: 'pre-paginated' | 'reflowable';\n    spread?: 'auto' | 'none';\n    viewport?: { width: number; height: number };\n  };\n  dir: string;\n  toc?: Array<TOCItem>;\n  sections?: Array<SectionItem>;\n  transformTarget?: EventTarget;\n  splitTOCHref(href: string): Array<string | number>;\n  getCover(): Promise<Blob | null>;\n}\n\nexport const EXTS: Record<BookFormat, string> = {\n  EPUB: 'epub',\n  PDF: 'pdf',\n  MOBI: 'mobi',\n  AZW: 'azw',\n  AZW3: 'azw3',\n  CBZ: 'cbz',\n  FB2: 'fb2',\n  FBZ: 'fbz',\n  TXT: 'txt',\n  MD: 'md',\n};\n\nexport const MIMETYPES: Record<BookFormat, string[]> = {\n  EPUB: ['application/epub+zip'],\n  PDF: ['application/pdf'],\n  MOBI: ['application/x-mobipocket-ebook'],\n  AZW: ['application/vnd.amazon.ebook'],\n  AZW3: ['application/vnd.amazon.mobi8-ebook', 'application/x-mobi8-ebook'],\n  CBZ: ['application/vnd.comicbook+zip', 'application/zip', 'application/x-cbz'],\n  FB2: ['application/x-fictionbook+xml', 'text/xml', 'application/xml'],\n  FBZ: ['application/x-zip-compressed-fb2', 'application/zip'],\n  TXT: ['text/plain'],\n  MD: ['text/markdown', 'text/x-markdown'],\n};\n\nexport class DocumentLoader {\n  private file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  private async isZip(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 4).arrayBuffer());\n    return arr[0] === 0x50 && arr[1] === 0x4b && arr[2] === 0x03 && arr[3] === 0x04;\n  }\n\n  private async isPDF(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 5).arrayBuffer());\n    return (\n      arr[0] === 0x25 && arr[1] === 0x50 && arr[2] === 0x44 && arr[3] === 0x46 && arr[4] === 0x2d\n    );\n  }\n\n  private async makeZipLoader() {\n    const getComment = async (): Promise<string | null> => {\n      const EOCD_SIGNATURE = [0x50, 0x4b, 0x05, 0x06];\n      const maxEOCDSearch = 1024 * 64;\n\n      const sliceSize = Math.min(maxEOCDSearch, this.file.size);\n      const tail = await this.file.slice(this.file.size - sliceSize, this.file.size).arrayBuffer();\n      const bytes = new Uint8Array(tail);\n\n      for (let i = bytes.length - 22; i >= 0; i--) {\n        if (\n          bytes[i] === EOCD_SIGNATURE[0] &&\n          bytes[i + 1] === EOCD_SIGNATURE[1] &&\n          bytes[i + 2] === EOCD_SIGNATURE[2] &&\n          bytes[i + 3] === EOCD_SIGNATURE[3]\n        ) {\n          const commentLength = bytes[i + 20]! + (bytes[i + 21]! << 8);\n          const commentStart = i + 22;\n          const commentBytes = bytes.slice(commentStart, commentStart + commentLength);\n          return new TextDecoder().decode(commentBytes);\n        }\n      }\n\n      return null;\n    };\n\n    const { configure, ZipReader, BlobReader, TextWriter, BlobWriter } = await import(\n      '@zip.js/zip.js'\n    );\n    type Entry = import('@zip.js/zip.js').Entry;\n    configure({ useWebWorkers: false });\n    const reader = new ZipReader(new BlobReader(this.file));\n    const entries = await reader.getEntries();\n    const map = new Map(entries.map((entry) => [entry.filename, entry]));\n    const load =\n      (f: (entry: Entry, type?: string) => Promise<string | Blob> | null) =>\n      (name: string, ...args: [string?]) =>\n        map.has(name) ? f(map.get(name)!, ...args) : null;\n\n    const loadText = load((entry: Entry) =>\n      entry.getData ? entry.getData(new TextWriter()) : null,\n    );\n    const loadBlob = load((entry: Entry, type?: string) =>\n      entry.getData ? entry.getData(new BlobWriter(type!)) : null,\n    );\n    const getSize = (name: string) => map.get(name)?.uncompressedSize ?? 0;\n\n    return { entries, loadText, loadBlob, getSize, getComment, sha1: undefined };\n  }\n\n  private isCBZ(): boolean {\n    return (\n      this.file.type === 'application/vnd.comicbook+zip' || this.file.name.endsWith(`.${EXTS.CBZ}`)\n    );\n  }\n\n  private isFB2(): boolean {\n    return (\n      this.file.type === 'application/x-fictionbook+xml' || this.file.name.endsWith(`.${EXTS.FB2}`)\n    );\n  }\n\n  private isFBZ(): boolean {\n    return (\n      this.file.type === 'application/x-zip-compressed-fb2' ||\n      this.file.name.endsWith('.fb.zip') ||\n      this.file.name.endsWith('.fb2.zip') ||\n      this.file.name.endsWith(`.${EXTS.FBZ}`)\n    );\n  }\n\n  public async open(): Promise<{ book: BookDoc; format: BookFormat }> {\n    let book = null;\n    let format: BookFormat = 'EPUB';\n    if (!this.file.size) {\n      throw new Error('File is empty');\n    }\n    try {\n      if (await this.isZip()) {\n        const loader = await this.makeZipLoader();\n        const { entries } = loader;\n\n        if (this.isCBZ()) {\n          const { makeComicBook } = await import('foliate-js/comic-book.js');\n          book = await makeComicBook(loader, this.file);\n          format = 'CBZ';\n        } else if (this.isFBZ()) {\n          const entry = entries.find((entry) => entry.filename.endsWith(`.${EXTS.FB2}`));\n          const blob = await loader.loadBlob((entry ?? entries[0]!).filename);\n          const { makeFB2 } = await import('foliate-js/fb2.js');\n          book = await makeFB2(blob);\n          format = 'FBZ';\n        } else {\n          const { EPUB } = await import('foliate-js/epub.js');\n          book = await new EPUB(loader).init();\n          format = 'EPUB';\n        }\n      } else if (await this.isPDF()) {\n        const { makePDF } = await import('foliate-js/pdf.js');\n        book = await makePDF(this.file);\n        format = 'PDF';\n      } else if (await (await import('foliate-js/mobi.js')).isMOBI(this.file)) {\n        const fflate = await import('foliate-js/vendor/fflate.js');\n        const { MOBI } = await import('foliate-js/mobi.js');\n        book = await new MOBI({ unzlib: fflate.unzlibSync }).open(this.file);\n        const ext = this.file.name.split('.').pop()?.toLowerCase();\n        switch (ext) {\n          case 'azw':\n            format = 'AZW';\n            break;\n          case 'azw3':\n            format = 'AZW3';\n            break;\n          default:\n            format = 'MOBI';\n        }\n      } else if (this.isFB2()) {\n        const { makeFB2 } = await import('foliate-js/fb2.js');\n        book = await makeFB2(this.file);\n        format = 'FB2';\n      }\n    } catch (e: unknown) {\n      console.error('Failed to open document:', e);\n      if (e instanceof Error && e.message?.includes('not a valid zip')) {\n        throw new Error('Unsupported or corrupted book file');\n      }\n      throw e;\n    }\n    return { book, format } as { book: BookDoc; format: BookFormat };\n  }\n}\n\nexport const getDirection = (doc: Document) => {\n  const { defaultView } = doc;\n  const { writingMode, direction } = defaultView!.getComputedStyle(doc.body);\n  const vertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr';\n  const rtl = doc.body.dir === 'rtl' || direction === 'rtl' || doc.documentElement.dir === 'rtl';\n  return { vertical, rtl };\n};\n\nexport const getFileExtFromMimeType = (mimeType?: string): string => {\n  if (!mimeType) return '';\n\n  for (const format in MIMETYPES) {\n    const list = MIMETYPES[format as BookFormat];\n    if (list.includes(mimeType)) {\n      return EXTS[format as BookFormat];\n    }\n  }\n  return '';\n};\n\nexport const getMimeTypeFromFileExt = (ext: string): string => {\n  ext = ext.toLowerCase();\n  for (const format in EXTS) {\n    if (EXTS[format as BookFormat] === ext) {\n      const mimeTypes = MIMETYPES[format as BookFormat];\n      return mimeTypes[0] || 'application/octet-stream';\n    }\n  }\n  return 'application/octet-stream';\n};\n","import { BookMetadata, EXTS } from '@/libs/document';\nimport { Book, BookConfig, BookProgress, WritingMode } from '@/types/book';\nimport { SUPPORTED_LANGS } from '@/services/constants';\nimport { getUserLang } from './misc';\nimport { getDirFromLanguage } from './rtl';\nimport { code6392to6391, isValidLang, normalizedLangCode } from './lang';\nimport { md5 } from './md5';\n\nexport const getDir = (book: Book) => {\n  // In local storage mode, return the folder name (same as book name without extension)\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath.replace(/\\.[^.]+$/, '');\n};\nexport const getLibraryFilename = () => {\n  return 'library.json';\n};\nexport const getLibraryBackupFilename = () => {\n  return 'library_backup.json';\n};\nexport const getLocalBookFilename = (book: Book) => {\n  // In local storage mode, books are stored in their original relative paths\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath;\n};\nexport const getCoverFilename = (book: Book) => {\n  // In local storage mode, covers are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  const result = `${pathWithoutExt}/cover.png`;\n  console.log('[getCoverFilename]  Using relativePath:', book.relativePath);\n  console.log('[getCoverFilename]  Cover path result:', result);\n  return result;\n};\nexport const getConfigFilename = (book: Book) => {\n  // In local storage mode, configs are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  return `${pathWithoutExt}/config.json`;\n};\nexport const isBookFile = (filename: string) => {\n  return Object.values(EXTS).includes(filename.split('.').pop()!);\n};\n\nexport const INIT_BOOK_CONFIG: BookConfig = {\n  updatedAt: 0,\n};\n\nexport interface LanguageMap {\n  [key: string]: string;\n}\n\nexport interface Identifier {\n  scheme: string;\n  value: string;\n}\n\nexport interface Contributor {\n  name: LanguageMap;\n}\n\nconst formatLanguageMap = (x: string | LanguageMap, defaultLang = false): string => {\n  const userLang = getUserLang();\n  if (!x) return '';\n  if (typeof x === 'string') return x;\n  const keys = Object.keys(x);\n  return defaultLang ? x[keys[0]!]! : x[userLang] || x[keys[0]!]!;\n};\n\nexport const listFormater = (narrow = false, lang = '') => {\n  lang = lang ? lang : getUserLang();\n  if (narrow) {\n    return new Intl.ListFormat('en', { style: 'narrow', type: 'unit' });\n  } else {\n    return new Intl.ListFormat(lang, { style: 'long', type: 'conjunction' });\n  }\n};\n\nexport const getBookLangCode = (lang: string | string[] | undefined) => {\n  try {\n    const bookLang = typeof lang === 'string' ? lang : lang?.[0];\n    return bookLang ? bookLang.split('-')[0]! : '';\n  } catch {\n    return '';\n  }\n};\n\nexport const flattenContributors = (\n  contributors: string | string[] | Contributor | Contributor[],\n) => {\n  if (!contributors) return '';\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string' ? contributor : formatLanguageMap(contributor?.name),\n      )\n      .join(', ')\n    : typeof contributors === 'string'\n      ? contributors\n      : formatLanguageMap(contributors?.name);\n};\n\n// prettier-ignore\nconst LASTNAME_AUTHOR_SORT_LANGS = ['ar', 'bo', 'de', 'en', 'es', 'fr', 'hi', 'it', 'nl', 'pl', 'pt', 'ru', 'th', 'tr', 'uk'];\n\nconst formatAuthorName = (name: string, lastNameFirst: boolean) => {\n  if (!name) return '';\n  const parts = name.split(' ');\n  if (lastNameFirst && parts.length > 1) {\n    return `${parts[parts.length - 1]}, ${parts.slice(0, -1).join(' ')}`;\n  }\n  return name;\n};\n\nexport const formatAuthors = (\n  contributors: string | string[] | Contributor | Contributor[],\n  bookLang?: string | string[],\n  sortAs?: boolean,\n) => {\n  const langCode = getBookLangCode(bookLang) || 'en';\n  const lastNameFirst = !!sortAs && LASTNAME_AUTHOR_SORT_LANGS.includes(langCode);\n  return Array.isArray(contributors)\n    ? listFormater(langCode === 'zh', langCode).format(\n      contributors.map((contributor) =>\n        typeof contributor === 'string'\n          ? formatAuthorName(contributor, lastNameFirst)\n          : formatAuthorName(formatLanguageMap(contributor?.name), lastNameFirst),\n      ),\n    )\n    : typeof contributors === 'string'\n      ? formatAuthorName(contributors, lastNameFirst)\n      : formatAuthorName(formatLanguageMap(contributors?.name), lastNameFirst);\n};\n\nexport const formatTitle = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title);\n};\n\nexport const formatDescription = (description?: string | LanguageMap) => {\n  if (!description) return '';\n  const text = typeof description === 'string' ? description : formatLanguageMap(description);\n  return text\n    .replace(/<\\/?[^>]+(>|$)/g, '')\n    .replace(/&#\\d+;/g, '')\n    .trim();\n};\n\nexport const formatPublisher = (publisher: string | LanguageMap) => {\n  return typeof publisher === 'string' ? publisher : formatLanguageMap(publisher);\n};\n\nconst langCodeToLangName = (langCode: string) => {\n  return SUPPORTED_LANGS[langCode] || langCode.toUpperCase();\n};\n\nexport const formatLanguage = (lang: string | string[] | undefined): string => {\n  return Array.isArray(lang)\n    ? lang.map(langCodeToLangName).join(', ')\n    : langCodeToLangName(lang || '');\n};\n\n// Should return valid ISO-639-1 language code, fallback to 'en' if not valid\nexport const getPrimaryLanguage = (lang: string | string[] | undefined) => {\n  const primaryLang = Array.isArray(lang) ? lang[0] : lang;\n  if (isValidLang(primaryLang)) {\n    const normalizedLang = normalizedLangCode(primaryLang);\n    return code6392to6391(normalizedLang) || normalizedLang;\n  }\n  return 'en';\n};\n\nexport const formatDate = (date: string | number | Date | null | undefined, isUTC = false) => {\n  if (!date) return;\n  const userLang = getUserLang();\n  try {\n    return new Date(date).toLocaleDateString(userLang, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      timeZone: isUTC ? 'UTC' : undefined,\n    });\n  } catch {\n    return;\n  }\n};\n\nexport const formatBytes = (bytes?: number | null, locale = 'en-US') => {\n  if (!bytes) return '';\n  const units = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte'];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  const value = bytes / Math.pow(1024, i);\n  const formatter = new Intl.NumberFormat(locale, {\n    style: 'unit',\n    unit: units[i],\n    unitDisplay: 'short',\n    maximumFractionDigits: 2,\n  });\n  return formatter.format(value);\n};\n\nexport const getCurrentPage = (book: Book, progress: BookProgress) => {\n  const bookFormat = book.format;\n  const { section, pageinfo } = progress;\n  return bookFormat === 'PDF'\n    ? section\n      ? section.current + 1\n      : 0\n    : pageinfo\n      ? pageinfo.current + 1\n      : 0;\n};\n\nexport const getBookDirFromWritingMode = (writingMode: WritingMode) => {\n  switch (writingMode) {\n    case 'horizontal-tb':\n      return 'ltr';\n    case 'horizontal-rl':\n    case 'vertical-rl':\n      return 'rtl';\n    default:\n      return 'auto';\n  }\n};\n\nexport const getBookDirFromLanguage = (language: string | string[] | undefined) => {\n  const lang = getPrimaryLanguage(language) || '';\n  return getDirFromLanguage(lang);\n};\n\nconst getTitleForHash = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title, true);\n};\n\nconst getAuthorsList = (contributors: string | string[] | Contributor | Contributor[]) => {\n  if (!contributors) return [];\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string'\n          ? contributor\n          : formatLanguageMap(contributor?.name, true),\n      )\n      .filter(Boolean)\n    : [\n      typeof contributors === 'string'\n        ? contributors\n        : formatLanguageMap(contributors?.name, true),\n    ];\n};\n\nconst normalizeIdentifier = (identifier: string) => {\n  try {\n    if (identifier.includes('urn:')) {\n      // Slice after the last ':'\n      return identifier.match(/[^:]+$/)?.[0] || '';\n    } else if (identifier.includes(':')) {\n      // Slice after the first ':'\n      return identifier.match(/^[^:]+:(.+)$/)?.[1] || '';\n    }\n  } catch {\n    return identifier;\n  }\n  return identifier;\n};\n\nconst getPreferredIdentifier = (identifiers: string[] | Identifier[]) => {\n  for (const scheme of ['uuid', 'calibre', 'isbn']) {\n    const found = identifiers.find((identifier) =>\n      typeof identifier === 'string'\n        ? identifier.toLowerCase().includes(scheme)\n        : identifier.scheme.toLowerCase() === scheme,\n    );\n    if (found) {\n      return typeof found === 'string' ? normalizeIdentifier(found) : found.value;\n    }\n  }\n  return;\n};\n\nconst getIdentifiersList = (\n  identifiers: undefined | string | string[] | Identifier | Identifier[],\n) => {\n  if (!identifiers) return [];\n  if (Array.isArray(identifiers)) {\n    const preferred = getPreferredIdentifier(identifiers);\n    if (preferred) {\n      return [preferred];\n    }\n  }\n  return Array.isArray(identifiers)\n    ? identifiers\n      .map((identifier) =>\n        typeof identifier === 'string' ? normalizeIdentifier(identifier) : identifier.value,\n      )\n      .filter(Boolean)\n    : typeof identifiers === 'string'\n      ? [normalizeIdentifier(identifiers)]\n      : [identifiers.value];\n};\n\nexport const getMetadataHash = (metadata: BookMetadata) => {\n  try {\n    const title = getTitleForHash(metadata.title);\n    const authors = getAuthorsList(metadata.author).join(',');\n    const identifiers = getIdentifiersList(metadata.altIdentifier || metadata.identifier).join(',');\n    const hashSource = `${title}|${authors}|${identifiers}`;\n    const metaHash = md5(hashSource.normalize('NFC'));\n    return metaHash;\n  } catch (error) {\n    console.error('Error generating metadata hash:', error);\n  }\n  return;\n};\n","import { getUserLang } from './misc';\n\nexport const getDirFromLanguage = (lang: string) => {\n  if (!lang) return 'auto';\n  const rtlLanguages = new Set(['ar', 'he', 'fa', 'ur', 'dv', 'ps', 'sd', 'yi']);\n  const primaryLang = lang.split('-')[0]!.toLowerCase();\n  return rtlLanguages.has(primaryLang) ? 'rtl' : 'auto';\n};\n\nexport const getDirFromUILanguage = () => {\n  const lang = getUserLang();\n  return getDirFromLanguage(lang);\n};\n","import { md5 } from 'js-md5';\n\nexport function isMd5(value: string): boolean {\n  return /^[0-9a-f]{32}$/.test(value);\n}\n\nexport function md5Fingerprint(value: string): string {\n  return md5(value).slice(0, 7);\n}\n\nexport async function partialMD5(file: File): Promise<string> {\n  const step = 1024;\n  const size = 1024;\n  const hasher = md5.create();\n\n  for (let i = -1; i <= 10; i++) {\n    const start = Math.min(file.size, step << (2 * i));\n    const end = Math.min(start + size, file.size);\n\n    if (start >= file.size) break;\n\n    const blobSlice = file.slice(start, end);\n    const arrayBuffer = await blobSlice.arrayBuffer();\n    const uint8Array = new Uint8Array(arrayBuffer);\n\n    hasher.update(uint8Array);\n  }\n\n  return hasher.hex();\n}\n\nexport { md5 };\n","import { v4 as uuidv4 } from 'uuid';\nimport { SystemSettings } from '@/types/settings';\nimport {\n  AppPlatform,\n  AppService,\n  DistChannel,\n  FileItem,\n  OsPlatform,\n  ResolvedPath,\n  SelectDirectoryMode,\n} from '@/types/system';\nimport { FileSystem, BaseDir, DeleteAction } from '@/types/system';\nimport {\n  Book,\n  BookConfig,\n  BookContent,\n  BookFormat,\n  FIXED_LAYOUT_FORMATS,\n  ViewSettings,\n} from '@/types/book';\nimport {\n  getDir,\n  getLocalBookFilename,\n  getCoverFilename,\n  getConfigFilename,\n  getLibraryFilename,\n  INIT_BOOK_CONFIG,\n  formatTitle,\n  formatAuthors,\n  getPrimaryLanguage,\n  getLibraryBackupFilename,\n} from '@/utils/book';\nimport { md5, partialMD5, md5Fingerprint } from '@/utils/md5';\nimport { getBaseFilename, getFilename } from '@/utils/path';\nimport { BookDoc, DocumentLoader, EXTS } from '@/libs/document';\nimport {\n  DEFAULT_BOOK_LAYOUT,\n  DEFAULT_BOOK_STYLE,\n  DEFAULT_BOOK_FONT,\n  DEFAULT_BOOK_LANGUAGE,\n  DEFAULT_VIEW_CONFIG,\n  DEFAULT_READSETTINGS,\n  SYSTEM_SETTINGS_VERSION,\n  DEFAULT_BOOK_SEARCH_CONFIG,\n  DEFAULT_TTS_CONFIG,\n  DEFAULT_MOBILE_VIEW_SETTINGS,\n  DEFAULT_SYSTEM_SETTINGS,\n  DEFAULT_CJK_VIEW_SETTINGS,\n  DEFAULT_MOBILE_READSETTINGS,\n  DEFAULT_SCREEN_CONFIG,\n  DEFAULT_TRANSLATOR_CONFIG,\n  DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS,\n  SETTINGS_FILENAME,\n  DEFAULT_MOBILE_SYSTEM_SETTINGS,\n  DEFAULT_ANNOTATOR_CONFIG,\n  DEFAULT_EINK_VIEW_SETTINGS,\n} from './constants';\nimport { cachedFetchAsUrl } from '@/utils/cachedFetch';\nimport { fetch as tauriFetch } from '@tauri-apps/plugin-http';\nimport {\n  getOSPlatform,\n  getTargetLang,\n  isCJKEnv,\n  isContentURI,\n  isValidURL,\n  makeSafeFilename,\n} from '@/utils/misc';\nimport { deserializeConfig, serializeConfig } from '@/utils/serializer';\nimport { ClosableFile } from '@/utils/file';\nimport { TxtToEpubConverter } from '@/utils/txt';\nimport { BOOK_FILE_NOT_FOUND_ERROR } from './errors';\nimport { CustomTextureInfo } from '@/styles/textures';\nimport { CustomFont, CustomFontInfo } from '@/styles/fonts';\nimport { parseFontInfo } from '@/utils/font';\nimport { svg2png } from '@/utils/svg';\n\nexport abstract class BaseAppService implements AppService {\n  osPlatform: OsPlatform = getOSPlatform();\n  appPlatform: AppPlatform = 'tauri';\n  localBooksDir = '';\n  isMobile = false;\n  isMacOSApp = false;\n  isLinuxApp = false;\n  isAppDataSandbox = false;\n  isAndroidApp = false;\n  isIOSApp = false;\n  isMobileApp = false;\n  isPortableApp = false;\n  isDesktopApp = false;\n  isEink = false;\n  hasTrafficLight = false;\n  hasWindow = false;\n  hasWindowBar = false;\n  hasContextMenu = false;\n  hasRoundedWindow = false;\n  hasSafeAreaInset = false;\n  hasHaptics = false;\n  hasUpdater = false;\n  hasOrientationLock = false;\n  hasScreenBrightness = false;\n  hasIAP = false;\n  canCustomizeRootDir = false;\n  canReadExternalDir = false;\n  distChannel = 'readest' as DistChannel;\n\n  protected CURRENT_MIGRATION_VERSION = 20260121;\n\n  protected abstract fs: FileSystem;\n  protected abstract resolvePath(fp: string, base: BaseDir): ResolvedPath;\n\n  abstract init(): Promise<void>;\n  abstract setCustomRootDir(customRootDir: string): Promise<void>;\n  abstract selectDirectory(mode: SelectDirectoryMode): Promise<string>;\n  abstract selectFiles(name: string, extensions: string[]): Promise<string[]>;\n  abstract saveFile(\n    filename: string,\n    content: string | ArrayBuffer,\n    filepath: string,\n    mimeType?: string,\n  ): Promise<boolean>;\n\n  protected async runMigrations(lastMigrationVersion: number): Promise<void> {\n    if (lastMigrationVersion < 20251124) {\n      try {\n        await this.migrate20251124();\n      } catch (error) {\n        console.error('Error migrating to version 20251124:', error);\n      }\n    }\n\n    if (lastMigrationVersion < 20260121) {\n      try {\n        await this.migrate20260121();\n      } catch (error) {\n        console.error('Error migrating to version 20260121:', error);\n      }\n    }\n  }\n\n  async prepareBooksDir() {\n    this.localBooksDir = await this.fs.getPrefix('Books');\n    // Initialize configuration files in .readest directory\n    await this.ensureConfigFilesExist();\n  }\n\n  /**\n   * Ensure settings.json and library.json exist in .readest directory\n   * If they don't exist, create them with default values\n   */\n  private async ensureConfigFilesExist(): Promise<void> {\n    try {\n      // Check and create settings.json if needed\n      const settingsExists = await this.fs.exists(SETTINGS_FILENAME, 'Settings');\n      if (!settingsExists) {\n        console.log('[Init] settings.json not found, creating with defaults...');\n        const defaultSettings = {\n          ...DEFAULT_SYSTEM_SETTINGS,\n          ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n          version: SYSTEM_SETTINGS_VERSION,\n          localBooksDir: await this.fs.getPrefix('Books'),\n          globalReadSettings: {\n            ...DEFAULT_READSETTINGS,\n            ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n          },\n          globalViewSettings: this.getDefaultViewSettings(),\n        } as SystemSettings;\n        await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', defaultSettings);\n        console.log('[Init]  settings.json created successfully');\n      }\n\n      // Check and create library.json if needed\n      const libraryFilename = getLibraryFilename();\n      const libraryExists = await this.fs.exists(libraryFilename, 'Books');\n      if (!libraryExists) {\n        console.log('[Init] library.json not found, creating with defaults...');\n        await this.safeSaveJSON(libraryFilename, 'Books', []);\n        console.log('[Init]  library.json created successfully');\n      }\n\n      console.log('[Init]  All configuration files are ready');\n    } catch (error) {\n      console.error('[Init] Error ensuring config files exist:', error);\n      // Don't throw, continue with defaults\n    }\n  }\n\n  async openFile(path: string, base: BaseDir): Promise<File> {\n    return await this.fs.openFile(path, base);\n  }\n\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir): Promise<void> {\n    return await this.fs.copyFile(srcPath, dstPath, base);\n  }\n\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    return await this.fs.readFile(path, base, mode);\n  }\n\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    return await this.fs.writeFile(path, base, content);\n  }\n\n  async createDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.createDir(path, base, recursive);\n  }\n\n  async deleteFile(path: string, base: BaseDir): Promise<void> {\n    return await this.fs.removeFile(path, base);\n  }\n\n  async deleteDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.removeDir(path, base, recursive);\n  }\n\n  async resolveFilePath(path: string, base: BaseDir): Promise<string> {\n    const prefix = await this.fs.getPrefix(base);\n    return path ? `${prefix}/${path}` : prefix;\n  }\n\n  async readDirectory(path: string, base: BaseDir): Promise<FileItem[]> {\n    return await this.fs.readDir(path, base);\n  }\n\n  async exists(path: string, base: BaseDir): Promise<boolean> {\n    return await this.fs.exists(path, base);\n  }\n\n  async getImageURL(path: string): Promise<string> {\n    return await this.fs.getImageURL(path);\n  }\n\n  getCoverImageUrl = (book: Book): string => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n    const resolvedPath = this.fs.resolvePath(coverPath, 'Books');\n    return this.fs.getURL(resolvedPath.fp) || `${this.localBooksDir}/${coverPath}`;\n  };\n\n  getCoverImageBlobUrl = async (book: Book): Promise<string> => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n\n    //  web  Blob URL\n    if (this.appPlatform === 'web') {\n      try {\n        const coverUrl = this.fs.getURL(this.fs.resolvePath(coverPath, 'Books').fp) ||\n          `${this.localBooksDir}/${coverPath}`;\n\n        //  Blob URL 30 \n        return await cachedFetchAsUrl(coverUrl, {\n          cacheStrategy: 'cache-first',\n          cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n        }).catch(() => {\n          // \n          return `${this.localBooksDir}/${coverPath}`;\n        });\n      } catch {\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    } else {\n      try {\n        return await this.fs.getBlobURL(coverPath, 'Books');\n      } catch {\n        // Fallback to old path if the new path doesn't exist\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    }\n  };\n\n  async getCachedImageUrl(pathOrUrl: string): Promise<string> {\n    const cachedKey = `img_${md5(pathOrUrl)}`;\n    const cachePrefix = await this.fs.getPrefix('Cache');\n    const cachedPath = `${cachePrefix}/${cachedKey}`;\n    if (await this.fs.exists(cachedPath, 'None')) {\n      return await this.fs.getImageURL(cachedPath);\n    } else {\n      const file = await this.fs.openFile(pathOrUrl, 'None');\n      await this.fs.writeFile(cachedKey, 'Cache', await file.arrayBuffer());\n      return await this.fs.getImageURL(cachedPath);\n    }\n  }\n\n  getDefaultViewSettings(): ViewSettings {\n    return {\n      ...DEFAULT_BOOK_LAYOUT,\n      ...DEFAULT_BOOK_STYLE,\n      ...DEFAULT_BOOK_FONT,\n      ...DEFAULT_BOOK_LANGUAGE,\n      ...(this.isMobile ? DEFAULT_MOBILE_VIEW_SETTINGS : {}),\n      ...(this.isEink ? DEFAULT_EINK_VIEW_SETTINGS : {}),\n      ...(isCJKEnv() ? DEFAULT_CJK_VIEW_SETTINGS : {}),\n      ...DEFAULT_VIEW_CONFIG,\n      ...DEFAULT_TTS_CONFIG,\n      ...DEFAULT_SCREEN_CONFIG,\n      ...DEFAULT_ANNOTATOR_CONFIG,\n      ...{ ...DEFAULT_TRANSLATOR_CONFIG, translateTargetLang: getTargetLang() },\n    };\n  }\n\n  async loadSettings(): Promise<SystemSettings> {\n    const defaultSettings: SystemSettings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      version: SYSTEM_SETTINGS_VERSION,\n      localBooksDir: await this.fs.getPrefix('Books'),\n      koreaderSyncDeviceId: uuidv4(),\n      globalReadSettings: {\n        ...DEFAULT_READSETTINGS,\n        ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      },\n      globalViewSettings: this.getDefaultViewSettings(),\n    } as SystemSettings;\n\n    let settings = await this.safeLoadJSON<SystemSettings>(\n      SETTINGS_FILENAME,\n      'Settings',\n      defaultSettings,\n    );\n\n    const version = settings.version ?? 0;\n    if (this.isAppDataSandbox || version < SYSTEM_SETTINGS_VERSION) {\n      settings.version = SYSTEM_SETTINGS_VERSION;\n    }\n    settings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      ...settings,\n    };\n    settings.globalReadSettings = {\n      ...DEFAULT_READSETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      ...settings.globalReadSettings,\n    };\n    settings.globalViewSettings = {\n      ...this.getDefaultViewSettings(),\n      ...settings.globalViewSettings,\n    };\n\n    settings.localBooksDir = await this.fs.getPrefix('Books');\n\n    if (!settings.kosync.deviceId) {\n      settings.kosync.deviceId = uuidv4();\n      await this.saveSettings(settings);\n    }\n\n    this.localBooksDir = settings.localBooksDir;\n    return settings;\n  }\n\n  async saveSettings(settings: SystemSettings): Promise<void> {\n    await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', settings);\n  }\n\n  async importFont(file?: string | File): Promise<CustomFontInfo | null> {\n    let fontPath: string;\n    let fontFile: File;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      fontPath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, fontPath, 'Fonts');\n      fontFile = await this.fs.openFile(fontPath, 'Fonts');\n    } else if (file) {\n      fontPath = getFilename(file.name);\n      await this.fs.writeFile(fontPath, 'Fonts', file);\n      fontFile = file;\n    } else {\n      return null;\n    }\n\n    return {\n      path: fontPath,\n      ...parseFontInfo(await fontFile.arrayBuffer(), fontPath),\n    };\n  }\n\n  async deleteFont(font: CustomFont): Promise<void> {\n    await this.fs.removeFile(font.path, 'Fonts');\n  }\n\n  async importImage(file?: string | File): Promise<CustomTextureInfo | null> {\n    let imagePath: string;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      imagePath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, imagePath, 'Images');\n    } else if (file) {\n      imagePath = getFilename(file.name);\n      await this.fs.writeFile(imagePath, 'Images', file);\n    } else {\n      return null;\n    }\n\n    return {\n      name: imagePath.replace(/\\.[^/.]+$/, ''),\n      path: imagePath,\n    };\n  }\n\n  async deleteImage(texture: CustomTextureInfo): Promise<void> {\n    await this.fs.removeFile(texture.path, 'Images');\n  }\n\n  async importBook(\n    // file might be:\n    // 1.1 absolute path for local file on Desktop\n    // 1.2 /private/var inbox file path on iOS\n    // 2. remote url\n    // 3. content provider uri\n    // 4. File object from browsers\n    file: string | File,\n    books: Book[],\n    saveBook: boolean = true,\n    saveCover: boolean = true,\n    overwrite: boolean = false,\n    transient: boolean = false,\n    options?: {\n      /** Desired relative path (e.g. \"/.epub\"), only used in local mode */\n      targetRelativePath?: string;\n      /** Desired group name, used to derive path when targetRelativePath is not provided */\n      targetGroupName?: string;\n    },\n  ): Promise<Book | null> {\n    const startTime = Date.now();\n    let filename = '';\n\n    try {\n      let loadedBook: BookDoc;\n      let format: BookFormat;\n      let fileobj: File;\n\n      if (transient && typeof file !== 'string') {\n        throw new Error('Transient import is only supported for file paths');\n      }\n\n      try {\n        if (typeof file === 'string') {\n          fileobj = await this.fs.openFile(file, 'None');\n          filename = fileobj.name || getFilename(file);\n        } else {\n          fileobj = file;\n          filename = file.name;\n        }\n\n        // \n        const fileSizeMB = fileobj.size / (1024 * 1024);\n        console.log(`[importBook] Processing: ${filename}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // \n        if (fileobj.size === 0) {\n          throw new Error('Invalid or empty book file');\n        }\n\n        // \n        if (fileobj.size > 100 * 1024 * 1024) {\n          console.warn(`[importBook]  Large file: ${fileSizeMB.toFixed(2)} MB, processing may take longer`);\n        }\n\n        if (/\\.txt$/i.test(filename)) {\n          const txt2epub = new TxtToEpubConverter();\n          ({ file: fileobj } = await txt2epub.convert({ file: fileobj }));\n        }\n\n        console.log(`[importBook] Opening document: ${filename}`);\n        ({ book: loadedBook, format } = await new DocumentLoader(fileobj).open());\n\n        if (!loadedBook) {\n          throw new Error('Unsupported or corrupted book file');\n        }\n        const metadataTitle = formatTitle(loadedBook.metadata.title);\n        if (!metadataTitle || !metadataTitle.trim() || metadataTitle === filename) {\n          loadedBook.metadata.title = getBaseFilename(filename);\n        }\n\n        console.log(`[importBook]  Document opened successfully: ${filename}`);\n      } catch (error) {\n        const errorMsg = (error as Error).message || String(error);\n        console.error(`[importBook]  Failed to open book: ${filename}`, errorMsg);\n        throw new Error(`Failed to open the book: ${errorMsg}`);\n      }\n\n      console.log(`[importBook] Computing hash for: ${filename}`);\n      const hash = await partialMD5(fileobj);\n      const existingBook = books.filter((b) => b.hash === hash)[0];\n      const now = Date.now();\n      if (existingBook) {\n        if (!transient) {\n          existingBook.deletedAt = null;\n        }\n        existingBook.createdAt = now;\n        existingBook.updatedAt = now;\n      }\n\n      const primaryLanguage = getPrimaryLanguage(loadedBook.metadata.language);\n      const book: Book = {\n        hash,\n        format,\n        title: formatTitle(loadedBook.metadata.title),\n        sourceTitle: formatTitle(loadedBook.metadata.title),\n        primaryLanguage,\n        author: formatAuthors(loadedBook.metadata.author, primaryLanguage),\n        createdAt: existingBook ? existingBook.createdAt : now,\n        uploadedAt: existingBook ? existingBook.uploadedAt : (transient ? null : now),\n        deletedAt: transient ? now : null,\n        downloadedAt: now,\n        updatedAt: now,\n      };\n      // update book metadata when reimporting the same book\n      if (existingBook) {\n        existingBook.format = book.format;\n        existingBook.title = existingBook.title.trim() ? existingBook.title.trim() : book.title;\n        existingBook.sourceTitle = existingBook.sourceTitle ?? book.sourceTitle;\n        existingBook.author = existingBook.author ?? book.author;\n        existingBook.primaryLanguage = existingBook.primaryLanguage ?? book.primaryLanguage;\n        existingBook.downloadedAt = Date.now();\n      }\n\n      // Decide whether to use new flat local storage path\n      // Check runtime window.__STORAGE_MODE__ first (set by Providers), then fallback to compile-time env var\n      const isLocalStorageMode =\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') ||\n        process.env['NEXT_PUBLIC_STORAGE_MODE'] === 'local';\n      const shouldUseLocalFlatStorage = this.appPlatform === 'web' && isLocalStorageMode;\n\n      console.log('[ImportBook] appPlatform:', this.appPlatform, 'STORAGE_MODE (runtime):', (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__), 'STORAGE_MODE (env):', process.env['NEXT_PUBLIC_STORAGE_MODE'], 'shouldUseLocalFlatStorage:', shouldUseLocalFlatStorage);\n\n      const fileExt = EXTS[format] || format.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title);\n      const targetGroupName = options?.targetGroupName?.trim();\n\n      // Compute target relative path for local mode\n      if (shouldUseLocalFlatStorage) {\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n\n        if (!derivedRelativePath) {\n          throw new Error('targetRelativePath is required for local storage mode. Please provide a valid relative path.');\n        }\n\n        book.relativePath = derivedRelativePath;\n        console.log('[ImportBook] 5. Setting book.relativePath to:', derivedRelativePath);\n        console.log('[ImportBook] 6. Book hash:', book.hash);\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n        if (targetGroupName && !book.groupName) {\n          book.groupName = targetGroupName;\n          if (existingBook && !existingBook.groupName) {\n            existingBook.groupName = targetGroupName;\n          }\n        }\n      } else if (this.appPlatform === 'web') {\n        // For web platform in remote mode, still require relativePath for consistency\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n        book.relativePath = derivedRelativePath;\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n      }\n\n      // Ensure destination directories exist (new flat structure or legacy hash-based)\n      await this.ensureLocalBookDirs(book);\n\n      const bookFilename = getLocalBookFilename(book);\n      if (saveBook && !transient && (!(await this.fs.exists(bookFilename, 'Books')) || overwrite)) {\n        if (/\\.txt$/i.test(filename)) {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        } else if (typeof file === 'string' && isContentURI(file)) {\n          await this.fs.copyFile(file, bookFilename, 'Books');\n        } else if (typeof file === 'string' && !isValidURL(file)) {\n          try {\n            // try to copy the file directly first in case of large files to avoid memory issues\n            // on desktop when reading recursively from selected directory the direct copy will fail\n            // due to permission issues, then fallback to read and write files\n            await this.fs.copyFile(file, bookFilename, 'Books');\n          } catch {\n            await this.fs.writeFile(bookFilename, 'Books', await fileobj.arrayBuffer());\n          }\n        } else {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        }\n      }\n      if (saveCover && (!(await this.fs.exists(getCoverFilename(book), 'Books')) || overwrite)) {\n        console.log('[ImportBook] 7. Preparing to save cover');\n        let cover = await loadedBook.getCover();\n        if (cover?.type === 'image/svg+xml') {\n          try {\n            console.log('[ImportBook] Converting SVG cover to PNG...');\n            cover = await svg2png(cover);\n          } catch { }\n        }\n        if (cover) {\n          const coverFilename = getCoverFilename(book);\n          console.log('[ImportBook] 8. Saving cover with filename:', coverFilename);\n          console.log('[ImportBook] 9. Cover size:', cover.size, 'bytes');\n          await this.fs.writeFile(coverFilename, 'Books', await cover.arrayBuffer());\n          console.log('[ImportBook] 10. Cover saved successfully');\n        }\n      }\n      // Never overwrite the config file only when it's not existed\n      if (!existingBook) {\n        await this.saveBookConfig(book, INIT_BOOK_CONFIG);\n        books.splice(0, 0, book);\n      }\n\n      // update file links with url or path or content uri\n      if (typeof file === 'string') {\n        if (isValidURL(file)) {\n          book.url = file;\n          if (existingBook) existingBook.url = file;\n        }\n        if (transient) {\n          book.filePath = file;\n          if (existingBook) existingBook.filePath = file;\n        }\n      }\n      book.coverImageUrl = await this.generateCoverImageUrl(book);\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n\n      const elapsed = Date.now() - startTime;\n      console.log(`[importBook]  Import completed in ${elapsed}ms: ${filename}`);\n\n      return existingBook || book;\n    } catch (error) {\n      const elapsed = Date.now() - startTime;\n      const errorMsg = (error as Error).message || String(error);\n      const errorStack = (error as Error).stack;\n\n      console.error(`[importBook]  Import failed after ${elapsed}ms`);\n      console.error(`[importBook] File: ${filename || (typeof file === 'string' ? file : 'unknown')}`);\n      console.error(`[importBook] Error: ${errorMsg}`);\n      if (errorStack) {\n        console.error(`[importBook] Stack trace:`, errorStack);\n      }\n\n      // \n      if (errorMsg.includes('memory') || errorMsg.includes('ENOMEM')) {\n        throw new Error(`${errorMsg}`);\n      }\n\n      // \n      if (errorMsg.includes('too large') || errorMsg.includes('Maximum size')) {\n        throw error;\n      }\n\n      throw error;\n    }\n  }\n\n  async importBookFromPath(\n    filePath: string,\n    relativePath: string,\n    books: Book[],\n  ): Promise<Book | null> {\n    try {\n      // Extract directory structure for grouping\n      const directory = relativePath.split('/').slice(0, -1).join('/');\n      const groupName = directory || '';\n\n      // Import the book as transient (don't copy, just reference)\n      const book = await this.importBook(\n        filePath,\n        books,\n        false, // saveBook = false\n        true,  // saveCover = true\n        false, // overwrite = false\n        true,  // transient = true\n        {\n          targetRelativePath: relativePath,\n          targetGroupName: groupName,\n        },\n      );\n\n      return book;\n    } catch (error) {\n      console.error('Error importing book from path:', filePath, error);\n      return null;\n    }\n  }\n\n  /**\n   *  - \n   * \n   */\n  async reclassifyBook(book: Book, newGroupName: string, oldGroupName?: string): Promise<void> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reclassify] ');\n      return;\n    }\n\n    //  relativePath hash-based \n    if (!book.relativePath) {\n      console.log('[Reclassify] :', book.title);\n      return;\n    }\n\n    try {\n      // \n      const settings = await this.loadSettings();\n      const groupDirectories = settings.groupDirectories || {};\n\n      //  relativePath \n      const oldRelativePath = book.relativePath;\n\n      // \n      let filename: string;\n      if (oldGroupName && oldRelativePath.startsWith(`${oldGroupName}/`)) {\n        // \n        filename = oldRelativePath.substring(oldGroupName.length + 1);\n      } else {\n        // relativePath \n        // \n        const parts = oldRelativePath.split('/');\n        filename = parts[parts.length - 1] || '';\n      }\n\n      // \n      // 1.  groupDirectories \n      // 2. \n      let targetDirectory: string;\n      if (newGroupName && groupDirectories[newGroupName]) {\n        targetDirectory = groupDirectories[newGroupName];\n      } else if (newGroupName) {\n        targetDirectory = newGroupName;\n      } else {\n        targetDirectory = '';\n      }\n\n      const newRelativePath = targetDirectory\n        ? `${targetDirectory}/${filename}`\n        : filename;\n\n      // \n      if (oldRelativePath === newRelativePath) {\n        console.log('[Reclassify] ');\n        return;\n      }\n\n      console.log('[Reclassify] ');\n      console.log('  :', oldRelativePath);\n      console.log('  :', newRelativePath);\n      console.log('  :', filename);\n      console.log('  :', newGroupName);\n      console.log('  :', targetDirectory);\n\n      //  API \n      const response = await fetch('/api/storage/reclassify', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          oldPath: oldRelativePath,\n          newPath: newRelativePath,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reclassify] :', error);\n        throw new Error(`Failed to move book files: ${error}`);\n      }\n\n      const result = await response.json();\n\n      //  book \n      book.relativePath = newRelativePath;\n      book.groupName = newGroupName || undefined;\n      //  API \n      if (result.absolutePath) {\n        book.absolutePath = result.absolutePath;\n      }\n\n      console.log('[Reclassify] :', result);\n    } catch (error) {\n      console.error('[Reclassify] :', error);\n      throw error;\n    }\n  }\n\n  async deleteBook(book: Book, deleteAction: DeleteAction): Promise<void> {\n    console.log('Deleting book with action:', deleteAction, book.title);\n    if (deleteAction === 'local' || deleteAction === 'both') {\n      const localDeleteFps =\n        deleteAction === 'local'\n          ? [getLocalBookFilename(book)]\n          : [getLocalBookFilename(book), getCoverFilename(book)];\n      for (const fp of localDeleteFps) {\n        console.log('Deleting local file:', fp);\n        await this.fs.removeFile(fp, 'Books');\n      }\n      if (deleteAction === 'local') {\n        book.downloadedAt = null;\n      } else {\n        book.deletedAt = Date.now();\n        book.downloadedAt = null;\n        book.coverDownloadedAt = null;\n      }\n    }\n    // Cloud storage delete functionality removed - using local server storage only\n    if ((deleteAction === 'cloud' || deleteAction === 'both') && book.uploadedAt) {\n      console.log('Cloud delete operation skipped - cloud storage removed');\n      book.uploadedAt = null;\n    }\n  }\n\n  // Cloud storage methods removed - using local server storage only\n\n  async exportBook(book: Book): Promise<boolean> {\n    const { file } = await this.loadBookContent(book);\n    const content = await file.arrayBuffer();\n    const filename = `${makeSafeFilename(book.title)}.${book.format.toLowerCase()}`;\n    const filepath = await this.resolveFilePath(getLocalBookFilename(book), 'Books');\n    const fileType = file.type || 'application/octet-stream';\n    return await this.saveFile(filename, content, filepath, fileType);\n  }\n\n  async isBookAvailable(book: Book): Promise<boolean> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      return true;\n    }\n    if (book.filePath) {\n      return await this.fs.exists(book.filePath, 'None');\n    }\n    if (book.url) {\n      return isValidURL(book.url);\n    }\n    return false;\n  }\n\n  async getBookFileSize(book: Book): Promise<number | null> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      const file = await this.fs.openFile(fp, 'Books');\n      const size = file.size;\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n      return size;\n    }\n    return null;\n  }\n\n  async loadBookContent(book: Book): Promise<BookContent> {\n    let file: File;\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      file = await this.fs.openFile(fp, 'Books');\n    } else if (book.filePath) {\n      file = await this.fs.openFile(book.filePath, 'None');\n    } else if (book.url) {\n      file = await this.fs.openFile(book.url, 'None');\n    } else {\n      // 0.9.64 has a bug that book.title might be modified but the filename is not updated\n      const bookDir = getDir(book);\n      const files = await this.fs.readDir(getDir(book), 'Books');\n      if (files.length > 0) {\n        const bookFile = files.find((f) => f.path.endsWith(`.${EXTS[book.format]}`));\n        if (bookFile) {\n          file = await this.fs.openFile(`${bookDir}/${bookFile.path}`, 'Books');\n        } else {\n          throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n        }\n      } else {\n        throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n      }\n    }\n    return { book, file };\n  }\n\n  async loadBookConfig(book: Book, settings: SystemSettings): Promise<BookConfig> {\n    const globalViewSettings = {\n      ...settings.globalViewSettings,\n      ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n    };\n    try {\n      let str = '{}';\n      if (await this.fs.exists(getConfigFilename(book), 'Books')) {\n        str = (await this.fs.readFile(getConfigFilename(book), 'Books', 'text')) as string;\n      }\n      return deserializeConfig(str, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } catch {\n      return deserializeConfig('{}', globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    }\n  }\n\n  async fetchBookDetails(book: Book) {\n    const fp = getLocalBookFilename(book);\n    if (!(await this.fs.exists(fp, 'Books')) && book.uploadedAt) {\n      // Cloud download functionality removed - books should already be stored locally\n      console.warn('Book file not found locally and cloud download is disabled:', book.title);\n      throw new Error('Book file not found locally');\n    }\n    const { file } = await this.loadBookContent(book);\n    const bookDoc = (await new DocumentLoader(file).open()).book;\n    const f = file as ClosableFile;\n    if (f && f.close) {\n      await f.close();\n    }\n    return bookDoc.metadata;\n  }\n\n  async saveBookConfig(book: Book, config: BookConfig, settings?: SystemSettings) {\n    let serializedConfig: string;\n    if (settings) {\n      const globalViewSettings = {\n        ...settings.globalViewSettings,\n        ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n      };\n      serializedConfig = serializeConfig(config, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } else {\n      serializedConfig = JSON.stringify(config);\n    }\n    await this.fs.writeFile(getConfigFilename(book), 'Books', serializedConfig);\n  }\n\n  async generateCoverImageUrl(book: Book): Promise<string> {\n    return this.appPlatform === 'web'\n      ? await this.getCoverImageBlobUrl(book)\n      : this.getCoverImageUrl(book);\n  }\n\n  async loadLibraryBooks(): Promise<Book[]> {\n    console.log('Loading library books...');\n    const libraryFilename = getLibraryFilename();\n\n    if (!(await this.fs.exists('', 'Books'))) {\n      await this.fs.createDir('', 'Books', true);\n    }\n\n    const books = await this.safeLoadJSON<Book[]>(libraryFilename, 'Books', []);\n\n    await Promise.all(\n      books.map(async (book) => {\n        book.coverImageUrl = await this.generateCoverImageUrl(book);\n        book.updatedAt ??= book.lastUpdated || Date.now();\n        return book;\n      }),\n    );\n\n    return books;\n  }\n\n  async saveLibraryBooks(books: Book[]): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const libraryBooks = books.map(({ coverImageUrl, ...rest }) => rest);\n    await this.safeSaveJSON(getLibraryFilename(), 'Books', libraryBooks);\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async reconcileBookPaths(books: Book[]): Promise<any> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reconcile] ');\n      return { success: false, error: 'Not in local storage mode' };\n    }\n\n    try {\n      console.log('[Reconcile] ', books.length, '');\n\n      // \n      const libraryData = books\n        .filter(book => !book.deletedAt)\n        .map(book => ({\n          hash: book.hash,\n          relativePath: book.relativePath,\n          absolutePath: book.absolutePath,\n          title: book.title,\n          groupName: book.groupName,\n        }));\n\n      const response = await fetch('/api/storage/reconcile', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ library: libraryData }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reconcile] :', error);\n        throw new Error(`Failed to reconcile paths: ${error}`);\n      }\n\n      const result = await response.json();\n      console.log('[Reconcile] :', result.summary);\n      return result;\n    } catch (error) {\n      console.error('[Reconcile] :', error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async applyReconciliation(books: Book[], reconcileResults: any[]): Promise<Book[]> {\n    const updatedBooks = [...books];\n\n    for (const result of reconcileResults) {\n      if (result.status === 'moved') {\n        // \n        const bookIndex = updatedBooks.findIndex(b => b.hash === result.hash);\n        if (bookIndex !== -1) {\n          const book = updatedBooks[bookIndex];\n          if (book) {\n            book.relativePath = result.newRelativePath;\n            book.absolutePath = result.absolutePath;\n            if (result.suggestedGroupName !== undefined) {\n              book.groupName = result.suggestedGroupName;\n              //  groupId\n              book.groupId = result.suggestedGroupName\n                ? md5Fingerprint(result.suggestedGroupName)\n                : '';\n            }\n            book.updatedAt = Date.now();\n            console.log('[Reconcile] :', book.title, ':', book.relativePath);\n          }\n        }\n      }\n    }\n\n    await this.saveLibraryBooks(updatedBooks);\n    return updatedBooks;\n  }\n\n  private imageToArrayBuffer(imageUrl?: string, imageFile?: string): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      if (!imageUrl && !imageFile) {\n        reject(new Error('No image URL or file provided'));\n        return;\n      }\n      if (this.appPlatform === 'web' && imageUrl && imageUrl.startsWith('blob:')) {\n        fetch(imageUrl)\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageFile) {\n        this.fs\n          .openFile(imageFile, 'None')\n          .then((file) => file.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageUrl) {\n        tauriFetch(imageUrl, { method: 'GET' })\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else {\n        reject(new Error('Unsupported platform or missing image data'));\n      }\n    });\n  }\n\n  async updateCoverImage(book: Book, imageUrl?: string, imageFile?: string): Promise<void> {\n    if (imageUrl === '_blank') {\n      await this.fs.removeFile(getCoverFilename(book), 'Books');\n    } else if (imageUrl || imageFile) {\n      const arrayBuffer = await this.imageToArrayBuffer(imageUrl, imageFile);\n      await this.fs.writeFile(getCoverFilename(book), 'Books', arrayBuffer);\n    }\n  }\n\n  private async loadJSONFile(\n    path: string,\n    base: BaseDir,\n  ): Promise<{ success: boolean; data?: unknown; error?: unknown }> {\n    try {\n      const txt = await this.fs.readFile(path, base, 'text');\n      if (!txt || typeof txt !== 'string' || txt.trim().length === 0) {\n        return { success: false, error: 'File is empty or invalid' };\n      }\n      try {\n        const data = JSON.parse(txt as string);\n        return { success: true, data };\n      } catch (parseError) {\n        return { success: false, error: `JSON parse error: ${parseError}` };\n      }\n    } catch (error) {\n      return { success: false, error };\n    }\n  }\n\n  /**\n   * Safely loads a JSON file with automatic backup fallback.\n   * If the main file is corrupted, attempts to load from backup.\n   * @param filename - The name of the file to load (without .bak extension)\n   * @param base - The base directory\n   * @param defaultValue - Default value to return if both files fail\n   */\n  private async safeLoadJSON<T>(filename: string, base: BaseDir, defaultValue: T): Promise<T> {\n    const backupFilename = `${filename}.bak`;\n\n    // Try loading main file\n    const mainResult = await this.loadJSONFile(filename, base);\n    if (mainResult.success) {\n      return mainResult.data as T;\n    }\n\n    console.warn(`Failed to load ${filename}, attempting backup...`, mainResult.error);\n\n    // Try loading backup file\n    const backupResult = await this.loadJSONFile(backupFilename, base);\n    if (backupResult.success) {\n      console.warn(`Loaded from backup: ${backupFilename}`);\n      // Restore the main file from backup\n      try {\n        const backupData = JSON.stringify(backupResult.data, null, 2);\n        await this.fs.writeFile(filename, base, backupData);\n        console.log(`Restored ${filename} from backup`);\n      } catch (error) {\n        console.error(`Failed to restore ${filename} from backup:`, error);\n      }\n      return backupResult.data as T;\n    }\n\n    console.error(`Both ${filename} and ${backupFilename} failed to load`);\n    return defaultValue;\n  }\n\n  /**\n   * Safely saves a JSON file with atomic write using backup strategy.\n   * Strategy: write to backup first, then to main file.\n   * This ensures at least one valid copy exists at all times.\n   * @param filename - The name of the file to save (without .bak extension)\n   * @param base - The base directory\n   * @param data - The data to save\n   */\n  private async safeSaveJSON(filename: string, base: BaseDir, data: unknown): Promise<void> {\n    const backupFilename = `${filename}.bak`;\n    const jsonData = JSON.stringify(data, null, 2);\n\n    // Strategy: Always write to backup first, then to main file\n    // This ensures we always have at least one valid copy\n    try {\n      // Step 1: Write to backup file\n      await this.fs.writeFile(backupFilename, base, jsonData);\n\n      // Step 2: Write to main file\n      await this.fs.writeFile(filename, base, jsonData);\n    } catch (error) {\n      console.error(`Failed to save ${filename}:`, error);\n      throw new Error(`Failed to save ${filename}: ${error}`);\n    }\n  }\n\n  /** Ensure necessary directories exist for a book (both legacy hash-based and new flat local paths). */\n  private async ensureLocalBookDirs(book: Book): Promise<void> {\n    if (book.relativePath) {\n      const segments = book.relativePath.split('/');\n      const fileDir = segments.slice(0, -1).join('/');\n      const metadataDir = book.relativePath.replace(/\\.[^.]+$/, '');\n\n      if (fileDir) {\n        await this.fs.createDir(fileDir, 'Books', true);\n      }\n      await this.fs.createDir(metadataDir, 'Books', true);\n      return;\n    }\n\n    // Legacy hash-based storage\n    if (!(await this.fs.exists(getDir(book), 'Books'))) {\n      await this.fs.createDir(getDir(book), 'Books');\n    }\n  }\n\n  private async migrate20251124(): Promise<void> {\n    console.log('Running migration for version 20251124 to rename the backup library file...');\n    const oldBackupFilename = getLibraryBackupFilename();\n    const newBackupFilename = `${getLibraryFilename()}.bak`;\n    if (await this.fs.exists(oldBackupFilename, 'Books')) {\n      try {\n        const content = await this.fs.readFile(oldBackupFilename, 'Books', 'text');\n        await this.fs.writeFile(newBackupFilename, 'Books', content);\n        await this.fs.removeFile(oldBackupFilename, 'Books');\n        console.log('Migration to rename backup library file completed successfully.');\n      } catch (error) {\n        console.error('Error during migration to rename backup library file:', error);\n      }\n    }\n  }\n\n  /**\n   * Migration 20260121: move legacy hash-based local books to flat relativePath layout in local mode.\n   * - Applies only when appPlatform === 'web' and STORAGE_MODE is local\n   * - For any book without relativePath, derive a flat path and move files + metadata\n   */\n  private async migrate20260121(): Promise<void> {\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    const isLocalMode = (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') === 'local';\n    if (this.appPlatform !== 'web' || !isLocalMode) {\n      console.log('[Migration 20260121] Skip (not web/local mode)');\n      return;\n    }\n\n    console.log('[Migration 20260121] Start migrating legacy hash-based books to flat layout');\n\n    const books = await this.loadLibraryBooks();\n    let migrated = 0;\n\n    for (const book of books) {\n      if (book.relativePath) continue;\n\n      const ext = EXTS[book.format] || book.format?.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title || book.hash);\n      const newRelativePath = `${book.groupName ? `${book.groupName}/` : ''}${safeBaseName}.${ext}`;\n\n      // Legacy paths\n      const legacyBookPath = `${book.hash}/${safeBaseName}.${ext}`;\n      const legacyCoverPath = `${book.hash}/cover.png`;\n      const legacyConfigPath = `${book.hash}/config.json`;\n\n      // New paths\n      const newBookPath = newRelativePath;\n      const newCoverPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/cover.png';\n      const newConfigPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/config.json';\n\n      try {\n        // Move book file if present\n        if (await this.fs.exists(legacyBookPath, 'Books')) {\n          await this.ensureLocalBookDirs({ ...book, relativePath: newRelativePath } as Book);\n          const file = await this.fs.openFile(legacyBookPath, 'Books');\n          await this.fs.writeFile(newBookPath, 'Books', file);\n          await this.fs.removeFile(legacyBookPath, 'Books');\n        }\n\n        // Move cover\n        if (await this.fs.exists(legacyCoverPath, 'Books')) {\n          const coverFile = await this.fs.openFile(legacyCoverPath, 'Books');\n          await this.fs.writeFile(newCoverPath, 'Books', coverFile);\n          await this.fs.removeFile(legacyCoverPath, 'Books');\n        }\n\n        // Move config\n        if (await this.fs.exists(legacyConfigPath, 'Books')) {\n          const configContent = await this.fs.readFile(legacyConfigPath, 'Books', 'text');\n          await this.fs.writeFile(newConfigPath, 'Books', configContent);\n          await this.fs.removeFile(legacyConfigPath, 'Books');\n        }\n\n        // Update in-memory book\n        book.relativePath = newRelativePath;\n        migrated++;\n      } catch (error) {\n        console.error('[Migration 20260121] Failed to migrate book:', book.title, error);\n      }\n    }\n\n    if (migrated > 0) {\n      await this.saveLibraryBooks(books);\n      console.log(`[Migration 20260121] Migrated ${migrated} book(s) to flat layout`);\n    } else {\n      console.log('[Migration 20260121] No legacy books to migrate');\n    }\n  }\n}\n","/**\n * IndexedDB \n * \n */\n\nconst DB_NAME = 'readest-cache';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'files';\n\nexport interface CacheEntry {\n    key: string; //  URL\n    data: ArrayBuffer;\n    etag?: string;\n    mimeType: string;\n    timestamp: number;\n    expiresAt?: number; // \n}\n\nclass IndexedDBCache {\n    private db: IDBDatabase | null = null;\n    private initPromise: Promise<void> | null = null;\n\n    async init(): Promise<void> {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n\n        this.initPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onerror = () => {\n                console.error('[IndexedDBCache] Failed to open database:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                console.log('[IndexedDBCache]  Database opened successfully');\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(STORE_NAME)) {\n                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });\n                    store.createIndex('expiresAt', 'expiresAt', { unique: false });\n                    console.log('[IndexedDBCache]  Object store created');\n                }\n            };\n        });\n\n        return this.initPromise;\n    }\n\n    /**\n     * \n     */\n    async get(key: string): Promise<CacheEntry | null> {\n        await this.init();\n        if (!this.db) return null;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entry = request.result as CacheEntry | undefined;\n\n                // \n                if (entry && entry.expiresAt && Date.now() > entry.expiresAt) {\n                    console.log('[IndexedDBCache] Cache expired for:', key);\n                    // \n                    this.delete(key).catch(e => console.error('Failed to delete expired cache:', e));\n                    resolve(null);\n                } else {\n                    if (entry) {\n                        console.log('[IndexedDBCache]  Cache hit for:', key);\n                    }\n                    resolve(entry || null);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async set(\n        key: string,\n        data: ArrayBuffer,\n        mimeType: string,\n        options?: {\n            etag?: string;\n            ttl?: number; // \n        },\n    ): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        const entry: CacheEntry = {\n            key,\n            data,\n            mimeType,\n            etag: options?.etag,\n            timestamp: Date.now(),\n            expiresAt: options?.ttl ? Date.now() + options.ttl : undefined,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(entry);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache saved for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async delete(key: string): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache deleted for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clear(): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  All caches cleared');\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clearExpired(): Promise<number> {\n        await this.init();\n        if (!this.db) return 0;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const index = store.index('expiresAt');\n            const range = IDBKeyRange.upperBound(Date.now());\n            const request = index.openCursor(range);\n\n            let deletedCount = 0;\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = (event) => {\n                const cursor = (event.target as IDBRequest).result;\n                if (cursor) {\n                    console.log('[IndexedDBCache] Deleting expired cache:', cursor.key);\n                    store.delete(cursor.primaryKey);\n                    deletedCount++;\n                    cursor.continue();\n                } else {\n                    console.log('[IndexedDBCache]  Cleared', deletedCount, 'expired caches');\n                    resolve(deletedCount);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async getStats(): Promise<{\n        totalEntries: number;\n        totalSize: number; // \n        oldestEntry?: { key: string; timestamp: number };\n        newestEntry?: { key: string; timestamp: number };\n    }> {\n        await this.init();\n        if (!this.db) {\n            return { totalEntries: 0, totalSize: 0 };\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.getAll();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entries = request.result as CacheEntry[];\n                let totalSize = 0;\n                let oldestEntry: { key: string; timestamp: number } | undefined;\n                let newestEntry: { key: string; timestamp: number } | undefined;\n\n                entries.forEach((entry) => {\n                    totalSize += entry.data.byteLength;\n                    if (!oldestEntry || entry.timestamp < oldestEntry.timestamp) {\n                        oldestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                    if (!newestEntry || entry.timestamp > newestEntry.timestamp) {\n                        newestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                });\n\n                console.log('[IndexedDBCache] Stats:', {\n                    entries: entries.length,\n                    size: (totalSize / 1024 / 1024).toFixed(2) + ' MB',\n                });\n\n                resolve({\n                    totalEntries: entries.length,\n                    totalSize,\n                    oldestEntry,\n                    newestEntry,\n                });\n            };\n        });\n    }\n}\n\nexport const indexedDBCache = new IndexedDBCache();\n","/**\n * \n * HTTP   IndexedDB  \n */\n\nimport { indexedDBCache } from './indexedDBCache';\n\nexport type FetchOptions = {\n    /**  */\n    cacheStrategy?: 'network-first' | 'cache-first' | 'stale-while-revalidate';\n    /** 0  */\n    cacheTTL?: number;\n    /**  */\n    bypassCache?: boolean;\n    /**  HTTP  */\n    headers?: Record<string, string>;\n    /**  */\n    onProgress?: (progress: number) => void;\n};\n\nconst DEFAULT_OPTIONS: FetchOptions = {\n    cacheStrategy: 'cache-first',\n    cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n};\n\n/**\n * \n */\nfunction generateCacheKey(url: string): string {\n    return `file_${url}`;\n}\n\n/**\n *  fetch \n */\nexport async function cachedFetch(\n    url: string,\n    options: FetchOptions = {},\n): Promise<{ data: ArrayBuffer; headers: Headers; fromCache: boolean }> {\n    const finalOptions = { ...DEFAULT_OPTIONS, ...options };\n    const cacheKey = generateCacheKey(url);\n\n    console.log(`[cachedFetch] Fetching: ${url}, strategy: ${finalOptions.cacheStrategy}`);\n\n    try {\n        //  1: cache-first - \n        if (\n            finalOptions.cacheStrategy === 'cache-first' &&\n            !finalOptions.bypassCache\n        ) {\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                console.log(`[cachedFetch]  Using cached data for: ${url}`);\n                // \n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    ...(cached.etag && { 'ETag': cached.etag }),\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        // \n        const fetchHeaders = new Headers(finalOptions.headers || {});\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: fetchHeaders,\n            signal: AbortSignal.timeout(30000), // 30\n        });\n\n        //  304 Not Modified\n        if (response.status === 304) {\n            console.log(`[cachedFetch] 304 Not Modified for: ${url}`);\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    'ETag': response.headers.get('ETag') || cached.etag || '',\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // \n        const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);\n        const reader = response.body?.getReader();\n        const chunks: Uint8Array[] = [];\n        let receivedLength = 0;\n\n        if (reader) {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                chunks.push(value);\n                receivedLength += value.length;\n\n                // \n                if (contentLength > 0 && finalOptions.onProgress) {\n                    const progress = Math.round((receivedLength / contentLength) * 100);\n                    finalOptions.onProgress(progress);\n                }\n            }\n        } else {\n            // Fallback  ReadableStream \n            chunks.push(new Uint8Array(await response.arrayBuffer()));\n        }\n\n        // \n        const data = new ArrayBuffer(receivedLength);\n        const dataView = new Uint8Array(data);\n        let offset = 0;\n        for (const chunk of chunks) {\n            dataView.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        // \n        const mimeType = response.headers.get('Content-Type') || 'application/octet-stream';\n        const etag = response.headers.get('ETag');\n\n        // \n        if (!finalOptions.bypassCache && response.status === 200) {\n            indexedDBCache\n                .set(cacheKey, data, mimeType, {\n                    etag: etag || undefined,\n                    ttl: finalOptions.cacheTTL,\n                })\n                .catch((error) => {\n                    console.warn(`[cachedFetch] Failed to cache ${url}:`, error);\n                });\n        }\n\n        console.log(`[cachedFetch]  Fetched ${(data.byteLength / 1024 / 1024).toFixed(2)} MB from network`);\n\n        return { data, headers: response.headers, fromCache: false };\n    } catch (error) {\n        //  network-first \n        console.warn(`[cachedFetch] Network error for ${url}:`, error);\n        const cached = await indexedDBCache.get(cacheKey);\n        if (cached) {\n            console.log(`[cachedFetch]  Using stale cache due to network error: ${url}`);\n            const headers = new Headers({\n                'Content-Type': cached.mimeType,\n                'Content-Length': cached.data.byteLength.toString(),\n                'Warning': '199 - \"Stale cache used due to network error\"',\n            });\n            return { data: cached.data, headers, fromCache: true };\n        }\n\n        throw error;\n    }\n}\n\n/**\n *  Blob URL\n */\nexport async function cachedFetchAsUrl(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data, headers } = await cachedFetch(url, options);\n    const mimeType = headers.get('Content-Type') || 'application/octet-stream';\n    const blob = new Blob([data], { type: mimeType });\n    return URL.createObjectURL(blob);\n}\n\n/**\n *  Base64\n */\nexport async function cachedFetchAsBase64(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data } = await cachedFetch(url, options);\n    const bytes = new Uint8Array(data);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]!);\n    }\n    return btoa(binary);\n}\n\n/**\n * \n */\nexport async function clearFileCache(url?: string): Promise<void> {\n    if (url) {\n        const cacheKey = generateCacheKey(url);\n        await indexedDBCache.delete(cacheKey);\n        console.log(`[cachedFetch] Cleared cache for: ${url}`);\n    } else {\n        await indexedDBCache.clear();\n        console.log('[cachedFetch] Cleared all file caches');\n    }\n}\n\n/**\n * \n */\nexport async function clearExpiredFileCache(): Promise<number> {\n    return await indexedDBCache.clearExpired();\n}\n\n/**\n * \n */\nexport async function getFileCacheStats() {\n    return await indexedDBCache.getStats();\n}\n","import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Make HTTP requests with the Rust backend.\n *\n * ## Security\n *\n * This API has a scope configuration that forces you to restrict the URLs that can be accessed using glob patterns.\n *\n * For instance, this scope configuration only allows making HTTP requests to all subdomains for `tauri.app` except for `https://private.tauri.app`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"http:default\",\n *       \"allow\": [{ \"url\": \"https://*.tauri.app\" }],\n *       \"deny\": [{ \"url\": \"https://private.tauri.app\" }]\n *     }\n *   ]\n * }\n * ```\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nconst ERROR_REQUEST_CANCELLED = 'Request cancelled';\n/**\n * Fetch a resource from the network. It returns a `Promise` that resolves to the\n * `Response` to that `Request`, whether it is successful or not.\n *\n * @example\n * ```typescript\n * const response = await fetch(\"http://my.json.host/data.json\");\n * console.log(response.status);  // e.g. 200\n * console.log(response.statusText); // e.g. \"OK\"\n * const jsonData = await response.json();\n * ```\n *\n * @since 2.0.0\n */\nasync function fetch(input, init) {\n    // Optimistically check for abort signal and avoid doing any work\n    const signal = init?.signal;\n    if (signal?.aborted) {\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    const maxRedirections = init?.maxRedirections;\n    const connectTimeout = init?.connectTimeout;\n    const proxy = init?.proxy;\n    const danger = init?.danger;\n    // Remove these fields before creating the request\n    if (init) {\n        delete init.maxRedirections;\n        delete init.connectTimeout;\n        delete init.proxy;\n        delete init.danger;\n    }\n    const headers = init?.headers\n        ? init.headers instanceof Headers\n            ? init.headers\n            : new Headers(init.headers)\n        : new Headers();\n    const req = new Request(input, init);\n    const buffer = await req.arrayBuffer();\n    const data = buffer.byteLength !== 0 ? Array.from(new Uint8Array(buffer)) : null;\n    // append new headers created by the browser `Request` implementation,\n    // if not already declared by the caller of this function\n    for (const [key, value] of req.headers) {\n        if (!headers.get(key)) {\n            headers.set(key, value);\n        }\n    }\n    const headersArray = headers instanceof Headers\n        ? Array.from(headers.entries())\n        : Array.isArray(headers)\n            ? headers\n            : Object.entries(headers);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const mappedHeaders = headersArray.map(([name, val]) => [\n        name,\n        // we need to ensure we have all header values as strings\n        // eslint-disable-next-line\n        typeof val === 'string' ? val : val.toString()\n    ]);\n    // Optimistically check for abort signal and avoid doing any work on the Rust side\n    if (signal?.aborted) {\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    const rid = await invoke('plugin:http|fetch', {\n        clientConfig: {\n            method: req.method,\n            url: req.url,\n            headers: mappedHeaders,\n            data,\n            maxRedirections,\n            connectTimeout,\n            proxy,\n            danger\n        }\n    });\n    const abort = () => invoke('plugin:http|fetch_cancel', { rid });\n    // Optimistically check for abort signal\n    // and avoid doing any work after doing intial work on the Rust side\n    if (signal?.aborted) {\n        // we don't care about the result of this proimse\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        abort();\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    signal?.addEventListener('abort', () => void abort());\n    const { status, statusText, url, headers: responseHeaders, rid: responseRid } = await invoke('plugin:http|fetch_send', {\n        rid\n    });\n    const dropBody = () => {\n        return invoke('plugin:http|fetch_cancel_body', { rid: responseRid });\n    };\n    const readChunk = async (controller) => {\n        let data;\n        try {\n            data = await invoke('plugin:http|fetch_read_body', {\n                rid: responseRid\n            });\n        }\n        catch (e) {\n            // close the stream if an error occurs\n            // and drop the body on Rust side\n            controller.error(e);\n            void dropBody();\n            return;\n        }\n        const dataUint8 = new Uint8Array(data);\n        const lastByte = dataUint8[dataUint8.byteLength - 1];\n        const actualData = dataUint8.slice(0, dataUint8.byteLength - 1);\n        // close when the signal to close (last byte is 1) is sent from the IPC.\n        if (lastByte === 1) {\n            controller.close();\n            return;\n        }\n        controller.enqueue(actualData);\n    };\n    // no body for 101, 103, 204, 205 and 304\n    // see https://fetch.spec.whatwg.org/#null-body-status\n    const body = [101, 103, 204, 205, 304].includes(status)\n        ? null\n        : new ReadableStream({\n            start: (controller) => {\n                // listen for abort events to cancel reading\n                signal?.addEventListener('abort', () => {\n                    controller.error(ERROR_REQUEST_CANCELLED);\n                    void dropBody();\n                });\n            },\n            pull: (controller) => readChunk(controller)\n        });\n    const res = new Response(body, {\n        status,\n        statusText\n    });\n    // Set `Response` properties that are ignored by the\n    // constructor, like url and some headers\n    //\n    // Since url and headers are read only properties\n    // this is the only way to set them.\n    Object.defineProperty(res, 'url', { value: url });\n    Object.defineProperty(res, 'headers', {\n        value: new Headers(responseHeaders)\n    });\n    return res;\n}\n\nexport { fetch };\n","import { BookConfig, BookSearchConfig, ViewSettings } from '@/types/book';\n\nexport const serializeConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  config = JSON.parse(JSON.stringify(config));\n  const viewSettings = config.viewSettings as Partial<ViewSettings>;\n  const searchConfig = config.searchConfig as Partial<BookSearchConfig>;\n  config.viewSettings = Object.entries(viewSettings).reduce(\n    (acc: Partial<Record<keyof ViewSettings, unknown>>, [key, value]) => {\n      if (globalViewSettings[key as keyof ViewSettings] !== value) {\n        acc[key as keyof ViewSettings] = value;\n      }\n      return acc;\n    },\n    {} as Partial<Record<keyof ViewSettings, unknown>>,\n  ) as Partial<ViewSettings>;\n  config.searchConfig = Object.entries(searchConfig).reduce(\n    (acc: Partial<Record<keyof BookSearchConfig, unknown>>, [key, value]) => {\n      if (defaultSearchConfig[key as keyof BookSearchConfig] !== value) {\n        acc[key as keyof BookSearchConfig] = value;\n      }\n      return acc;\n    },\n    {} as Partial<BookSearchConfig>,\n  ) as Partial<BookSearchConfig>;\n\n  return JSON.stringify(config);\n};\n\nexport const deserializeConfig = (\n  str: string,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): BookConfig => {\n  const config = JSON.parse(str) as BookConfig;\n  const { viewSettings, searchConfig } = config;\n  config.viewSettings = { ...globalViewSettings, ...viewSettings };\n  config.searchConfig = { ...defaultSearchConfig, ...searchConfig };\n  config.updatedAt ??= Date.now();\n  return config;\n};\n\nexport const compressConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  return JSON.parse(serializeConfig(config, globalViewSettings, defaultSearchConfig));\n};\n","import { partialMD5 } from './md5';\nimport { getBaseFilename } from './path';\nimport { detectLanguage } from './lang';\n\ninterface Metadata {\n  bookTitle: string;\n  author: string;\n  language: string;\n  identifier: string;\n}\n\ninterface Chapter {\n  title: string;\n  content: string;\n  text: string;\n  isVolume: boolean;\n}\n\ninterface Txt2EpubOptions {\n  file: File;\n  author?: string;\n  language?: string;\n}\n\ninterface ExtractChapterOptions {\n  linesBetweenSegments: number;\n  fallbackParagraphsPerChapter: number;\n}\n\ninterface ConversionResult {\n  file: File;\n  bookTitle: string;\n  chapterCount: number;\n  language: string;\n}\n\nconst zipWriteOptions = {\n  lastAccessDate: new Date(0),\n  lastModDate: new Date(0),\n};\n\nconst escapeXml = (str: string) => {\n  if (!str) return '';\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n};\n\nexport class TxtToEpubConverter {\n  public async convert(options: Txt2EpubOptions): Promise<ConversionResult> {\n    const { file: txtFile, author: providedAuthor, language: providedLanguage } = options;\n\n    const fileContent = await txtFile.arrayBuffer();\n    const detectedEncoding = this.detectEncoding(fileContent) || 'utf-8';\n    console.log(`Detected encoding: ${detectedEncoding}`);\n    const decoder = new TextDecoder(detectedEncoding);\n    const txtContent = decoder.decode(fileContent).trim();\n\n    const bookTitle = this.extractBookTitle(getBaseFilename(txtFile.name));\n    const fileName = `${bookTitle}.epub`;\n\n    const fileHeader = txtContent.slice(0, 1024);\n    const authorMatch =\n      fileHeader.match(/[\\[]?[\\]]?[:\\s]\\s*(.+)\\r?\\n/) ||\n      fileHeader.match(/[\\[]?\\s*(.+)\\s+\\s*[\\]]?\\r?\\n/);\n    let matchedAuthor = authorMatch ? authorMatch[1]!.trim() : providedAuthor || '';\n    try {\n      matchedAuthor = matchedAuthor.replace(/^[\\p{P}\\p{S}]+|[\\p{P}\\p{S}]+$/gu, '');\n    } catch {}\n    const author = matchedAuthor || providedAuthor || '';\n    const language = providedLanguage || detectLanguage(fileHeader);\n    console.log(`Detected language: ${language}`);\n    const identifier = await partialMD5(txtFile);\n    const metadata = { bookTitle, author, language, identifier };\n\n    let chapters: Chapter[] = [];\n    for (let i = 8; i >= 6; i--) {\n      chapters = this.extractChapters(txtContent, metadata, {\n        linesBetweenSegments: i,\n        fallbackParagraphsPerChapter: 100,\n      });\n\n      if (chapters.length === 0) {\n        throw new Error('No chapters detected.');\n      } else if (chapters.length > 1) {\n        break;\n      }\n    }\n\n    const blob = await this.createEpub(chapters, metadata);\n    return {\n      file: new File([blob], fileName),\n      bookTitle,\n      chapterCount: chapters.length,\n      language,\n    };\n  }\n\n  private extractChapters(\n    txtContent: string,\n    metadata: Metadata,\n    option: ExtractChapterOptions,\n  ): Chapter[] {\n    const { language } = metadata;\n    const { linesBetweenSegments, fallbackParagraphsPerChapter } = option;\n    const segmentRegex = new RegExp(`(?:\\\\r?\\\\n){${linesBetweenSegments},}|-{8,}\\r?\\n`);\n    const chapterRegexps: RegExp[] = [];\n    if (language === 'zh') {\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[0-9][0-9]*(?:[])(?:[: \\(\\)0-9]*[^\\n-]{0,24})(?!\\S)`,\n              String.raw`(?:||||||||)(?:[: ][^\\n-]{0,24})?(?!\\S)`,\n              String.raw`chapter[\\s.]*[0-9]+(?:[:. ]+[^\\n-]{0,50})?(?!\\S)`,\n            ].join('|') +\n            ')',\n          'gui',\n        ),\n      );\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[][]?[: ][^\\n-]{0,24}(?=\\n|$)`,\n              String.raw`[0-9]+[^\\n]{0,16}(?=\\n|$)`,\n            ].join('|') +\n            ')',\n          'gu',\n        ),\n      );\n    } else {\n      const chapterKeywords = ['Chapter', 'Part', 'Section', 'Book', 'Volume', 'Act'];\n\n      const prefaceKeywords = [\n        'Prologue',\n        'Epilogue',\n        'Introduction',\n        'Foreword',\n        'Preface',\n        'Afterword',\n      ];\n\n      const numberPattern = String.raw`(\\d+|(?:[IVXLCDM]{2,}|V|X|L|C|D|M)\\b)`;\n      const dotNumberPattern = String.raw`\\.\\d{1,4}`;\n      const titlePattern = String.raw`[^\\n]{0,50}`;\n\n      const normalChapterPattern = chapterKeywords\n        .map(\n          (k) =>\n            String.raw`${k}\\s*(?:${numberPattern}|${dotNumberPattern})(?:[:.\\-]?\\s*${titlePattern})?`,\n        )\n        .join('|');\n\n      const prefacePattern = prefaceKeywords\n        .map((k) => String.raw`${k}(?:[:.\\-]?\\s*${titlePattern})?`)\n        .join('|');\n\n      const combinedPattern = String.raw`(?:^|\\n|\\s)(?:${normalChapterPattern}|${prefacePattern})(?=\\s|$)`;\n\n      chapterRegexps.push(new RegExp(combinedPattern, 'gi'));\n    }\n\n    const formatSegment = (segment: string): string => {\n      segment = escapeXml(segment);\n      return segment\n        .replace(/-{8,}|_{8,}/g, '\\n')\n        .split(/\\n+/)\n        .map((line) => line.trim())\n        .filter((line) => line)\n        .join('</p><p>');\n    };\n\n    const joinAroundUndefined = (arr: (string | undefined)[]) =>\n      arr.reduce<string[]>((acc, curr, i, src) => {\n        if (\n          curr === undefined &&\n          i > 0 &&\n          i < src.length - 1 &&\n          src[i - 1] !== undefined &&\n          src[i + 1] !== undefined\n        ) {\n          acc[acc.length - 1] += src[i + 1]!;\n          return acc;\n        }\n        if (curr !== undefined && (i === 0 || src[i - 1] !== undefined)) {\n          acc.push(curr);\n        }\n        return acc;\n      }, []);\n\n    const isGoodMatches = (matches: string[], maxLength: number = 100000): boolean => {\n      const meaningfulParts = matches.filter((part) => part && part.trim().length > 0);\n      if (meaningfulParts.length <= 1) return false;\n\n      const hasLongParts = meaningfulParts.some((part) => part.length > maxLength);\n      return !hasLongParts;\n    };\n\n    const chapters: Chapter[] = [];\n    const segments = txtContent.split(segmentRegex);\n    for (const segment of segments) {\n      const trimmedSegment = segment.replace(/<!--.*?-->/g, '').trim();\n      if (!trimmedSegment) continue;\n\n      const segmentChapters: Chapter[] = [];\n      let matches: string[] = [];\n      for (const chapterRegex of chapterRegexps) {\n        const tryMatches = trimmedSegment.split(chapterRegex);\n        if (isGoodMatches(tryMatches)) {\n          matches = joinAroundUndefined(tryMatches);\n          break;\n        }\n      }\n\n      if (matches.length === 0 && fallbackParagraphsPerChapter > 0) {\n        const paragraphs = trimmedSegment.split(/\\n+/);\n        const totalParagraphs = paragraphs.length;\n        for (let i = 0; i < totalParagraphs; i += fallbackParagraphsPerChapter) {\n          const chunks = paragraphs.slice(i, i + fallbackParagraphsPerChapter);\n          const formattedSegment = formatSegment(chunks.join('\\n'));\n          const title = `${chapters.length + 1}`;\n          const content = `<h2>${title}</h2><p>${formattedSegment}</p>`;\n          chapters.push({ title, content, text: chunks.join('\\n'), isVolume: false });\n        }\n        continue;\n      }\n\n      for (let j = 1; j < matches.length; j += 2) {\n        const title = matches[j]?.trim() || '';\n        const content = matches[j + 1]?.trim() || '';\n\n        let isVolume = false;\n        if (language === 'zh') {\n          isVolume = /[0-9]+(|||)/.test(title);\n        } else {\n          isVolume = /\\b(Part|Volume|Book)\\b/i.test(title);\n        }\n\n        const headTitle = isVolume ? `<h1>${title}</h1>` : `<h2>${title}</h2>`;\n        const formattedSegment = formatSegment(content);\n        segmentChapters.push({\n          title: escapeXml(title),\n          content: `${headTitle}<p>${formattedSegment}</p>`,\n          text: content,\n          isVolume: isVolume,\n        });\n      }\n\n      if (matches[0] && matches[0].trim()) {\n        const initialContent = matches[0].trim();\n        const firstLine = initialContent.split('\\n')[0]!.trim();\n        const segmentTitle =\n          (firstLine.length > 16 ? initialContent.split(/[\\n\\s\\p{P}]/u)[0]!.trim() : firstLine) ||\n          initialContent.slice(0, 16);\n        const formattedSegment = formatSegment(initialContent);\n        segmentChapters.unshift({\n          title: escapeXml(segmentTitle),\n          content: `<h3></h3><p>${formattedSegment}</p>`,\n          text: initialContent,\n          isVolume: false,\n        });\n      }\n      chapters.push(...segmentChapters);\n    }\n\n    return chapters;\n  }\n\n  private async createEpub(chapters: Chapter[], metadata: Metadata): Promise<Blob> {\n    const { BlobWriter, TextReader, ZipWriter } = await import('@zip.js/zip.js');\n    const { bookTitle, author, language, identifier } = metadata;\n\n    const zipWriter = new ZipWriter(new BlobWriter('application/epub+zip'), {\n      extendedTimestamp: false,\n    });\n    await zipWriter.add('mimetype', new TextReader('application/epub+zip'), zipWriteOptions);\n\n    // Add META-INF/container.xml\n    const containerXml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <container xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\" version=\"1.0\">\n      <rootfiles>\n        <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n      </rootfiles>\n    </container>`.trim();\n\n    await zipWriter.add('META-INF/container.xml', new TextReader(containerXml), zipWriteOptions);\n\n    // Create navigation points for TOC\n    let isNested = false;\n    let navPoints = ``;\n    for (let i = 0; i < chapters.length; i++) {\n      const id = `chapter${i + 1}`;\n      const playOrder = i + 1;\n      if (chapters[i]!.isVolume && isNested) {\n        navPoints += `</navPoint>\\n`;\n        isNested = !isNested;\n      }\n      navPoints +=\n        `<navPoint id=\"navPoint-${id}\" playOrder=\"${playOrder}\">\\n` +\n        `<navLabel><text>${chapters[i]!.title}</text></navLabel>\\n` +\n        `<content src=\"./OEBPS/${id}.xhtml\" />\\n`;\n      if (chapters[i]!.isVolume && !isNested) {\n        isNested = !isNested;\n      } else {\n        navPoints += `</navPoint>\\n`;\n      }\n    }\n    if (isNested) {\n      navPoints += `</navPoint>`;\n    }\n\n    // Add NCX file (table of contents)\n    const tocNcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n      <head>\n        <meta name=\"dtb:uid\" content=\"book-id\" />\n        <meta name=\"dtb:depth\" content=\"1\" />\n        <meta name=\"dtb:totalPageCount\" content=\"0\" />\n        <meta name=\"dtb:maxPageNumber\" content=\"0\" />\n      </head>\n      <docTitle>\n        <text>${escapeXml(bookTitle)}</text>\n      </docTitle>\n      <docAuthor>\n        <text>${escapeXml(author)}</text>\n      </docAuthor>\n      <navMap>\n        ${navPoints}\n      </navMap>\n    </ncx>`.trim();\n\n    await zipWriter.add('toc.ncx', new TextReader(tocNcx), zipWriteOptions);\n\n    // Create manifest and spine items\n    const manifest = chapters\n      .map(\n        (_, index) => `\n      <item id=\"chap${index + 1}\" href=\"OEBPS/chapter${index + 1}.xhtml\" media-type=\"application/xhtml+xml\"/>\n    `,\n      )\n      .join('\\n')\n      .trim();\n\n    const spine = chapters\n      .map(\n        (_, index) => `\n      <itemref idref=\"chap${index + 1}\"/>`,\n      )\n      .join('\\n')\n      .trim();\n\n    // Add CSS stylesheet\n    const css = `\n      body { line-height: 1.6; font-size: 1em; font-family: 'Arial', sans-serif; text-align: justify; }\n      p { text-indent: 2em; margin: 0; }\n    `;\n\n    await zipWriter.add('style.css', new TextReader(css), zipWriteOptions);\n\n    // Add chapter files\n    for (let i = 0; i < chapters.length; i++) {\n      const chapter = chapters[i]!;\n      const lang = detectLanguage(chapter.text);\n      const chapterContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"${lang}\" xml:lang=\"${lang}\">\n          <head>\n            <title>${chapter.title}</title>\n            <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\"/>\n          </head>\n          <body>${chapter.content}</body>\n        </html>`.trim();\n\n      await zipWriter.add(\n        `OEBPS/chapter${i + 1}.xhtml`,\n        new TextReader(chapterContent),\n        zipWriteOptions,\n      );\n    }\n\n    const tocManifest = `<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>`;\n    const styleManifest = `<item id=\"css\" href=\"style.css\" media-type=\"text/css\"/>`;\n\n    // Add content.opf file\n    const contentOpf = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"book-id\" version=\"2.0\">\n        <metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n          <dc:title>${escapeXml(bookTitle)}</dc:title>\n          <dc:language>${language}</dc:language>\n          <dc:creator>${escapeXml(author)}</dc:creator>\n          <dc:identifier id=\"book-id\">${identifier}</dc:identifier>\n        </metadata>\n        <manifest>\n          ${manifest}\n          ${tocManifest}\n          ${styleManifest}\n        </manifest>\n        <spine toc=\"ncx\">\n          ${spine}\n        </spine>\n      </package>`.trim();\n\n    await zipWriter.add('content.opf', new TextReader(contentOpf), zipWriteOptions);\n\n    return await zipWriter.close();\n  }\n\n  private detectEncoding(buffer: ArrayBuffer): string | undefined {\n    try {\n      new TextDecoder('utf-8', { fatal: true }).decode(buffer);\n      return 'utf-8';\n    } catch {\n      const uint8Array = new Uint8Array(buffer);\n      // Try tolerant UTF-8 detection - check if most of it is valid UTF-8\n      let validBytes = 0;\n      let checkedBytes = 0;\n      const sampleSize = Math.min(uint8Array.length, 10000);\n\n      for (let i = 0; i < sampleSize; i++) {\n        try {\n          new TextDecoder('utf-8', { fatal: true }).decode(uint8Array.slice(i, i + 100));\n          validBytes += 100;\n          checkedBytes += 100;\n          i += 99;\n        } catch {\n          checkedBytes++;\n        }\n      }\n\n      const validPercentage = (validBytes / checkedBytes) * 100;\n      console.log(`UTF-8 validity: ${validPercentage.toFixed(2)}%`);\n\n      // If more than 80% is valid UTF-8, consider it UTF-8 with some corruption\n      if (validPercentage > 80) {\n        console.log('Treating as UTF-8 despite some invalid sequences');\n        return 'utf-8';\n      }\n      // If UTF-8 decoding fails, try to detect other encodings\n    }\n\n    const headerBytes = new Uint8Array(buffer.slice(0, 4));\n\n    if (headerBytes[0] === 0xff && headerBytes[1] === 0xfe) {\n      return 'utf-16le';\n    }\n\n    if (headerBytes[0] === 0xfe && headerBytes[1] === 0xff) {\n      return 'utf-16be';\n    }\n\n    if (headerBytes[0] === 0xef && headerBytes[1] === 0xbb && headerBytes[2] === 0xbf) {\n      return 'utf-8';\n    }\n\n    // Analyze a sample of the content to guess between common East Asian encodings\n    // If the content has a high ratio of bytes in the 0x80-0xFF range, it's likely GBK/GB18030\n    const sample = new Uint8Array(buffer.slice(0, Math.min(1024, buffer.byteLength)));\n    let highByteCount = 0;\n\n    for (let i = 0; i < sample.length; i++) {\n      if (sample[i]! >= 0x80) {\n        highByteCount++;\n      }\n    }\n\n    const highByteRatio = highByteCount / sample.length;\n    if (highByteRatio > 0.3) {\n      return 'gbk';\n    }\n\n    if (highByteRatio > 0.1) {\n      let sjisPattern = false;\n      for (let i = 0; i < sample.length - 1; i++) {\n        const b1 = sample[i]!;\n        const b2 = sample[i + 1]!;\n        if (\n          ((b1 >= 0x81 && b1 <= 0x9f) || (b1 >= 0xe0 && b1 <= 0xfc)) &&\n          ((b2 >= 0x40 && b2 <= 0x7e) || (b2 >= 0x80 && b2 <= 0xfc))\n        ) {\n          sjisPattern = true;\n          break;\n        }\n      }\n\n      if (sjisPattern) {\n        return 'shift-jis';\n      }\n\n      return 'gb18030';\n    }\n\n    return 'utf-8';\n  }\n\n  private extractBookTitle(filename: string): string {\n    const match = filename.match(/([^]+)/);\n    return match ? match[1]! : filename.split('.')[0]!;\n  }\n}\n","export const BOOK_FILE_NOT_FOUND_ERROR = 'Book file not found';\n","import { FontStyle } from '@/styles/fonts';\nimport { getUserLang } from './misc';\n\nfunction parseUnicodeString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i += 2) {\n    const charCode = dataView.getUint16(offset + i, false);\n    if (charCode !== 0) {\n      chars.push(String.fromCharCode(charCode));\n    }\n  }\n  return chars.join('');\n}\n\nfunction parseMacintoshString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i++) {\n    const charCode = dataView.getUint8(offset + i);\n    chars.push(String.fromCharCode(charCode));\n  }\n  return chars.join('');\n}\n\nconst NO_STYLE_LANGUAGE_IDS = new Set([0x0404, 0x0804, 0x0c04, 0x1004, 19, 33]);\n\nfunction getLanguagePriority(platformID: number, languageID: number, userLanguage: string): number {\n  let priority = 0;\n\n  // Base priority by platform (Unicode/Microsoft preferred)\n  if (platformID === 0)\n    priority += 100; // Unicode\n  else if (platformID === 3)\n    priority += 90; // Microsoft\n  else if (platformID === 1) priority += 50; // Macintosh\n\n  // Language-specific priorities\n  const userLang = userLanguage.toLowerCase();\n\n  if (platformID === 0 || platformID === 3) {\n    if (userLang.startsWith('zh')) {\n      if (languageID === 0x0804)\n        priority += 50; // Simplified Chinese\n      else if (languageID === 0x0404)\n        priority += 45; // Traditional Chinese\n      else if (languageID === 0x0c04)\n        priority += 40; // Traditional Chinese\n      else if (languageID === 0x1004) priority += 35; // Simplified Chinese\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 0x0411) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 0x0412) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0x0409)\n        priority += 50; // English (US)\n      else if (languageID === 0x0809) priority += 45; // English (UK)\n    }\n\n    // Fallback: English\n    if (languageID === 0x0409) priority += 10; // English fallback\n  } else if (platformID === 1) {\n    // Macintosh platform language codes\n    if (userLang.startsWith('zh')) {\n      if (languageID === 33)\n        priority += 50; // Chinese (Simplified)\n      else if (languageID === 19) priority += 45; // Chinese (Traditional)\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 11) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 23) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0) priority += 50; // English\n    }\n\n    // Fallback: English\n    if (languageID === 0) priority += 10; // English fallback\n  }\n\n  return priority;\n}\n\nfunction parseOS2Weight(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table usWeightClass is at offset 4\n  return dataView.getUint16(os2TableOffset + 4, false);\n}\n\nfunction parseOS2Selection(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table fsSelection is at offset 62\n  return dataView.getUint16(os2TableOffset + 62, false);\n}\n\ninterface VariableFontAxis {\n  tag: string;\n  minValue: number;\n  defaultValue: number;\n  maxValue: number;\n  name?: string;\n}\n\nfunction parseVariableFontAxes(dataView: DataView, fvarTableOffset: number): VariableFontAxis[] {\n  try {\n    // fvar table structure:\n    // version (4 bytes) + axisCount (2 bytes) + axisSize (2 bytes) + instanceCount (2 bytes) + instanceSize (2 bytes)\n    const axisCount = dataView.getUint16(fvarTableOffset + 4, false);\n    const axisSize = dataView.getUint16(fvarTableOffset + 6, false);\n\n    const axes: VariableFontAxis[] = [];\n\n    // Each axis record starts at offset 16 from table start\n    let axisOffset = fvarTableOffset + 16;\n\n    for (let i = 0; i < axisCount; i++) {\n      // Axis record structure:\n      // axisTag (4 bytes) + minValue (4 bytes) + defaultValue (4 bytes) + maxValue (4 bytes) + flags (2 bytes) + axisNameID (2 bytes)\n\n      const tag = String.fromCharCode(\n        dataView.getUint8(axisOffset),\n        dataView.getUint8(axisOffset + 1),\n        dataView.getUint8(axisOffset + 2),\n        dataView.getUint8(axisOffset + 3),\n      );\n\n      // Fixed-point values (16.16 format)\n      const minValue = dataView.getInt32(axisOffset + 4, false) / 65536;\n      const defaultValue = dataView.getInt32(axisOffset + 8, false) / 65536;\n      const maxValue = dataView.getInt32(axisOffset + 12, false) / 65536;\n\n      axes.push({\n        tag,\n        minValue,\n        defaultValue,\n        maxValue,\n      });\n\n      axisOffset += axisSize;\n    }\n\n    return axes;\n  } catch (error) {\n    console.warn('Failed to parse fvar table:', error);\n    return [];\n  }\n}\n\nfunction weightClassToCSSWeight(weightClass: number): number {\n  // Map OpenType weight class to CSS weight\n  if (weightClass >= 1 && weightClass <= 100) return 100;\n  if (weightClass >= 101 && weightClass <= 200) return 200;\n  if (weightClass >= 201 && weightClass <= 300) return 300;\n  if (weightClass >= 301 && weightClass <= 400) return 400;\n  if (weightClass >= 401 && weightClass <= 500) return 500;\n  if (weightClass >= 501 && weightClass <= 600) return 600;\n  if (weightClass >= 601 && weightClass <= 700) return 700;\n  if (weightClass >= 701 && weightClass <= 800) return 800;\n  if (weightClass >= 801 && weightClass <= 900) return 900;\n  return 400; // Default to normal weight\n}\n\nfunction inferWeightFromStyleName(styleName: string): number {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check for specific weight keywords\n  if (lowerStyle.includes('thin') || lowerStyle.includes('hairline')) return 100;\n  if (lowerStyle.includes('extralight') || lowerStyle.includes('ultralight')) return 200;\n  if (\n    lowerStyle.includes('light') &&\n    !lowerStyle.includes('extralight') &&\n    !lowerStyle.includes('ultralight')\n  )\n    return 300;\n  if (lowerStyle.includes('medium')) return 500;\n  if (lowerStyle.includes('semibold') || lowerStyle.includes('demibold')) return 600;\n  if (lowerStyle.includes('extrabold') || lowerStyle.includes('ultrabold')) return 800;\n  if (lowerStyle.includes('black') || lowerStyle.includes('heavy')) return 900;\n  if (\n    lowerStyle.includes('bold') &&\n    !lowerStyle.includes('semibold') &&\n    !lowerStyle.includes('extrabold') &&\n    !lowerStyle.includes('ultrabold')\n  )\n    return 700;\n\n  return 400; // Default to normal weight\n}\n\nfunction inferStyleFromName(\n  styleName: string,\n  fsSelection: number,\n): 'normal' | 'italic' | 'oblique' {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check fsSelection flags first (bit 0 = italic, bit 9 = oblique)\n  if (fsSelection & 0x200) return 'oblique'; // Bit 9\n  if (fsSelection & 0x1) return 'italic'; // Bit 0\n\n  // Fallback to style name analysis\n  if (lowerStyle.includes('oblique')) return 'oblique';\n  if (lowerStyle.includes('italic') || lowerStyle.includes('slant')) return 'italic';\n\n  return 'normal';\n}\n\ntype FontNameType = {\n  name: string;\n  platformID: number;\n  languageID: number;\n  priority: number;\n};\n\nexport const parseFontInfo = (fontData: ArrayBuffer, filename: string) => {\n  const fallbackName = filename.replace(/\\.[^/.]+$/, '');\n  try {\n    const dataView = new DataView(fontData);\n    const signature = dataView.getUint32(0, false);\n    if (signature !== 0x00010000 && signature !== 0x74727565 && signature !== 0x4f54544f) {\n      throw new Error('Unsupported font format');\n    }\n    const numTables = dataView.getUint16(4, false);\n    let nameTableOffset = 0;\n    let os2TableOffset = 0;\n    let fvarTableOffset = 0;\n    for (let i = 0; i < numTables; i++) {\n      const tableOffset = 12 + i * 16;\n      const tag = String.fromCharCode(\n        dataView.getUint8(tableOffset),\n        dataView.getUint8(tableOffset + 1),\n        dataView.getUint8(tableOffset + 2),\n        dataView.getUint8(tableOffset + 3),\n      );\n\n      if (tag === 'name') {\n        nameTableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'OS/2') {\n        os2TableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'fvar') {\n        fvarTableOffset = dataView.getUint32(tableOffset + 8, false);\n      }\n    }\n\n    if (nameTableOffset === 0) {\n      throw new Error('Name table not found');\n    }\n\n    const count = dataView.getUint16(nameTableOffset + 2, false);\n    const stringOffset = dataView.getUint16(nameTableOffset + 4, false);\n\n    const userLanguage = getUserLang();\n    const fontFamilyNames: Array<FontNameType> = [];\n    const fontStyleNames: Array<FontNameType> = [];\n    const preferredFamilyNames: Array<FontNameType> = [];\n    const preferredStyleNames: Array<FontNameType> = [];\n    for (let i = 0; i < count; i++) {\n      const recordOffset = nameTableOffset + 6 + i * 12;\n      const platformID = dataView.getUint16(recordOffset, false);\n      const languageID = dataView.getUint16(recordOffset + 4, false);\n      const nameID = dataView.getUint16(recordOffset + 6, false);\n      const nameLength = dataView.getUint16(recordOffset + 8, false);\n      const nameOffsetInTable = dataView.getUint16(recordOffset + 10, false);\n\n      // nameID 1 = Font Family name, nameID 2 = Font Subfamily name (style)\n      // nameID 16 = Typographic Family name, nameID 17 = Typographic Subfamily name\n      if (nameID === 1 || nameID === 2 || nameID === 16 || nameID === 17) {\n        const stringStart = nameTableOffset + stringOffset + nameOffsetInTable;\n        let fontName = '';\n\n        if (platformID === 0 || platformID === 3) {\n          // Unicode/Microsoft platform\n          fontName = parseUnicodeString(dataView, stringStart, nameLength);\n        } else if (platformID === 1) {\n          // Macintosh platform\n          fontName = parseMacintoshString(dataView, stringStart, nameLength);\n        }\n\n        if (fontName && fontName.trim()) {\n          const priority = getLanguagePriority(platformID, languageID, userLanguage);\n          const nameEntry = {\n            name: fontName.trim(),\n            platformID,\n            languageID,\n            priority,\n          };\n\n          if (nameID === 1) {\n            fontFamilyNames.push(nameEntry);\n          } else if (nameID === 2) {\n            fontStyleNames.push(nameEntry);\n          } else if (nameID === 16) {\n            preferredFamilyNames.push(nameEntry);\n          } else if (nameID === 17) {\n            preferredStyleNames.push(nameEntry);\n          }\n        }\n      }\n    }\n    if (fontFamilyNames.length === 0) {\n      throw new Error('Font family name not found');\n    }\n    fontFamilyNames.sort((a, b) => b.priority - a.priority);\n    fontStyleNames.sort((a, b) => b.priority - a.priority);\n    preferredFamilyNames.sort((a, b) => b.priority - a.priority);\n    preferredStyleNames.sort((a, b) => b.priority - a.priority);\n\n    // Prefer typographic names if available\n    const familyName = (preferredFamilyNames[0] || fontFamilyNames[0])!.name;\n    const fontStyleName = preferredStyleNames[0] || fontStyleNames[0];\n    const styleName = fontStyleName?.name || '';\n\n    // Parse weight and style information\n    let fontWeight = 400;\n    let fontStyle: FontStyle = 'normal';\n    let fsSelection = 0;\n\n    if (os2TableOffset > 0) {\n      try {\n        const weightClass = parseOS2Weight(dataView, os2TableOffset);\n        fontWeight = weightClassToCSSWeight(weightClass);\n        fsSelection = parseOS2Selection(dataView, os2TableOffset);\n      } catch {\n        console.warn('Failed to parse OS/2 table, falling back to style name analysis');\n      }\n    }\n\n    let isVariable = false;\n    if (fvarTableOffset > 0) {\n      const axes = parseVariableFontAxes(dataView, fvarTableOffset);\n      if (axes && axes.length > 0) {\n        isVariable = true;\n      }\n    }\n\n    // If OS/2 table weight is default (400) or unavailable, try to infer from style name\n    if (fontWeight === 400 && styleName) {\n      const inferredWeight = inferWeightFromStyleName(styleName);\n      if (inferredWeight !== 400) {\n        fontWeight = inferredWeight;\n      }\n    }\n\n    fontStyle = inferStyleFromName(styleName, fsSelection);\n\n    return {\n      name:\n        fontStyleName && !NO_STYLE_LANGUAGE_IDS.has(fontStyleName.languageID)\n          ? `${familyName} ${styleName}`\n          : familyName,\n      family: familyName,\n      weight: fontWeight,\n      style: fontStyle,\n      variable: isVariable,\n    };\n  } catch (error) {\n    console.warn(`Failed to parse font: ${error}`);\n    return {\n      name: fallbackName,\n      family: fallbackName,\n      weight: 400,\n      style: 'normal' as FontStyle,\n      variable: false,\n    };\n  }\n};\n","function parseSvgLength(value: string) {\n  const n = parseFloat(value);\n  if (!isNaN(n)) return n;\n\n  return undefined;\n}\n\nasync function getSvgSize(\n  svgBlob: Blob,\n  defaultWidth: number = 700,\n  defaultHeight: number = 1050,\n): Promise<{ width: number; height: number }> {\n  const text = await svgBlob.text();\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(text, 'image/svg+xml');\n  const svg = doc.documentElement;\n\n  const widthAttr = svg.getAttribute('width');\n  const heightAttr = svg.getAttribute('height');\n\n  if (widthAttr && heightAttr) {\n    return {\n      width: parseSvgLength(widthAttr) || defaultWidth,\n      height: parseSvgLength(heightAttr) || defaultHeight,\n    };\n  }\n\n  const viewBox = svg.getAttribute('viewBox');\n  if (viewBox) {\n    const parts = viewBox.split(/\\s+/).map(Number);\n    if (parts.length === 4 && !parts.some(isNaN)) {\n      const [, , vbWidth, vbHeight] = parts;\n      return { width: vbWidth || defaultWidth, height: vbHeight || defaultHeight };\n    }\n  }\n\n  return { width: defaultWidth, height: defaultHeight };\n}\n\nexport async function svg2png(svgBlob: Blob, quality: number = 0.9): Promise<Blob> {\n  const svgText = await svgBlob.text();\n\n  const svgUrl = URL.createObjectURL(new Blob([svgText], { type: 'image/svg+xml' }));\n\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n\n  await new Promise<void>((resolve, reject) => {\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error('Failed to load SVG'));\n    img.src = svgUrl;\n  });\n\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n\n  const canvas = document.createElement('canvas');\n  const { width, height } = await getSvgSize(svgBlob);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0);\n\n  URL.revokeObjectURL(svgUrl);\n\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => resolve(blob!), 'image/png', quality);\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,4,5,6,7,8,9,18]}
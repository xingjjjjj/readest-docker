{"version":3,"sources":["../../../../../apps/readest-app/src/services/environment.ts","../../../../../node_modules/.pnpm/jwt-decode%404.0.0/node_modules/jwt-decode/build/esm/index.js","../../../../../apps/readest-app/src/utils/access.ts","../../../../../apps/readest-app/src/services/translators/utils.ts","../../../../../apps/readest-app/src/utils/fetch.ts"],"sourcesContent":["import { AppService } from '@/types/system';\nimport { READEST_NODE_BASE_URL, READEST_WEB_BASE_URL } from './constants';\n\ndeclare global {\n  interface Window {\n    __READEST_CLI_ACCESS?: boolean;\n  }\n}\n\nconst appPlatform = process.env['NEXT_PUBLIC_APP_PLATFORM'] || 'web';\nexport const isTauriAppPlatform = () => appPlatform === 'tauri';\nexport const isWebAppPlatform = () => appPlatform === 'web';\nexport const hasCli = () => window.__READEST_CLI_ACCESS === true;\nexport const isPWA = () => window.matchMedia('(display-mode: standalone)').matches;\nexport const getBaseUrl = () => process.env['NEXT_PUBLIC_API_BASE_URL'] ?? READEST_WEB_BASE_URL;\nexport const getNodeBaseUrl = () =>\n  process.env['NEXT_PUBLIC_NODE_BASE_URL'] ?? READEST_NODE_BASE_URL;\n\nconst isWebDevMode = () => process.env['NODE_ENV'] === 'development' && isWebAppPlatform();\n\n// Dev API only in development mode and web platform\n// with command `pnpm dev-web`\n// for production build or tauri app use the production Web API\nexport const getAPIBaseUrl = () => (isWebDevMode() ? '/api' : `${getBaseUrl()}/api`);\n\n// For Node.js API that currently not supported in some edge runtimes\nexport const getNodeAPIBaseUrl = () => (isWebDevMode() ? '/api' : `${getNodeBaseUrl()}/api`);\n\nexport interface EnvConfigType {\n  getAppService: () => Promise<AppService>;\n}\n\nlet nativeAppService: AppService | null = null;\nconst getNativeAppService = async () => {\n  if (!nativeAppService) {\n    const { NativeAppService } = await import('@/services/nativeAppService');\n    nativeAppService = new NativeAppService();\n    await nativeAppService.init();\n  }\n  return nativeAppService;\n};\n\nlet webAppService: AppService | null = null;\nconst getWebAppService = async () => {\n  if (!webAppService) {\n    const { WebAppService } = await import('@/services/webAppService');\n    webAppService = new WebAppService();\n    await webAppService.init();\n  }\n  return webAppService;\n};\n\nconst environmentConfig: EnvConfigType = {\n  getAppService: async () => {\n    // Check if actually running in Tauri environment (runtime check)\n    const isTauriRuntime = typeof window !== 'undefined' && (window as any).__TAURI__;\n\n    if (isTauriAppPlatform() && isTauriRuntime) {\n      return getNativeAppService();\n    } else {\n      return getWebAppService();\n    }\n  },\n};\n\nexport default environmentConfig;\n","export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n","import { jwtDecode } from 'jwt-decode';\nimport { verifyJWT } from '@/utils/jwt';\nimport { UserPlan } from '@/types/quota';\nimport { DEFAULT_DAILY_TRANSLATION_QUOTA, DEFAULT_STORAGE_QUOTA } from '@/services/constants';\nimport { isWebAppPlatform } from '@/services/environment';\nimport { getDailyUsage } from '@/services/translators/utils';\n\ninterface Token {\n  plan: UserPlan;\n  storage_usage_bytes: number;\n  storage_purchased_bytes: number;\n  [key: string]: string | number;\n}\n\nexport const getSubscriptionPlan = (token: string): UserPlan => {\n  const data = jwtDecode<Token>(token) || {};\n  return data['plan'] || 'free';\n};\n\nexport const getUserProfilePlan = (token: string): UserPlan => {\n  const data = jwtDecode<Token>(token) || {};\n  let plan = data['plan'] || 'free';\n  if (plan === 'free') {\n    const purchasedQuota = data['storage_purchased_bytes'] || 0;\n    if (purchasedQuota > 0) {\n      plan = 'purchase';\n    }\n  }\n  return plan;\n};\n\nexport const STORAGE_QUOTA_GRACE_BYTES = 10 * 1024 * 1024; // 10 MB grace\n\nexport const getStoragePlanData = (token: string) => {\n  const data = jwtDecode<Token>(token) || {};\n  const plan = data['plan'] || 'free';\n  const usage = data['storage_usage_bytes'] || 0;\n  const purchasedQuota = data['storage_purchased_bytes'] || 0;\n  const fixedQuota = parseInt(process.env['NEXT_PUBLIC_STORAGE_FIXED_QUOTA'] || '0');\n  const planQuota = fixedQuota || DEFAULT_STORAGE_QUOTA[plan] || DEFAULT_STORAGE_QUOTA['free'];\n  const quota = planQuota + purchasedQuota;\n\n  return {\n    plan,\n    usage,\n    quota,\n  };\n};\n\nexport const getTranslationPlanData = (token: string) => {\n  const data = jwtDecode<Token>(token) || {};\n  const plan: UserPlan = data['plan'] || 'free';\n  const usage = getDailyUsage() || 0;\n  const quota = DEFAULT_DAILY_TRANSLATION_QUOTA[plan];\n\n  return {\n    plan,\n    usage,\n    quota,\n  };\n};\n\nexport const getDailyTranslationPlanData = (token: string) => {\n  const data = jwtDecode<Token>(token) || {};\n  const plan = data['plan'] || 'free';\n  const fixedQuota = parseInt(process.env['NEXT_PUBLIC_TRANSLATION_FIXED_QUOTA'] || '0');\n  const quota =\n    fixedQuota || DEFAULT_DAILY_TRANSLATION_QUOTA[plan] || DEFAULT_DAILY_TRANSLATION_QUOTA['free'];\n\n  return {\n    plan,\n    quota,\n  };\n};\n\nexport const getAccessToken = async (): Promise<string | null> => {\n  // Get token from localStorage (client-side) or from request (server-side)\n  if (isWebAppPlatform()) {\n    return localStorage.getItem('token') ?? null;\n  }\n  return null;\n};\n\nexport const getUserID = async (): Promise<string | null> => {\n  if (isWebAppPlatform()) {\n    const user = localStorage.getItem('user') ?? '{}';\n    return JSON.parse(user).id ?? null;\n  }\n  return null;\n};\n\nexport const validateUserAndToken = async (authHeader: string | null | undefined) => {\n  if (!authHeader) return {};\n\n  const token = authHeader.replace('Bearer ', '');\n  try {\n    const payload = await verifyJWT(token);\n    if (!payload) return {};\n    return { user: { id: 'xingjjjjj', email: 'admin@local' }, token };\n  } catch (error) {\n    return {};\n  }\n};\n","import { Book } from '@/types/book';\nimport { isSameLang } from '@/utils/lang';\nimport { getLocale } from '@/utils/misc';\n\nconst DAILY_USAGE_KEY = 'translationDailyUsage';\n\nexport const saveDailyUsage = (usage: number, date?: string) => {\n  if (typeof window !== 'undefined') {\n    const isoDate = date || new Date().toISOString().split('T')[0]!;\n    const dailyUsage = { [isoDate]: usage };\n    localStorage.setItem(DAILY_USAGE_KEY, JSON.stringify(dailyUsage));\n  }\n};\n\nexport const getDailyUsage = (date?: string): number | null => {\n  if (typeof window !== 'undefined') {\n    const isoDate = date || new Date().toISOString().split('T')[0]!;\n    const usage = localStorage.getItem(DAILY_USAGE_KEY);\n    if (usage) {\n      const dailyUsage = JSON.parse(usage);\n      if (dailyUsage[isoDate]) {\n        return dailyUsage[isoDate];\n      }\n    }\n  }\n  return null;\n};\n\nexport const isTranslationAvailable = (book?: Book | null, targetLanguage?: string | null) => {\n  if (!book || book.format === 'PDF') {\n    return false;\n  }\n\n  const primaryLanguage = book.primaryLanguage || '';\n  if (!primaryLanguage || primaryLanguage.toLowerCase() === 'und') {\n    return false;\n  }\n\n  if (targetLanguage && isSameLang(primaryLanguage, targetLanguage)) {\n    return false;\n  }\n\n  if (!targetLanguage && isSameLang(primaryLanguage, getLocale())) {\n    return false;\n  }\n\n  return true;\n};\n","import { getAccessToken } from './access';\n\nexport const fetchWithTimeout = (url: string, options: RequestInit = {}, timeout = 10000) => {\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort('Request timed out'), timeout);\n\n  return fetch(url, {\n    ...options,\n    signal: controller.signal,\n  }).finally(() => clearTimeout(id));\n};\n\nexport const fetchWithAuth = async (url: string, options: RequestInit) => {\n  const token = await getAccessToken();\n  if (!token) {\n    throw new Error('Not authenticated');\n  }\n  const headers = {\n    ...options.headers,\n    Authorization: `Bearer ${token}`,\n  };\n\n  const response = await fetch(url, { ...options, headers });\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    console.error('Error:', errorData.error || response.statusText);\n    throw new Error(errorData.error || 'Request failed');\n  }\n\n  return response;\n};\n"],"names":[],"mappings":"wzDACA,EAAA,CAAA,CAAA,kCAyBiC,IAAO,AAA0B,GAAG,cAAZ,GAA6B,IAAI,CAAC,aAbtE,IAAM,OAAO,UAAU,CAAC,8BAA8B,OAAO,wBAHhD,KAAM,gBAAgB,OACxB,KAAM,gBAAgB,mBCTtD,CAFO,MAAM,SAA0B,OACvC,EACkB,SAAS,CAAC,IAAI,CAAG,oBCDnC,IAAA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,CAAA,CAAA,OACA,IAAA,EAAA,EAAA,CAAA,CAAA,QCHA,EAAA,CAAA,CAAA,QACA,EAAA,CAAA,CAAA,QDyEO,IAAM,EAAiB,SAE5B,AAAI,CAAA,EAAA,EAAA,gBAAA,AAAgB,IACX,CADe,YACF,OAAO,CAAC,UAAY,KAEnC,KAWI,EAAuB,MAAO,IACzC,GAAI,CAAC,EAAY,MAAO,CAAC,EAEzB,IAAM,EAAQ,EAAW,OAAO,CAAC,UAAW,IAC5C,GAAI,CAEF,GAAI,CADY,AACX,MADiB,CAAA,EAAA,EAAA,SAAS,AAAT,EAAU,GAClB,MAAO,CAAC,EACtB,MAAO,CAAE,KAAM,CAAE,GAAI,YAAa,MAAO,aAAc,QAAG,CAAM,CAClE,CAAE,MAAO,EAAO,CACd,MAAO,CAAC,CACV,CACF,gEE1FO,IAAM,EAAgB,MAAO,EAAa,KAC/C,IAAM,EAAQ,MAAM,IACpB,GAAI,CAAC,EACH,KADU,CACA,AAAJ,MAAU,qBAElB,IAAM,EAAU,CACd,GAAG,EAAQ,OAAO,CAClB,cAAe,CAAC,OAAO,EAAE,EAAA,CAAO,AAClC,EAEM,EAAW,MAAM,MAAM,EAAK,CAAE,GAAG,CAAO,SAAE,CAAQ,GAExD,GAAI,CAAC,EAAS,EAAE,CAAE,CAChB,IAAM,EAAY,MAAM,EAAS,IAAI,EAErC,OADA,QAAQ,KAAK,CAAC,SAAU,EAAU,KAAK,EAAI,EAAS,UAAU,EACxD,AAAI,MAAM,EAAU,KAAK,EAAI,iBACrC,CAEA,OAAO,CACT,gDA7BgC,CAAC,EAAa,EAAuB,CAAC,CAAC,CAAE,EAAU,GAAK,IACtF,IAAM,EAAa,IAAI,gBACjB,EAAK,WAAW,IAAM,EAAW,KAAK,CAAC,qBAAsB,GAEnE,OAAO,MAAM,EAAK,CAChB,GAAG,CAAO,CACV,OAAQ,EAAW,MAAM,AAC3B,GAAG,OAAO,CAAC,IAAM,aAAa,GAChC","ignoreList":[1]}
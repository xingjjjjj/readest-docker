{"version":3,"sources":["../../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-dialog%402.6.0/node_modules/%40tauri-apps/plugin-dialog/dist-js/index.js","../../../../../../apps/readest-app/src/utils/files.ts","../../../../../../apps/readest-app/src/services/nativeAppService.ts"],"sourcesContent":["import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Internal function to convert the buttons to the Rust type.\n */\nfunction buttonsToRust(buttons) {\n    if (buttons === undefined) {\n        return undefined;\n    }\n    if (typeof buttons === 'string') {\n        return buttons;\n    }\n    else if ('ok' in buttons && 'cancel' in buttons) {\n        return { OkCancelCustom: [buttons.ok, buttons.cancel] };\n    }\n    else if ('yes' in buttons && 'no' in buttons && 'cancel' in buttons) {\n        return {\n            YesNoCancelCustom: [buttons.yes, buttons.no, buttons.cancel]\n        };\n    }\n    else if ('ok' in buttons) {\n        return { OkCustom: buttons.ok };\n    }\n    return undefined;\n}\n/**\n * Open a file/directory selection dialog.\n *\n * The selected paths are added to the filesystem and asset protocol scopes.\n * When security is more important than the easy of use of this API,\n * prefer writing a dedicated command instead.\n *\n * Note that the scope change is not persisted, so the values are cleared when the application is restarted.\n * You can save it to the filesystem using [tauri-plugin-persisted-scope](https://github.com/tauri-apps/tauri-plugin-persisted-scope).\n * @example\n * ```typescript\n * import { open } from '@tauri-apps/plugin-dialog';\n * // Open a selection dialog for image files\n * const selected = await open({\n *   multiple: true,\n *   filters: [{\n *     name: 'Image',\n *     extensions: ['png', 'jpeg']\n *   }]\n * });\n * if (Array.isArray(selected)) {\n *   // user selected multiple files\n * } else if (selected === null) {\n *   // user cancelled the selection\n * } else {\n *   // user selected a single file\n * }\n * ```\n *\n * @example\n * ```typescript\n * import { open } from '@tauri-apps/plugin-dialog';\n * import { appDir } from '@tauri-apps/api/path';\n * // Open a selection dialog for directories\n * const selected = await open({\n *   directory: true,\n *   multiple: true,\n *   defaultPath: await appDir(),\n * });\n * if (Array.isArray(selected)) {\n *   // user selected multiple directories\n * } else if (selected === null) {\n *   // user cancelled the selection\n * } else {\n *   // user selected a single directory\n * }\n * ```\n *\n * @returns A promise resolving to the selected path(s)\n *\n * @since 2.0.0\n */\nasync function open(options = {}) {\n    if (typeof options === 'object') {\n        Object.freeze(options);\n    }\n    return await invoke('plugin:dialog|open', { options });\n}\n/**\n * Open a file/directory save dialog.\n *\n * The selected path is added to the filesystem and asset protocol scopes.\n * When security is more important than the easy of use of this API,\n * prefer writing a dedicated command instead.\n *\n * Note that the scope change is not persisted, so the values are cleared when the application is restarted.\n * You can save it to the filesystem using [tauri-plugin-persisted-scope](https://github.com/tauri-apps/tauri-plugin-persisted-scope).\n * @example\n * ```typescript\n * import { save } from '@tauri-apps/plugin-dialog';\n * const filePath = await save({\n *   filters: [{\n *     name: 'Image',\n *     extensions: ['png', 'jpeg']\n *   }]\n * });\n * ```\n *\n * @returns A promise resolving to the selected path.\n *\n * @since 2.0.0\n */\nasync function save(options = {}) {\n    if (typeof options === 'object') {\n        Object.freeze(options);\n    }\n    return await invoke('plugin:dialog|save', { options });\n}\n/**\n * Shows a message dialog with an `Ok` button.\n * @example\n * ```typescript\n * import { message } from '@tauri-apps/plugin-dialog';\n * await message('Tauri is awesome', 'Tauri');\n * await message('File not found', { title: 'Tauri', kind: 'error' });\n * ```\n *\n * @param message The message to show.\n * @param options The dialog's options. If a string, it represents the dialog title.\n *\n * @returns A promise indicating the success or failure of the operation.\n *\n * @since 2.0.0\n *\n */\nasync function message(message, options) {\n    const opts = typeof options === 'string' ? { title: options } : options;\n    return invoke('plugin:dialog|message', {\n        message: message.toString(),\n        title: opts?.title?.toString(),\n        kind: opts?.kind,\n        okButtonLabel: opts?.okLabel?.toString(),\n        buttons: buttonsToRust(opts?.buttons)\n    });\n}\n/**\n * Shows a question dialog with `Yes` and `No` buttons.\n * @example\n * ```typescript\n * import { ask } from '@tauri-apps/plugin-dialog';\n * const yes = await ask('Are you sure?', 'Tauri');\n * const yes2 = await ask('This action cannot be reverted. Are you sure?', { title: 'Tauri', kind: 'warning' });\n * ```\n *\n * @param message The message to show.\n * @param options The dialog's options. If a string, it represents the dialog title.\n *\n * @returns A promise resolving to a boolean indicating whether `Yes` was clicked or not.\n *\n * @since 2.0.0\n */\nasync function ask(message, options) {\n    const opts = typeof options === 'string' ? { title: options } : options;\n    return await invoke('plugin:dialog|ask', {\n        message: message.toString(),\n        title: opts?.title?.toString(),\n        kind: opts?.kind,\n        yesButtonLabel: opts?.okLabel?.toString(),\n        noButtonLabel: opts?.cancelLabel?.toString()\n    });\n}\n/**\n * Shows a question dialog with `Ok` and `Cancel` buttons.\n * @example\n * ```typescript\n * import { confirm } from '@tauri-apps/plugin-dialog';\n * const confirmed = await confirm('Are you sure?', 'Tauri');\n * const confirmed2 = await confirm('This action cannot be reverted. Are you sure?', { title: 'Tauri', kind: 'warning' });\n * ```\n *\n * @param message The message to show.\n * @param options The dialog's options. If a string, it represents the dialog title.\n *\n * @returns A promise resolving to a boolean indicating whether `Ok` was clicked or not.\n *\n * @since 2.0.0\n */\nasync function confirm(message, options) {\n    const opts = typeof options === 'string' ? { title: options } : options;\n    return await invoke('plugin:dialog|confirm', {\n        message: message.toString(),\n        title: opts?.title?.toString(),\n        kind: opts?.kind,\n        okButtonLabel: opts?.okLabel?.toString(),\n        cancelButtonLabel: opts?.cancelLabel?.toString()\n    });\n}\n\nexport { ask, confirm, message, open, save };\n","import { AppService, FileItem } from '@/types/system';\n\nexport const copyFiles = async (appService: AppService, srcDir: string, dstDir: string) => {\n  let filesToCopy: FileItem[] = [];\n  try {\n    filesToCopy = await appService.readDirectory(srcDir, 'None');\n  } catch {\n    throw new Error(`Dir ${srcDir} failed to read.`);\n  }\n\n  for (let i = 0; i < filesToCopy.length; i++) {\n    const file = filesToCopy[i]!;\n    const srcPath = `${srcDir}/${file.path}`;\n    const destPath = `${dstDir}/${file.path}`;\n    await appService.copyFile(srcPath, destPath, 'None');\n  }\n\n  const filesCopied = await appService.readDirectory(dstDir, 'None');\n  for (const file of filesToCopy) {\n    if (!filesCopied.find((f) => f.path === file.path && f.size === file.size)) {\n      throw new Error(`File ${file.path} failed to copy.`);\n    }\n  }\n};\n","import {\n  exists,\n  mkdir,\n  readTextFile,\n  readFile,\n  writeTextFile,\n  writeFile,\n  readDir,\n  remove,\n  copyFile,\n  stat,\n  BaseDirectory,\n  WriteFileOptions,\n  DirEntry,\n} from '@tauri-apps/plugin-fs';\nimport { invoke, convertFileSrc } from '@tauri-apps/api/core';\nimport { open as openDialog, save as saveDialog } from '@tauri-apps/plugin-dialog';\nimport {\n  join,\n  basename,\n  appDataDir,\n  appConfigDir,\n  appCacheDir,\n  appLogDir,\n  tempDir,\n} from '@tauri-apps/api/path';\nimport { type as osType } from '@tauri-apps/plugin-os';\nimport { shareFile } from '@choochmeque/tauri-plugin-sharekit-api';\n\nimport {\n  FileSystem,\n  BaseDir,\n  AppPlatform,\n  ResolvedPath,\n  FileItem,\n  DistChannel,\n} from '@/types/system';\nimport { getOSPlatform, isContentURI, isFileURI, isValidURL } from '@/utils/misc';\nimport { getDirPath, getFilename } from '@/utils/path';\nimport { NativeFile, RemoteFile } from '@/utils/file';\nimport { copyURIToPath } from '@/utils/bridge';\nimport { copyFiles } from '@/utils/files';\n\nimport { BaseAppService } from './appService';\nimport {\n  DATA_SUBDIR,\n  LOCAL_BOOKS_SUBDIR,\n  LOCAL_FONTS_SUBDIR,\n  LOCAL_IMAGES_SUBDIR,\n  SETTINGS_FILENAME,\n} from './constants';\n\ndeclare global {\n  interface Window {\n    __READEST_UPDATER_DISABLED?: boolean;\n    __READEST_IS_EINK?: boolean;\n  }\n}\n\n// Lazy evaluation to avoid calling osType() at module load time\n// This prevents errors when the module is imported in non-Tauri environments\nlet OS_TYPE: ReturnType<typeof osType> | null = null;\nconst getOSType = () => {\n  if (OS_TYPE === null) {\n    OS_TYPE = osType();\n  }\n  return OS_TYPE;\n};\n\n// Helper function to create a path resolver based on custom root directory and portable mode\n// 0. If no custom root dir and not portable mode, use default Tauri BaseDirectory\n// 1. If custom root dir is set, use it as base dir (baseDir = 0)\n// 2. If portable mode is detected (Settings.json in executable dir), use executable dir as base dir (baseDir = 0)\n// 3. If both custom root dir and portable mode are set, use custom root dir as base dir (baseDir = 0)\n// Path Resolver Usage:\n//  - appService.resolvePath and use returned baseDir + fp, when baseDir is 0, fp will be absolute path\n//  - fileSystem.getPrefix and use prefix + path\nconst getPathResolver = ({\n  customRootDir,\n  isPortable,\n  execDir,\n}: {\n  customRootDir?: string;\n  isPortable?: boolean;\n  execDir?: string;\n} = {}) => {\n  const customBaseDir = customRootDir ? 0 : undefined;\n  const isCustomBaseDir = Boolean(customRootDir);\n  const getCustomBasePrefixSync = isCustomBaseDir\n    ? (baseDir: BaseDir) => {\n      return () => {\n        const dataDirs = ['Settings', 'Data', 'Books', 'Fonts', 'Images'];\n        const leafDir = dataDirs.includes(baseDir) ? '' : baseDir;\n        return leafDir ? `${customRootDir}/${leafDir}` : customRootDir!;\n      };\n    }\n    : undefined;\n\n  const getCustomBasePrefix = getCustomBasePrefixSync\n    ? (baseDir: BaseDir) => async () => getCustomBasePrefixSync(baseDir)()\n    : undefined;\n\n  return (path: string, base: BaseDir): ResolvedPath => {\n    const customBasePrefixSync = getCustomBasePrefixSync?.(base);\n    const customBasePrefix = getCustomBasePrefix?.(base);\n    switch (base) {\n      case 'Settings':\n        return {\n          baseDir: isPortable ? 0 : BaseDirectory.AppConfig,\n          basePrefix: isPortable && execDir ? async () => execDir : appConfigDir,\n          fp: isPortable && execDir ? `${execDir}${path ? `/${path}` : ''}` : path,\n          base,\n        };\n      case 'Cache':\n        return {\n          baseDir: BaseDirectory.AppCache,\n          basePrefix: appCacheDir,\n          fp: path,\n          base,\n        };\n      case 'Log':\n        return {\n          baseDir: isCustomBaseDir ? 0 : BaseDirectory.AppLog,\n          basePrefix: customBasePrefix ?? appLogDir,\n          fp: customBasePrefixSync ? `${customBasePrefixSync()}${path ? `/${path}` : ''}` : path,\n          base,\n        };\n      case 'Data':\n        return {\n          baseDir: customBaseDir ?? BaseDirectory.AppData,\n          basePrefix: customBasePrefix ?? appDataDir,\n          fp: customBasePrefixSync\n            ? `${customBasePrefixSync()}/${DATA_SUBDIR}${path ? `/${path}` : ''}`\n            : `${DATA_SUBDIR}${path ? `/${path}` : ''}`,\n          base,\n        };\n      case 'Books':\n        return {\n          baseDir: customBaseDir ?? BaseDirectory.AppData,\n          basePrefix: customBasePrefix || appDataDir,\n          fp: customBasePrefixSync\n            ? `${customBasePrefixSync()}/${LOCAL_BOOKS_SUBDIR}${path ? `/${path}` : ''}`\n            : `${LOCAL_BOOKS_SUBDIR}${path ? `/${path}` : ''}`,\n          base,\n        };\n      case 'Fonts':\n        return {\n          baseDir: customBaseDir ?? BaseDirectory.AppData,\n          basePrefix: customBasePrefix || appDataDir,\n          fp: customBasePrefixSync\n            ? `${customBasePrefixSync()}/${LOCAL_FONTS_SUBDIR}${path ? `/${path}` : ''}`\n            : `${LOCAL_FONTS_SUBDIR}${path ? `/${path}` : ''}`,\n          base,\n        };\n      case 'Images':\n        return {\n          baseDir: customBaseDir ?? BaseDirectory.AppData,\n          basePrefix: customBasePrefix || appDataDir,\n          fp: customBasePrefixSync\n            ? `${customBasePrefixSync()}/${LOCAL_IMAGES_SUBDIR}${path ? `/${path}` : ''}`\n            : `${LOCAL_IMAGES_SUBDIR}${path ? `/${path}` : ''}`,\n          base,\n        };\n      case 'None':\n        return {\n          baseDir: 0,\n          basePrefix: async () => '',\n          fp: path,\n          base,\n        };\n      case 'Temp':\n      default:\n        return {\n          baseDir: BaseDirectory.Temp,\n          basePrefix: tempDir,\n          fp: path,\n          base,\n        };\n    }\n  };\n};\n\nexport const nativeFileSystem: FileSystem = {\n  resolvePath: getPathResolver(),\n\n  async getPrefix(base: BaseDir) {\n    const { basePrefix, fp, baseDir } = this.resolvePath('', base);\n    let basePath = await basePrefix();\n    basePath = basePath.replace(/\\/+$/, '');\n    return fp ? (baseDir === 0 ? fp : await join(basePath, fp)) : basePath;\n  },\n  getURL(path: string) {\n    return isValidURL(path) ? path : convertFileSrc(path);\n  },\n  async getBlobURL(path: string, base: BaseDir) {\n    const content = await this.readFile(path, base, 'binary');\n    return URL.createObjectURL(new Blob([content]));\n  },\n  async getImageURL(path: string) {\n    return this.getURL(path);\n  },\n  async openFile(path: string, base: BaseDir, name?: string) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n    let fname = name || getFilename(fp);\n    if (isValidURL(path)) {\n      return await new RemoteFile(path, fname).open();\n    } else if (isContentURI(path) || (isFileURI(path) && getOSType() === 'ios')) {\n      fname = await basename(path);\n      if (path.includes('com.android.externalstorage')) {\n        // If the URI is from shared internal storage (like /storage/emulated/0),\n        // we can access it directly using the path — no need to copy.\n        return await new NativeFile(fp, fname, baseDir ? baseDir : null).open();\n      } else {\n        // Otherwise, for content:// URIs (e.g. from MediaStore, Drive, or third-party apps),\n        // or file:// URIs is security scoped resource in iOS (e.g. from Files app),\n        // we cannot access the file directly — so we copy it to a temporary cache location.\n        const prefix = await this.getPrefix('Cache');\n        const dst = await join(prefix, decodeURIComponent(fname));\n        const res = await copyURIToPath({ uri: path, dst });\n        if (!res.success) {\n          console.error('Failed to open file:', res);\n          throw new Error('Failed to open file');\n        }\n        return await new NativeFile(dst, fname, baseDir ? baseDir : null).open();\n      }\n    } else if (isFileURI(path)) {\n      return await new NativeFile(fp, fname, baseDir ? baseDir : null).open();\n    } else {\n      if (getOSType() === 'android') {\n        // NOTE: RemoteFile is not usable on Android due to a known issue of range request in Android WebView.\n        // see https://issues.chromium.org/issues/40739128\n        return await new NativeFile(fp, fname, baseDir ? baseDir : null).open();\n      } else {\n        // NOTE: RemoteFile currently performs about 2× faster than NativeFile\n        // due to an unresolved performance issue in Tauri (see tauri-apps/tauri#9190).\n        // Once the bug is resolved, we should switch back to using NativeFile.\n        const prefix = await this.getPrefix(base);\n        const absolutePath = prefix ? await join(prefix, path) : path;\n        return await new RemoteFile(this.getURL(absolutePath), fname).open();\n      }\n    }\n  },\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n    try {\n      if (!(await this.exists(getDirPath(dstPath), base))) {\n        await this.createDir(getDirPath(dstPath), base, true);\n      }\n    } catch (error) {\n      console.log('Failed to create directory for copying file:', error);\n    }\n    if (isContentURI(srcPath)) {\n      const prefix = await this.getPrefix(base);\n      if (!prefix) {\n        throw new Error('Invalid base directory');\n      }\n      const res = await copyURIToPath({\n        uri: srcPath,\n        dst: await join(prefix, dstPath),\n      });\n      if (!res.success) {\n        console.error('Failed to copy file:', res);\n        throw new Error('Failed to copy file');\n      }\n    } else {\n      const { fp, baseDir } = this.resolvePath(dstPath, base);\n      await copyFile(srcPath, fp, baseDir ? { toPathBaseDir: baseDir } : undefined);\n    }\n  },\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    return mode === 'text'\n      ? (readTextFile(fp, baseDir ? { baseDir } : undefined) as Promise<string>)\n      : ((await readFile(fp, baseDir ? { baseDir } : undefined)).buffer as ArrayBuffer);\n  },\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    // NOTE: this could be very slow for large files and might block the UI thread\n    // so do not use this for large files\n    const { fp, baseDir } = this.resolvePath(path, base);\n    if (!(await this.exists(getDirPath(path), base))) {\n      await this.createDir(getDirPath(path), base, true);\n    }\n\n    if (typeof content === 'string') {\n      return writeTextFile(fp, content, baseDir ? { baseDir } : undefined);\n    } else if (content instanceof File) {\n      const writeOptions = {\n        write: true,\n        create: true,\n        baseDir: baseDir ? baseDir : undefined,\n      } as WriteFileOptions;\n      return await writeFile(fp, content.stream(), writeOptions);\n    } else {\n      return await writeFile(fp, new Uint8Array(content), baseDir ? { baseDir } : undefined);\n    }\n  },\n  async removeFile(path: string, base: BaseDir) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    await remove(fp, baseDir ? { baseDir } : undefined);\n  },\n  async createDir(path: string, base: BaseDir, recursive = false) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    await mkdir(fp, { baseDir: baseDir ? baseDir : undefined, recursive });\n  },\n  async removeDir(path: string, base: BaseDir, recursive = false) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    await remove(fp, { baseDir: baseDir ? baseDir : undefined, recursive });\n  },\n  async readDir(path: string, base: BaseDir) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    const getRelativePath = (filePath: string, basePath: string): string => {\n      let relativePath = filePath;\n      if (filePath.toLowerCase().startsWith(basePath.toLowerCase())) {\n        relativePath = filePath.substring(basePath.length);\n      }\n      if (relativePath.startsWith('\\\\') || relativePath.startsWith('/')) {\n        relativePath = relativePath.substring(1);\n      }\n      return relativePath;\n    };\n\n    // Use Rust WalkDir for massive performance gain on absolute paths\n    if (!baseDir || baseDir === 0) {\n      try {\n        const files = await invoke<{ path: string; size: number }[]>('read_dir', {\n          path: fp,\n          recursive: true,\n          extensions: ['*'],\n        });\n\n        return files.map((file) => ({\n          path: getRelativePath(file.path, fp),\n          size: file.size,\n        }));\n      } catch (e) {\n        console.error('Rust read_dir failed, falling back to JS recursion', e);\n      }\n    }\n\n    // Fallback to readDir for non-absolute paths or on error\n    const entries = await readDir(fp, baseDir ? { baseDir } : undefined);\n    const fileList: FileItem[] = [];\n    const readDirRecursively = async (\n      parent: string,\n      relative: string,\n      entries: DirEntry[],\n      fileList: FileItem[],\n    ) => {\n      for (const entry of entries) {\n        if (entry.isDirectory) {\n          const dir = await join(parent, entry.name);\n          const relativeDir = relative ? await join(relative, entry.name) : entry.name;\n          try {\n            const entries = await readDir(dir, baseDir ? { baseDir } : undefined);\n            await readDirRecursively(dir, relativeDir, entries, fileList);\n          } catch {\n            console.warn(`Skipping unreadable dir: ${dir}`);\n          }\n        } else {\n          const filePath = await join(parent, entry.name);\n          const relativePath = relative ? await join(relative, entry.name) : entry.name;\n          const opts = baseDir ? { baseDir } : undefined;\n          const fileSize = await stat(filePath, opts)\n            .then((info) => info.size)\n            .catch(() => 0);\n          fileList.push({\n            path: relativePath,\n            size: fileSize,\n          });\n        }\n      }\n    };\n    await readDirRecursively(fp, '', entries, fileList);\n    return fileList;\n  },\n  async exists(path: string, base: BaseDir) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    try {\n      const res = await exists(fp, baseDir ? { baseDir } : undefined);\n      return res;\n    } catch {\n      return false;\n    }\n  },\n  async stats(path: string, base: BaseDir) {\n    const { fp, baseDir } = this.resolvePath(path, base);\n\n    return await stat(fp, baseDir ? { baseDir } : undefined);\n  },\n};\n\nconst DIST_CHANNEL = (process.env['NEXT_PUBLIC_DIST_CHANNEL'] || 'readest') as DistChannel;\n\nexport class NativeAppService extends BaseAppService {\n  fs = nativeFileSystem;\n  override appPlatform = 'tauri' as AppPlatform;\n  override isAppDataSandbox = false;\n  override isMobile = false;\n  override isAndroidApp = false;\n  override isIOSApp = false;\n  override isMacOSApp = false;\n  override isLinuxApp = false;\n  override isMobileApp = false;\n  override isDesktopApp = false;\n  override isEink = Boolean(window.__READEST_IS_EINK);\n  override hasTrafficLight = false;\n  override hasWindow = false;\n  override hasWindowBar = false;\n  override hasContextMenu = false;\n  override hasRoundedWindow = false;\n  override hasSafeAreaInset = false;\n  override hasHaptics = false;\n  override hasUpdater = false;\n  override hasOrientationLock = false;\n  override hasScreenBrightness = false;\n  override hasIAP = false;\n  // CustomizeRootDir has a blocker on macOS App Store builds due to Security Scoped Resource restrictions.\n  // See: https://github.com/tauri-apps/tauri/issues/3716\n  override canCustomizeRootDir = DIST_CHANNEL !== 'appstore';\n  override canReadExternalDir = DIST_CHANNEL !== 'appstore' && DIST_CHANNEL !== 'playstore';\n  override distChannel = DIST_CHANNEL;\n\n  private execDir?: string = undefined;\n\n  override async init() {\n    // Check if running in Tauri environment\n    if (typeof window !== 'undefined' && !(window as any).__TAURI__) {\n      throw new Error('NativeAppService can only be initialized in Tauri environment');\n    }\n\n    // Initialize platform-specific properties based on OS type\n    const osType = getOSType();\n    this.isAppDataSandbox = ['android', 'ios'].includes(osType);\n    this.isMobile = ['android', 'ios'].includes(osType);\n    this.isAndroidApp = osType === 'android';\n    this.isIOSApp = osType === 'ios';\n    this.isMacOSApp = osType === 'macos';\n    this.isLinuxApp = osType === 'linux';\n    this.isMobileApp = ['android', 'ios'].includes(osType);\n    this.isDesktopApp = ['macos', 'windows', 'linux'].includes(osType);\n    this.hasTrafficLight = osType === 'macos';\n    this.hasWindow = !(osType === 'ios' || osType === 'android');\n    this.hasWindowBar = !(osType === 'ios' || osType === 'android');\n    this.hasContextMenu = !(osType === 'ios' || osType === 'android');\n    this.hasRoundedWindow = osType === 'linux';\n    this.hasSafeAreaInset = osType === 'ios' || osType === 'android';\n    this.hasHaptics = osType === 'ios' || osType === 'android';\n    this.hasUpdater = osType !== 'ios' &&\n      !process.env['NEXT_PUBLIC_DISABLE_UPDATER'] &&\n      !window.__READEST_UPDATER_DISABLED;\n    this.hasOrientationLock = (osType === 'ios' && getOSPlatform() === 'ios') || osType === 'android';\n    this.hasScreenBrightness = osType === 'ios' || osType === 'android';\n    this.hasIAP = osType === 'ios' || (osType === 'android' && DIST_CHANNEL === 'playstore');\n\n    const execDir = await invoke<string>('get_executable_dir');\n    this.execDir = execDir;\n    if (\n      process.env['NEXT_PUBLIC_PORTABLE_APP'] ||\n      (await this.fs.exists(`${execDir}/${SETTINGS_FILENAME}`, 'None'))\n    ) {\n      this.isPortableApp = true;\n      this.fs.resolvePath = getPathResolver({\n        customRootDir: execDir,\n        isPortable: this.isPortableApp,\n        execDir,\n      });\n    }\n    const settings = await this.loadSettings();\n    if (settings.customRootDir) {\n      this.fs.resolvePath = getPathResolver({\n        customRootDir: settings.customRootDir,\n        isPortable: this.isPortableApp,\n        execDir,\n      });\n    }\n    await this.prepareBooksDir();\n    await this.runMigrations();\n  }\n\n  override async runMigrations() {\n    try {\n      const settings = await this.loadSettings();\n      const lastMigrationVersion = settings.migrationVersion || 0;\n\n      await super.runMigrations(lastMigrationVersion);\n\n      if (lastMigrationVersion < 20251029) {\n        try {\n          await this.migrate20251029();\n        } catch (error) {\n          console.error('Error migrating to version 20251029:', error);\n        }\n      }\n\n      if (lastMigrationVersion < this.CURRENT_MIGRATION_VERSION) {\n        await this.saveSettings({\n          ...settings,\n          migrationVersion: this.CURRENT_MIGRATION_VERSION,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to run migrations:', error);\n    }\n  }\n\n  override resolvePath(fp: string, base: BaseDir): ResolvedPath {\n    return this.fs.resolvePath(fp, base);\n  }\n\n  async setCustomRootDir(customRootDir: string) {\n    this.fs.resolvePath = getPathResolver({\n      customRootDir,\n      isPortable: this.isPortableApp,\n      execDir: this.execDir,\n    });\n    await this.prepareBooksDir();\n  }\n\n  async selectDirectory(): Promise<string> {\n    const selected = await openDialog({\n      directory: true,\n      multiple: false,\n      recursive: true,\n    });\n    return selected as string;\n  }\n\n  async selectFiles(name: string, extensions: string[]): Promise<string[]> {\n    const selected = await openDialog({\n      multiple: true,\n      filters: [{ name, extensions }],\n    });\n    return Array.isArray(selected) ? selected : selected ? [selected] : [];\n  }\n\n  async saveFile(\n    filename: string,\n    content: string | ArrayBuffer,\n    filepath: string,\n    mimeType?: string,\n  ): Promise<boolean> {\n    try {\n      const ext = filename.split('.').pop() || '';\n      if (this.isIOSApp) {\n        await shareFile(filepath, {\n          mimeType: mimeType || 'application/octet-stream',\n        });\n      } else {\n        const filePath = await saveDialog({\n          defaultPath: filename,\n          filters: [{ name: ext.toUpperCase(), extensions: [ext] }],\n        });\n        if (!filePath) return false;\n\n        if (typeof content === 'string') {\n          await writeTextFile(filePath, content);\n        } else {\n          await writeFile(filePath, new Uint8Array(content));\n        }\n      }\n      return true;\n    } catch (error) {\n      console.error('Failed to save file:', error);\n      return false;\n    }\n  }\n\n  async migrate20251029() {\n    console.log('Running migration 20251029 to update paths in Images dir...');\n    const rootPath = await this.resolveFilePath('..', 'Data');\n    const newDir = await this.fs.getPrefix('Images');\n    const oldDir = await join(rootPath, 'Images', 'Readest', 'Images');\n\n    await copyFiles(this, oldDir, newDir);\n\n    const dirToDelete = await join(rootPath, 'Images', 'Readest');\n    await this.deleteDir(dirToDelete, 'None', true);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}
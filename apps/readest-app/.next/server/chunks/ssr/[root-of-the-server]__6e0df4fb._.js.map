{"version":3,"sources":["../../../../../../packages/foliate-js/epubcfi.js","../../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-os%402.3.2/node_modules/%40tauri-apps/plugin-os/dist-js/index.js"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n","import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Provides operating system-related utility methods and properties.\n *\n * @module\n */\n/**\n * Returns the operating system-specific end-of-line marker.\n * - `\\n` on POSIX\n * - `\\r\\n` on Windows\n *\n * @since 2.0.0\n * */\nfunction eol() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.eol;\n}\n/**\n * Returns a string describing the specific operating system in use.\n * The value is set at compile time. Possible values are `'linux'`, `'macos'`, `'ios'`, `'freebsd'`, `'dragonfly'`, `'netbsd'`, `'openbsd'`, `'solaris'`, `'android'`, `'windows'`\n *\n * @example\n * ```typescript\n * import { platform } from '@tauri-apps/plugin-os';\n * const platformName = platform();\n * ```\n *\n * @since 2.0.0\n *\n */\nfunction platform() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.platform;\n}\n/**\n * Returns the current operating system version.\n * @example\n * ```typescript\n * import { version } from '@tauri-apps/plugin-os';\n * const osVersion = version();\n * ```\n *\n * @since 2.0.0\n */\nfunction version() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.version;\n}\n/**\n * Returns the current operating system family. Possible values are `'unix'`, `'windows'`.\n * @example\n * ```typescript\n * import { family } from '@tauri-apps/plugin-os';\n * const family = family();\n * ```\n *\n * @since 2.0.0\n */\nfunction family() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.family;\n}\n/**\n * Returns the current operating system type. Returns `'linux'` on Linux, `'macos'` on macOS, `'windows'` on Windows, `'ios'` on iOS and `'android'` on Android.\n * @example\n * ```typescript\n * import { type } from '@tauri-apps/plugin-os';\n * const osType = type();\n * ```\n *\n * @since 2.0.0\n */\nfunction type() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.os_type;\n}\n/**\n * Returns the current operating system architecture.\n * Possible values are `'x86'`, `'x86_64'`, `'arm'`, `'aarch64'`, `'mips'`, `'mips64'`, `'powerpc'`, `'powerpc64'`, `'riscv64'`, `'s390x'`, `'sparc64'`.\n * @example\n * ```typescript\n * import { arch } from '@tauri-apps/plugin-os';\n * const archName = arch();\n * ```\n *\n * @since 2.0.0\n */\nfunction arch() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.arch;\n}\n/**\n * Returns the file extension, if any, used for executable binaries on this platform. Possible values are `'exe'` and `''` (empty string).\n * @example\n * ```typescript\n * import { exeExtension } from '@tauri-apps/plugin-os';\n * const exeExt = exeExtension();\n * ```\n *\n * @since 2.0.0\n */\nfunction exeExtension() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.exe_extension;\n}\n/**\n * Returns a String with a `BCP-47` language tag inside. If the locale couldnâ€™t be obtained, `null` is returned instead.\n * @example\n * ```typescript\n * import { locale } from '@tauri-apps/plugin-os';\n * const locale = await locale();\n * if (locale) {\n *    // use the locale string here\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function locale() {\n    return await invoke('plugin:os|locale');\n}\n/**\n * Returns the host name of the operating system.\n * @example\n * ```typescript\n * import { hostname } from '@tauri-apps/plugin-os';\n * const hostname = await hostname();\n * ```\n */\nasync function hostname() {\n    return await invoke('plugin:os|hostname');\n}\n\nexport { arch, eol, exeExtension, family, hostname, locale, platform, type, version };\n"],"names":[],"mappings":"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","ignoreList":[1]}
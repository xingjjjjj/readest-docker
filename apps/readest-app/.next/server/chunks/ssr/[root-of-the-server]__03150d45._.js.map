{"version":3,"sources":["../../../../../../packages/foliate-js/epubcfi.js","../../../../../../apps/readest-app/src/services/apiFileSystem.ts","../../../../../../apps/readest-app/src/services/webAppService.ts"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n","import { FileSystem, BaseDir, ResolvedPath, FileItem } from '@/types/system';\nimport { isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { LOCAL_BOOKS_SUBDIR, LOCAL_FONTS_SUBDIR, LOCAL_IMAGES_SUBDIR, DATA_SUBDIR } from './constants';\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n    // Check if we're in local storage mode\n    const isLocalMode = (typeof process !== 'undefined' && process.env?.['NEXT_PUBLIC_STORAGE_MODE'] === 'local') ||\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local');\n\n    if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        console.log('[ResolvePath] Env Check - NEXT_PUBLIC_STORAGE_MODE:', process.env?.['NEXT_PUBLIC_STORAGE_MODE'], 'isLocalMode:', isLocalMode, 'base:', base, 'path:', path);\n    }\n\n    switch (base) {\n        case 'Data':\n            return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n        case 'Settings':\n            // Settings files now stored in .readest directory\n            return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n        case 'Books':\n            // Always use flat storage structure (no Readest/Books/ prefix)\n            // Library metadata files now go to .readest directory\n            if (path === 'library.json' || path === 'library.json.bak' || path === 'library_backup.json') {\n                console.log('[ResolvePath] Books/Library detected, routing to .readest');\n                return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n            }\n            // All book files and metadata use flat structure (no Readest/Books/ prefix)\n            console.log('[ResolvePath] ✓ Books base, flat path (no prefix):', path);\n            console.log('[ResolvePath] ✓ Returning fp:', path);\n            return { baseDir: 0, basePrefix, fp: path, base };\n        case 'Fonts':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n        case 'Images':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n        case 'None':\n            return { baseDir: 0, basePrefix, fp: path, base };\n        default:\n            return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n    }\n};\n\nexport const apiFileSystem: FileSystem = {\n    resolvePath,\n    async getPrefix(base: BaseDir) {\n        const { basePrefix, fp } = this.resolvePath('', base);\n        const basePath = await basePrefix();\n        const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n        return prefix.replace(/\\/+$/, '');\n    },\n    getURL(path: string) {\n        if (isValidURL(path)) {\n            return path;\n        }\n        return `/api/storage/file?filePath=${encodeURIComponent(path)}`;\n    },\n    async getBlobURL(path: string, base: BaseDir) {\n        try {\n            const content = await this.readFile(path, base, 'binary');\n            return URL.createObjectURL(new Blob([content]));\n        } catch {\n            return path;\n        }\n    },\n    async getImageURL(path: string) {\n        return this.getURL(path);\n    },\n    async openFile(path: string, base: BaseDir, filename?: string) {\n        if (isValidURL(path)) {\n            return await new RemoteFile(path, filename).open();\n        }\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        return new File([await res.arrayBuffer()], filename || path);\n    },\n    async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n        const file = await this.openFile(srcPath, base);\n        await this.writeFile(dstPath, base, file);\n    },\n    async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error(`File not found: ${fp}`);\n        return mode === 'text' ? await res.text() : await res.arrayBuffer();\n    },\n    async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n        const { fp } = this.resolvePath(path, base);\n        console.log('[APIFileSystem.writeFile] 11. Input path:', path);\n        console.log('[APIFileSystem.writeFile] 12. Base:', base);\n        console.log('[APIFileSystem.writeFile] 13. Resolved fp:', fp);\n        let buffer: Buffer;\n        if (content instanceof File) {\n            buffer = Buffer.from(await content.arrayBuffer());\n        } else if (typeof content === 'string') {\n            buffer = Buffer.from(content);\n        } else {\n            buffer = Buffer.from(content);\n        }\n        console.log('[APIFileSystem.writeFile] 14. Calling PUT /api/storage/file with filePath:', fp);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`, {\n            method: 'PUT',\n            body: buffer,\n        });\n        if (!res.ok) throw new Error('Failed to write file');\n    },\n    async removeFile(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/delete?fileKey=${encodeURIComponent(fp)}`, {\n            method: 'DELETE',\n        });\n        if (!res.ok) throw new Error('Failed to delete file');\n    },\n    async createDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async removeDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async readDir(path: string, base: BaseDir): Promise<FileItem[]> {\n        return [];\n    },\n    async exists(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        return res.ok;\n    },\n    async stats(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        const buffer = await res.arrayBuffer();\n        return {\n            isFile: true,\n            isDirectory: false,\n            size: buffer.byteLength,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n        };\n    },\n};\n","import { FileSystem, BaseDir, AppPlatform, ResolvedPath, FileItem } from '@/types/system';\nimport { getOSPlatform, isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { isPWA } from './environment';\nimport { BaseAppService } from './appService';\nimport {\n  DATA_SUBDIR,\n  LOCAL_BOOKS_SUBDIR,\n  LOCAL_FONTS_SUBDIR,\n  LOCAL_IMAGES_SUBDIR,\n} from './constants';\nimport { apiFileSystem } from './apiFileSystem';\n\n// Check storage mode at runtime to support window.__STORAGE_MODE__ set by Providers\nconst getIsLocalStorageMode = (): boolean => {\n  // First check window.__STORAGE_MODE__ (runtime set by Providers)\n  if (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') {\n    return true;\n  }\n  // Fallback to compile-time environment variable\n  return (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n};\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n  switch (base) {\n    case 'Data':\n      return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n    case 'Books':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_BOOKS_SUBDIR}/${path}`, base };\n    case 'Fonts':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n    case 'Images':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n    case 'None':\n      return { baseDir: 0, basePrefix, fp: path, base };\n    default:\n      return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n  }\n};\n\nconst dbName = 'AppFileSystem';\nconst dbVersion = 1;\n\nasync function openIndexedDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(dbName, dbVersion);\n\n    request.onupgradeneeded = () => {\n      const db = request.result;\n      if (!db.objectStoreNames.contains('files')) {\n        db.createObjectStore('files', { keyPath: 'path' });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst indexedDBFileSystem: FileSystem = {\n  resolvePath,\n  async getPrefix(base: BaseDir) {\n    const { basePrefix, fp } = this.resolvePath('', base);\n    const basePath = await basePrefix();\n    const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n    return prefix.replace(/\\/+$/, '');\n  },\n  getURL(path: string) {\n    if (isValidURL(path)) {\n      return path;\n    } else {\n      return URL.createObjectURL(new Blob([path]));\n    }\n  },\n  async getBlobURL(path: string, base: BaseDir) {\n    try {\n      const content = await this.readFile(path, base, 'binary');\n      return URL.createObjectURL(new Blob([content]));\n    } catch {\n      return path;\n    }\n  },\n  async getImageURL(path: string) {\n    return await this.getBlobURL(path, 'None');\n  },\n  async openFile(path: string, base: BaseDir, filename?: string) {\n    if (isValidURL(path)) {\n      return await new RemoteFile(path, filename).open();\n    } else {\n      const content = await this.readFile(path, base, 'binary');\n      return new File([content], filename || path);\n    }\n  },\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n    const { fp } = this.resolvePath(dstPath, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const getRequest = store.get(srcPath);\n\n      getRequest.onsuccess = () => {\n        const data = getRequest.result;\n        if (data) {\n          store.put({ path: fp, content: data.content });\n          resolve();\n        } else {\n          reject(new Error(`File not found: ${srcPath}`));\n        }\n      };\n\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  },\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<string | ArrayBuffer>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = async () => {\n        if (request.result) {\n          const content = request.result.content;\n          if (mode === 'text') resolve(content);\n          else {\n            if (content instanceof Blob) {\n              const arrayBuffer = await content.arrayBuffer();\n              resolve(arrayBuffer);\n            } else if (content instanceof ArrayBuffer) {\n              resolve(content);\n            } else if (typeof content === 'string') {\n              resolve(new TextEncoder().encode(content).buffer as ArrayBuffer);\n            } else {\n              reject(new Error('Unsupported content type in IndexedDB'));\n            }\n          }\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    if (content instanceof File) {\n      content = await content.arrayBuffer();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.put({ path: fp, content });\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async removeFile(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.delete(fp);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async createDir(path: string, base: BaseDir) {\n    return await this.writeFile(path, base, '');\n  },\n  async removeDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string }[];\n        files.forEach((file) => {\n          if (file.path.startsWith(fp)) {\n            store.delete(file.path);\n          }\n        });\n      };\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async readDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<FileItem[]>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string; content: string | ArrayBuffer | Blob }[];\n        resolve(\n          files\n            .filter((file) => file.path.startsWith(fp))\n            .map((file) => ({\n              path: file.path.slice(fp.length + 1),\n              size:\n                file.content instanceof Blob\n                  ? file.content.size\n                  : typeof file.content === 'string'\n                    ? file.content.length\n                    : file.content instanceof ArrayBuffer\n                      ? file.content.byteLength\n                      : 0,\n            })),\n        );\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async exists(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<boolean>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => resolve(!!request.result);\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async stats(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (result) {\n          const content = result.content;\n          const size =\n            content instanceof Blob\n              ? content.size\n              : typeof content === 'string'\n                ? content.length\n                : content instanceof ArrayBuffer\n                  ? content.byteLength\n                  : 0;\n          resolve({\n            isFile: true,\n            isDirectory: false,\n            size,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n          });\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n};\n\nexport class WebAppService extends BaseAppService {\n  // Use getter to check storage mode dynamically at runtime\n  get fs(): FileSystem {\n    return getIsLocalStorageMode() ? apiFileSystem : indexedDBFileSystem;\n  }\n  override isMobile = ['android', 'ios'].includes(getOSPlatform());\n  override appPlatform = 'web' as AppPlatform;\n  override hasSafeAreaInset = isPWA();\n\n  override async init() {\n    await this.loadSettings();\n    await this.prepareBooksDir();\n    await this.runMigrations();\n  }\n\n  override async runMigrations() {\n    try {\n      const settings = await this.loadSettings();\n      const lastMigrationVersion = settings.migrationVersion || 0;\n\n      await super.runMigrations(lastMigrationVersion);\n\n      if (lastMigrationVersion < this.CURRENT_MIGRATION_VERSION) {\n        await this.saveSettings({\n          ...settings,\n          migrationVersion: this.CURRENT_MIGRATION_VERSION,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to run migrations:', error);\n    }\n  }\n\n  override resolvePath(fp: string, base: BaseDir): ResolvedPath {\n    return this.fs.resolvePath(fp, base);\n  }\n\n  async setCustomRootDir() {\n    // No-op in web environment\n  }\n\n  async selectDirectory(): Promise<string> {\n    throw new Error('selectDirectory is not supported in browser');\n  }\n\n  async selectFiles(): Promise<string[]> {\n    throw new Error('selectFiles is not supported in browser');\n  }\n\n  async saveFile(filename: string, content: string | ArrayBuffer, mimeType?: string): Promise<boolean> {\n    try {\n      const blob = new Blob([content], { type: mimeType || 'application/octet-stream' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      return true;\n    } catch (error) {\n      console.error('Failed to save file:', error);\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}
{"version":3,"sources":["../../../../../../packages/foliate-js/epubcfi.js","../../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-os%402.3.2/node_modules/%40tauri-apps/plugin-os/dist-js/index.js","../../../../../../packages/foliate-js/overlayer.js"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n","import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Provides operating system-related utility methods and properties.\n *\n * @module\n */\n/**\n * Returns the operating system-specific end-of-line marker.\n * - `\\n` on POSIX\n * - `\\r\\n` on Windows\n *\n * @since 2.0.0\n * */\nfunction eol() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.eol;\n}\n/**\n * Returns a string describing the specific operating system in use.\n * The value is set at compile time. Possible values are `'linux'`, `'macos'`, `'ios'`, `'freebsd'`, `'dragonfly'`, `'netbsd'`, `'openbsd'`, `'solaris'`, `'android'`, `'windows'`\n *\n * @example\n * ```typescript\n * import { platform } from '@tauri-apps/plugin-os';\n * const platformName = platform();\n * ```\n *\n * @since 2.0.0\n *\n */\nfunction platform() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.platform;\n}\n/**\n * Returns the current operating system version.\n * @example\n * ```typescript\n * import { version } from '@tauri-apps/plugin-os';\n * const osVersion = version();\n * ```\n *\n * @since 2.0.0\n */\nfunction version() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.version;\n}\n/**\n * Returns the current operating system family. Possible values are `'unix'`, `'windows'`.\n * @example\n * ```typescript\n * import { family } from '@tauri-apps/plugin-os';\n * const family = family();\n * ```\n *\n * @since 2.0.0\n */\nfunction family() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.family;\n}\n/**\n * Returns the current operating system type. Returns `'linux'` on Linux, `'macos'` on macOS, `'windows'` on Windows, `'ios'` on iOS and `'android'` on Android.\n * @example\n * ```typescript\n * import { type } from '@tauri-apps/plugin-os';\n * const osType = type();\n * ```\n *\n * @since 2.0.0\n */\nfunction type() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.os_type;\n}\n/**\n * Returns the current operating system architecture.\n * Possible values are `'x86'`, `'x86_64'`, `'arm'`, `'aarch64'`, `'mips'`, `'mips64'`, `'powerpc'`, `'powerpc64'`, `'riscv64'`, `'s390x'`, `'sparc64'`.\n * @example\n * ```typescript\n * import { arch } from '@tauri-apps/plugin-os';\n * const archName = arch();\n * ```\n *\n * @since 2.0.0\n */\nfunction arch() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.arch;\n}\n/**\n * Returns the file extension, if any, used for executable binaries on this platform. Possible values are `'exe'` and `''` (empty string).\n * @example\n * ```typescript\n * import { exeExtension } from '@tauri-apps/plugin-os';\n * const exeExt = exeExtension();\n * ```\n *\n * @since 2.0.0\n */\nfunction exeExtension() {\n    return window.__TAURI_OS_PLUGIN_INTERNALS__.exe_extension;\n}\n/**\n * Returns a String with a `BCP-47` language tag inside. If the locale couldnâ€™t be obtained, `null` is returned instead.\n * @example\n * ```typescript\n * import { locale } from '@tauri-apps/plugin-os';\n * const locale = await locale();\n * if (locale) {\n *    // use the locale string here\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function locale() {\n    return await invoke('plugin:os|locale');\n}\n/**\n * Returns the host name of the operating system.\n * @example\n * ```typescript\n * import { hostname } from '@tauri-apps/plugin-os';\n * const hostname = await hostname();\n * ```\n */\nasync function hostname() {\n    return await invoke('plugin:os|hostname');\n}\n\nexport { arch, eol, exeExtension, family, hostname, locale, platform, type, version };\n","const createSVGElement = tag =>\n    document.createElementNS('http://www.w3.org/2000/svg', tag)\n\nexport class Overlayer {\n    #svg = createSVGElement('svg')\n    #map = new Map()\n    #doc = null\n    constructor(doc) {\n        this.#doc = doc\n        Object.assign(this.#svg.style, {\n            position: 'absolute', top: '0', left: '0',\n            width: '100%', height: '100%',\n            pointerEvents: 'none',\n        })\n    }\n    get element() {\n        return this.#svg\n    }\n    get #zoom() {\n        // Safari does not zoom the client rects, while Chrome, Edge and Firefox does\n        if (/^((?!chrome|android).)*AppleWebKit/i.test(navigator.userAgent) && !window.chrome) {\n            return window.getComputedStyle(this.#doc.body).zoom || 1.0\n        }\n        return 1.0\n    }\n    #splitRangeByParagraph(range) {\n        const ancestor = range.commonAncestorContainer\n        const paragraphs = Array.from(ancestor.querySelectorAll?.('p, h1, h2, h3, h4') || [])\n\n        const splitRanges = []\n        paragraphs.forEach((p) => {\n            const pRange = document.createRange()\n            if (range.intersectsNode(p)) {\n                pRange.selectNodeContents(p)\n                if (pRange.compareBoundaryPoints(Range.START_TO_START, range) < 0) {\n                    pRange.setStart(range.startContainer, range.startOffset)\n                }\n                if (pRange.compareBoundaryPoints(Range.END_TO_END, range) > 0) {\n                    pRange.setEnd(range.endContainer, range.endOffset)\n                }\n                splitRanges.push(pRange)\n            }\n        })\n        return splitRanges.length === 0 ? [range] : splitRanges\n    }\n    add(key, range, draw, options) {\n        if (this.#map.has(key)) this.remove(key)\n        if (typeof range === 'function') range = range(this.#svg.getRootNode())\n        const zoom = this.#zoom\n        let rects = []\n        this.#splitRangeByParagraph(range).forEach((pRange) => {\n            const pRects = Array.from(pRange.getClientRects()).map(rect => ({\n                left: rect.left * zoom,\n                top: rect.top * zoom,\n                right: rect.right * zoom,\n                bottom: rect.bottom * zoom,\n                width: rect.width * zoom,\n                height: rect.height * zoom,\n            }))\n            rects = rects.concat(pRects)\n        })\n        const element = draw(rects, options)\n        this.#svg.append(element)\n        this.#map.set(key, { range, draw, options, element, rects })\n    }\n    remove(key) {\n        if (!this.#map.has(key)) return\n        this.#svg.removeChild(this.#map.get(key).element)\n        this.#map.delete(key)\n    }\n    redraw() {\n        for (const obj of this.#map.values()) {\n            const { range, draw, options, element } = obj\n            this.#svg.removeChild(element)\n            const zoom = this.#zoom\n            let rects = []\n            this.#splitRangeByParagraph(range).forEach((pRange) => {\n                const pRects = Array.from(pRange.getClientRects()).map(rect => ({\n                    left: rect.left * zoom,\n                    top: rect.top * zoom,\n                    right: rect.right * zoom,\n                    bottom: rect.bottom * zoom,\n                    width: rect.width * zoom,\n                    height: rect.height * zoom,\n                }))\n                rects = rects.concat(pRects)\n            })\n            const el = draw(rects, options)\n            this.#svg.append(el)\n            obj.element = el\n            obj.rects = rects\n        }\n    }\n    hitTest({ x, y }) {\n        const arr = Array.from(this.#map.entries())\n        // loop in reverse to hit more recently added items first\n        for (let i = arr.length - 1; i >= 0; i--) {\n            const tolerance = 5\n            const [key, obj] = arr[i]\n            for (const { left, top, right, bottom } of obj.rects) {\n                if (\n                    top <= y + tolerance &&\n                    left <= x + tolerance &&\n                    bottom > y - tolerance &&\n                    right > x - tolerance\n                ) {\n                    return [key, obj.range, { left, top, right, bottom }]\n                }\n            }\n        }\n        return []\n    }\n    static underline(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, padding = 0, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, top, height } of rects) {\n                const el = createSVGElement('rect')\n                el.setAttribute('x', right - strokeWidth / 2 + padding)\n                el.setAttribute('y', top)\n                el.setAttribute('height', height)\n                el.setAttribute('width', strokeWidth)\n                g.append(el)\n            }\n        else for (const { left, bottom, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left)\n            el.setAttribute('y', bottom - strokeWidth / 2 + padding)\n            el.setAttribute('height', strokeWidth)\n            el.setAttribute('width', width)\n            g.append(el)\n        }\n        return g\n    }\n    static strikethrough(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, left, top, height } of rects) {\n                const el = createSVGElement('rect')\n                el.setAttribute('x', (right + left) / 2)\n                el.setAttribute('y', top)\n                el.setAttribute('height', height)\n                el.setAttribute('width', strokeWidth)\n                g.append(el)\n            }\n        else for (const { left, top, bottom, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left)\n            el.setAttribute('y', (top + bottom) / 2)\n            el.setAttribute('height', strokeWidth)\n            el.setAttribute('width', width)\n            g.append(el)\n        }\n        return g\n    }\n    static squiggly(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, padding = 0, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', 'none')\n        g.setAttribute('stroke', color)\n        g.setAttribute('stroke-width', strokeWidth)\n        const block = strokeWidth * 1.5\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, top, height } of rects) {\n                const el = createSVGElement('path')\n                const n = Math.round(height / block / 1.5)\n                const inline = height / n\n                const ls = Array.from({ length: n },\n                    (_, i) => `l${i % 2 ? -block : block} ${inline}`).join('')\n                el.setAttribute('d', `M${right - strokeWidth / 2 + padding} ${top}${ls}`)\n                g.append(el)\n            }\n        else for (const { left, bottom, width } of rects) {\n            const el = createSVGElement('path')\n            const n = Math.round(width / block / 1.5)\n            const inline = width / n\n            const ls = Array.from({ length: n },\n                (_, i) => `l${inline} ${i % 2 ? block : -block}`).join('')\n            el.setAttribute('d', `M${left} ${bottom + strokeWidth / 2 + padding}${ls}`)\n            g.append(el)\n        }\n        return g\n    }\n    static highlight(rects, options = {}) {\n        const { color = 'red', padding = 0 } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        g.style.opacity = 'var(--overlayer-highlight-opacity, .3)'\n        g.style.mixBlendMode = 'var(--overlayer-highlight-blend-mode, normal)'\n        for (const { left, top, height, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left - padding)\n            el.setAttribute('y', top - padding)\n            el.setAttribute('height', height + padding * 2)\n            el.setAttribute('width', width + padding * 2)\n            g.append(el)\n        }\n        return g\n    }\n    static outline(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 3, padding = 0, radius = 3 } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', 'none')\n        g.setAttribute('stroke', color)\n        g.setAttribute('stroke-width', strokeWidth)\n        for (const { left, top, height, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left - padding)\n            el.setAttribute('y', top - padding)\n            el.setAttribute('height', height + padding * 2)\n            el.setAttribute('width', width + padding * 2)\n            el.setAttribute('rx', radius)\n            g.append(el)\n        }\n        return g\n    }\n    static bubble(rects, options = {}) {\n        const { color = '#fbbf24', writingMode, opacity = 0.85, size = 20, padding = 10 } = options\n        const isVertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr'\n        const g = createSVGElement('g')\n        g.style.opacity = opacity\n        if (rects.length === 0) return g\n        rects.splice(1)\n        const firstRect = rects[0]\n        const x = isVertical ? firstRect.right - size + padding : firstRect.right - size + padding\n        const y = isVertical ? firstRect.bottom - size + padding : firstRect.top - size + padding\n        firstRect.top = y - padding\n        firstRect.right = x + size + padding\n        firstRect.bottom = y + size + padding\n        firstRect.left = x - padding\n        const bubble = createSVGElement('path')\n        const s = size\n        const r = s * 0.15\n        // Speech bubble shape with a small tail\n        // Main rounded rectangle body\n        const d = `\n            M ${x + r} ${y}\n            h ${s - 2 * r}\n            a ${r} ${r} 0 0 1 ${r} ${r}\n            v ${s * 0.65 - 2 * r}\n            a ${r} ${r} 0 0 1 ${-r} ${r}\n            h ${-s * 0.3}\n            l ${-s * 0.15} ${s * 0.2}\n            l ${s * 0.05} ${-s * 0.2}\n            h ${-s * 0.6 + 2 * r}\n            a ${r} ${r} 0 0 1 ${-r} ${-r}\n            v ${-s * 0.65 + 2 * r}\n            a ${r} ${r} 0 0 1 ${r} ${-r}\n            z\n        `.replace(/\\s+/g, ' ').trim()\n\n        bubble.setAttribute('d', d)\n        bubble.setAttribute('fill', color)\n        bubble.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)')\n        bubble.setAttribute('stroke-width', '1')\n        // Add horizontal lines inside to represent text\n        const lineGroup = createSVGElement('g')\n        lineGroup.setAttribute('stroke', 'rgba(0, 0, 0, 0.3)')\n        lineGroup.setAttribute('stroke-width', '1.5')\n        lineGroup.setAttribute('stroke-linecap', 'round')\n        const lineY1 = y + s * 0.18\n        const lineY2 = y + s * 0.33\n        const lineY3 = y + s * 0.48\n        const lineX1 = x + s * 0.2\n        const lineX2 = x + s * 0.8\n        const line1 = createSVGElement('line')\n        line1.setAttribute('x1', lineX1)\n        line1.setAttribute('y1', lineY1)\n        line1.setAttribute('x2', lineX2)\n        line1.setAttribute('y2', lineY1)\n        const line2 = createSVGElement('line')\n        line2.setAttribute('x1', lineX1)\n        line2.setAttribute('y1', lineY2)\n        line2.setAttribute('x2', lineX2)\n        line2.setAttribute('y2', lineY2)\n        const line3 = createSVGElement('line')\n        line3.setAttribute('x1', lineX1)\n        line3.setAttribute('y1', lineY3)\n        line3.setAttribute('x2', x + s * 0.6)\n        line3.setAttribute('y2', lineY3)\n        lineGroup.append(line1, line2, line3)\n\n        if (isVertical) {\n            const centerX = x + s / 2\n            const centerY = y + s / 2\n            bubble.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`)\n            lineGroup.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`)\n        }\n\n        g.append(bubble)\n        g.append(lineGroup)\n        return g\n    }\n    // make an exact copy of an image in the overlay\n    // one can then apply filters to the entire element, without affecting them;\n    // it's a bit silly and probably better to just invert images twice\n    // (though the color will be off in that case if you do heu-rotate)\n    static copyImage([rect], options = {}) {\n        const { src } = options\n        const image = createSVGElement('image')\n        const { left, top, height, width } = rect\n        image.setAttribute('href', src)\n        image.setAttribute('x', left)\n        image.setAttribute('y', top)\n        image.setAttribute('height', height)\n        image.setAttribute('width', width)\n        return image\n    }\n}\n\n"],"names":[],"mappings":"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","ignoreList":[1]}
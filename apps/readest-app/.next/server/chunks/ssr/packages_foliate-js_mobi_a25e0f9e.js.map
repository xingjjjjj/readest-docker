{"version":3,"sources":["../../../../../../packages/foliate-js/mobi.js"],"sourcesContent":["const unescapeHTML = str => {\n    if (!str) return ''\n    const textarea = document.createElement('textarea')\n    textarea.innerHTML = str\n    return textarea.value\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n}\n\nconst PDB_HEADER = {\n    name: [0, 32, 'string'],\n    type: [60, 4, 'string'],\n    creator: [64, 4, 'string'],\n    numRecords: [76, 2, 'uint'],\n}\n\nconst PALMDOC_HEADER = {\n    compression: [0, 2, 'uint'],\n    numTextRecords: [8, 2, 'uint'],\n    recordSize: [10, 2, 'uint'],\n    encryption: [12, 2, 'uint'],\n}\n\nconst MOBI_HEADER = {\n    magic: [16, 4, 'string'],\n    length: [20, 4, 'uint'],\n    type: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    uid: [32, 4, 'uint'],\n    version: [36, 4, 'uint'],\n    titleOffset: [84, 4, 'uint'],\n    titleLength: [88, 4, 'uint'],\n    localeRegion: [94, 1, 'uint'],\n    localeLanguage: [95, 1, 'uint'],\n    resourceStart: [108, 4, 'uint'],\n    huffcdic: [112, 4, 'uint'],\n    numHuffcdic: [116, 4, 'uint'],\n    exthFlag: [128, 4, 'uint'],\n    trailingFlags: [240, 4, 'uint'],\n    indx: [244, 4, 'uint'],\n}\n\nconst KF8_HEADER = {\n    resourceStart: [108, 4, 'uint'],\n    fdst: [192, 4, 'uint'],\n    numFdst: [196, 4, 'uint'],\n    frag: [248, 4, 'uint'],\n    skel: [252, 4, 'uint'],\n    guide: [260, 4, 'uint'],\n}\n\nconst EXTH_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    count: [8, 4, 'uint'],\n}\n\nconst INDX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    type: [8, 4, 'uint'],\n    idxt: [20, 4, 'uint'],\n    numRecords: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    language: [32, 4, 'uint'],\n    total: [36, 4, 'uint'],\n    ordt: [40, 4, 'uint'],\n    ligt: [44, 4, 'uint'],\n    numLigt: [48, 4, 'uint'],\n    numCncx: [52, 4, 'uint'],\n}\n\nconst TAGX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numControlBytes: [8, 4, 'uint'],\n}\n\nconst HUFF_HEADER = {\n    magic: [0, 4, 'string'],\n    offset1: [8, 4, 'uint'],\n    offset2: [12, 4, 'uint'],\n}\n\nconst CDIC_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numEntries: [8, 4, 'uint'],\n    codeLength: [12, 4, 'uint'],\n}\n\nconst FDST_HEADER = {\n    magic: [0, 4, 'string'],\n    numEntries: [8, 4, 'uint'],\n}\n\nconst FONT_HEADER = {\n    flags: [8, 4, 'uint'],\n    dataStart: [12, 4, 'uint'],\n    keyLength: [16, 4, 'uint'],\n    keyStart: [20, 4, 'uint'],\n}\n\nconst MOBI_ENCODING = {\n    1252: 'windows-1252',\n    65001: 'utf-8',\n}\n\nconst EXTH_RECORD_TYPE = {\n    100: ['creator', 'string', true],\n    101: ['publisher'],\n    103: ['description'],\n    104: ['isbn'],\n    105: ['subject', 'string', true],\n    106: ['date'],\n    108: ['contributor', 'string', true],\n    109: ['rights'],\n    110: ['subjectCode', 'string', true],\n    112: ['source', 'string', true],\n    113: ['asin'],\n    121: ['boundary', 'uint'],\n    122: ['fixedLayout'],\n    125: ['numResources', 'uint'],\n    126: ['originalResolution'],\n    127: ['zeroGutter'],\n    128: ['zeroMargin'],\n    129: ['coverURI'],\n    132: ['regionMagnification'],\n    201: ['coverOffset', 'uint'],\n    202: ['thumbnailOffset', 'uint'],\n    503: ['title'],\n    524: ['language', 'string', true],\n    527: ['pageProgressionDirection'],\n}\n\nconst MOBI_LANG = {\n    1: ['ar', 'ar-SA', 'ar-IQ', 'ar-EG', 'ar-LY', 'ar-DZ', 'ar-MA', 'ar-TN', 'ar-OM',\n        'ar-YE', 'ar-SY', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-AE', 'ar-BH', 'ar-QA'],\n    2: ['bg'], 3: ['ca'], 4: ['zh', 'zh-TW', 'zh-CN', 'zh-HK', 'zh-SG'], 5: ['cs'],\n    6: ['da'], 7: ['de', 'de-DE', 'de-CH', 'de-AT', 'de-LU', 'de-LI'], 8: ['el'],\n    9: ['en', 'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',\n        'en-JM', null, 'en-BZ', 'en-TT', 'en-ZW', 'en-PH'],\n    10: ['es', 'es-ES', 'es-MX', null, 'es-GT', 'es-CR', 'es-PA', 'es-DO',\n        'es-VE', 'es-CO', 'es-PE', 'es-AR', 'es-EC', 'es-CL', 'es-UY', 'es-PY',\n        'es-BO', 'es-SV', 'es-HN', 'es-NI', 'es-PR'],\n    11: ['fi'], 12: ['fr', 'fr-FR', 'fr-BE', 'fr-CA', 'fr-CH', 'fr-LU', 'fr-MC'],\n    13: ['he'], 14: ['hu'], 15: ['is'], 16: ['it', 'it-IT', 'it-CH'],\n    17: ['ja'], 18: ['ko'], 19: ['nl', 'nl-NL', 'nl-BE'], 20: ['no', 'nb', 'nn'],\n    21: ['pl'], 22: ['pt', 'pt-BR', 'pt-PT'], 23: ['rm'], 24: ['ro'], 25: ['ru'],\n    26: ['hr', null, 'sr'], 27: ['sk'], 28: ['sq'], 29: ['sv', 'sv-SE', 'sv-FI'],\n    30: ['th'], 31: ['tr'], 32: ['ur'], 33: ['id'], 34: ['uk'], 35: ['be'],\n    36: ['sl'], 37: ['et'], 38: ['lv'], 39: ['lt'], 41: ['fa'], 42: ['vi'],\n    43: ['hy'], 44: ['az'], 45: ['eu'], 46: ['hsb'], 47: ['mk'], 48: ['st'],\n    49: ['ts'], 50: ['tn'], 52: ['xh'], 53: ['zu'], 54: ['af'], 55: ['ka'],\n    56: ['fo'], 57: ['hi'], 58: ['mt'], 59: ['se'], 62: ['ms'], 63: ['kk'],\n    65: ['sw'], 67: ['uz', null, 'uz-UZ'], 68: ['tt'], 69: ['bn'], 70: ['pa'],\n    71: ['gu'], 72: ['or'], 73: ['ta'], 74: ['te'], 75: ['kn'], 76: ['ml'],\n    77: ['as'], 78: ['mr'], 79: ['sa'], 82: ['cy', 'cy-GB'], 83: ['gl', 'gl-ES'],\n    87: ['kok'], 97: ['ne'], 98: ['fy'],\n}\n\nconst concatTypedArray = (a, b) => {\n    const result = new a.constructor(a.length + b.length)\n    result.set(a)\n    result.set(b, a.length)\n    return result\n}\nconst concatTypedArray3 = (a, b, c) => {\n    const result = new a.constructor(a.length + b.length + c.length)\n    result.set(a)\n    result.set(b, a.length)\n    result.set(c, a.length + b.length)\n    return result\n}\n\nconst decoder = new TextDecoder()\nconst getString = buffer => decoder.decode(buffer)\nconst getUint = buffer => {\n    if (!buffer) return\n    const l = buffer.byteLength\n    const func = l === 4 ? 'getUint32' : l === 2 ? 'getUint16' : 'getUint8'\n    return new DataView(buffer)[func](0)\n}\nconst getStruct = (def, buffer) => Object.fromEntries(Array.from(Object.entries(def))\n    .map(([key, [start, len, type]]) => [key,\n        (type === 'string' ? getString : getUint)(buffer.slice(start, start + len))]))\n\nconst getDecoder = x => new TextDecoder(MOBI_ENCODING[x])\n\nconst getVarLen = (byteArray, i = 0) => {\n    let value = 0, length = 0\n    for (const byte of byteArray.subarray(i, i + 4)) {\n        value = (value << 7) | (byte & 0b111_1111) >>> 0\n        length++\n        if (byte & 0b1000_0000) break\n    }\n    return { value, length }\n}\n\n// variable-length quantity, but read from the end of data\nconst getVarLenFromEnd = byteArray => {\n    let value = 0\n    for (const byte of byteArray.subarray(-4)) {\n        // `byte & 0b1000_0000` indicates the start of value\n        if (byte & 0b1000_0000) value = 0\n        value = (value << 7) | (byte & 0b111_1111)\n    }\n    return value\n}\n\nconst countBitsSet = x => {\n    let count = 0\n    for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++\n    return count\n}\n\nconst countUnsetEnd = x => {\n    let count = 0\n    while ((x & 1) === 0) x = x >> 1, count++\n    return count\n}\n\nconst decompressPalmDOC = array => {\n    let output = []\n    for (let i = 0; i < array.length; i++) {\n        const byte = array[i]\n        if (byte === 0) output.push(0) // uncompressed literal, just copy it\n        else if (byte <= 8) // copy next 1-8 bytes\n            for (const x of array.subarray(i + 1, (i += byte) + 1))\n                output.push(x)\n        else if (byte <= 0b0111_1111) output.push(byte) // uncompressed literal\n        else if (byte <= 0b1011_1111) {\n            // 1st and 2nd bits are 10, meaning this is a length-distance pair\n            // read next byte and combine it with current byte\n            const bytes = (byte << 8) | array[i++ + 1]\n            // the 3rd to 13th bits encode distance\n            const distance = (bytes & 0b0011_1111_1111_1111) >>> 3\n            // the last 3 bits, plus 3, is the length to copy\n            const length = (bytes & 0b111) + 3\n            for (let j = 0; j < length; j++)\n                output.push(output[output.length - distance])\n        }\n        // compressed from space plus char\n        else output.push(32, byte ^ 0b1000_0000)\n    }\n    return Uint8Array.from(output)\n}\n\nconst read32Bits = (byteArray, from) => {\n    const startByte = from >> 3\n    const end = from + 32\n    const endByte = end >> 3\n    let bits = 0n\n    for (let i = startByte; i <= endByte; i++)\n        bits = bits << 8n | BigInt(byteArray[i] ?? 0)\n    return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn\n}\n\nconst huffcdic = async (mobi, loadRecord) => {\n    const huffRecord = await loadRecord(mobi.huffcdic)\n    const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord)\n    if (magic !== 'HUFF') throw new Error('Invalid HUFF record')\n\n    // table1 is indexed by byte value\n    const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)\n        .map(offset => getUint(huffRecord.slice(offset, offset + 4)))\n        .map(x => [x & 0b1000_0000, x & 0b1_1111, x >>> 8])\n\n    // table2 is indexed by code length\n    const table2 = [null].concat(Array.from({ length: 32 }, (_, i) => offset2 + i * 8)\n        .map(offset => [\n            getUint(huffRecord.slice(offset, offset + 4)),\n            getUint(huffRecord.slice(offset + 4, offset + 8))]))\n\n    const dictionary = []\n    for (let i = 1; i < mobi.numHuffcdic; i++) {\n        const record = await loadRecord(mobi.huffcdic + i)\n        const cdic = getStruct(CDIC_HEADER, record)\n        if (cdic.magic !== 'CDIC') throw new Error('Invalid CDIC record')\n        // `numEntries` is the total number of dictionary data across CDIC records\n        // so `n` here is the number of entries in *this* record\n        const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length)\n        const buffer = record.slice(cdic.length)\n        for (let i = 0; i < n; i++) {\n            const offset = getUint(buffer.slice(i * 2, i * 2 + 2))\n            const x = getUint(buffer.slice(offset, offset + 2))\n            const length = x & 0x7fff\n            const decompressed = x & 0x8000\n            const value = new Uint8Array(\n                buffer.slice(offset + 2, offset + 2 + length))\n            dictionary.push([value, decompressed])\n        }\n    }\n\n    const decompress = byteArray => {\n        let output = new Uint8Array()\n        const bitLength = byteArray.byteLength * 8\n        for (let i = 0; i < bitLength;) {\n            const bits = Number(read32Bits(byteArray, i))\n            let [found, codeLength, value] = table1[bits >>> 24]\n            if (!found) {\n                while (bits >>> (32 - codeLength) < table2[codeLength][0])\n                    codeLength += 1\n                value = table2[codeLength][1]\n            }\n            if ((i += codeLength) > bitLength) break\n\n            const code = value - (bits >>> (32 - codeLength))\n            let [result, decompressed] = dictionary[code]\n            if (!decompressed) {\n                // the result is itself compressed\n                result = decompress(result)\n                // cache the result for next time\n                dictionary[code] = [result, true]\n            }\n            output = concatTypedArray(output, result)\n        }\n        return output\n    }\n    return decompress\n}\n\nconst getIndexData = async (indxIndex, loadRecord) => {\n    const indxRecord = await loadRecord(indxIndex)\n    const indx = getStruct(INDX_HEADER, indxRecord)\n    if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n    const decoder = getDecoder(indx.encoding)\n\n    const tagxBuffer = indxRecord.slice(indx.length)\n    const tagx = getStruct(TAGX_HEADER, tagxBuffer)\n    if (tagx.magic !== 'TAGX') throw new Error('Invalid TAGX section')\n    const numTags = (tagx.length - 12) / 4\n    const tagTable = Array.from({ length: numTags }, (_, i) =>\n        new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4)))\n\n    const cncx = {}\n    let cncxRecordOffset = 0\n    for (let i = 0; i < indx.numCncx; i++) {\n        const record = await loadRecord(indxIndex + indx.numRecords + i + 1)\n        const array = new Uint8Array(record)\n        for (let pos = 0; pos < array.byteLength;) {\n            const index = pos\n            const { value, length } = getVarLen(array, pos)\n            pos += length\n            const result = record.slice(pos, pos + value)\n            pos += value\n            cncx[cncxRecordOffset + index] = decoder.decode(result)\n        }\n        cncxRecordOffset += 0x10000\n    }\n\n    const table = []\n    for (let i = 0; i < indx.numRecords; i++) {\n        const record = await loadRecord(indxIndex + 1 + i)\n        const array = new Uint8Array(record)\n        const indx = getStruct(INDX_HEADER, record)\n        if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n        for (let j = 0; j < indx.numRecords; j++) {\n            const offsetOffset = indx.idxt + 4 + 2 * j\n            const offset = getUint(record.slice(offsetOffset, offsetOffset + 2))\n\n            const length = getUint(record.slice(offset, offset + 1))\n            const name = getString(record.slice(offset + 1, offset + 1 + length))\n\n            const tags = []\n            const startPos = offset + 1 + length\n            let controlByteIndex = 0\n            let pos = startPos + tagx.numControlBytes\n            for (const [tag, numValues, mask, end] of tagTable) {\n                if (end & 1) {\n                    controlByteIndex++\n                    continue\n                }\n                const offset = startPos + controlByteIndex\n                const value = getUint(record.slice(offset, offset + 1)) & mask\n                if (value === mask) {\n                    if (countBitsSet(mask) > 1) {\n                        const { value, length } = getVarLen(array, pos)\n                        tags.push([tag, null, value, numValues])\n                        pos += length\n                    } else tags.push([tag, 1, null, numValues])\n                } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues])\n            }\n\n            const tagMap = {}\n            for (const [tag, valueCount, valueBytes, numValues] of tags) {\n                const values = []\n                if (valueCount != null) {\n                    for (let i = 0; i < valueCount * numValues; i++) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                    }\n                } else {\n                    let count = 0\n                    while (count < valueBytes) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                        count += length\n                    }\n                }\n                tagMap[tag] = values\n            }\n            table.push({ name, tagMap })\n        }\n    }\n    return { table, cncx }\n}\n\nconst getNCX = async (indxIndex, loadRecord) => {\n    const { table, cncx } = await getIndexData(indxIndex, loadRecord)\n    const items = table.map(({ tagMap }, index) => ({\n        index,\n        offset: tagMap[1]?.[0],\n        size: tagMap[2]?.[0],\n        label: cncx[tagMap[3]] ?? '',\n        headingLevel: tagMap[4]?.[0],\n        pos: tagMap[6],\n        parent: tagMap[21]?.[0],\n        firstChild: tagMap[22]?.[0],\n        lastChild: tagMap[23]?.[0],\n    }))\n    const getChildren = item => {\n        if (item.firstChild == null) return item\n        item.children = items.filter(x => x.parent === item.index).map(getChildren)\n        return item\n    }\n    return items.filter(item => item.headingLevel === 0).map(getChildren)\n}\n\nconst getEXTH = (buf, encoding) => {\n    const { magic, count } = getStruct(EXTH_HEADER, buf)\n    if (magic !== 'EXTH') throw new Error('Invalid EXTH header')\n    const decoder = getDecoder(encoding)\n    const results = {}\n    let offset = 12\n    for (let i = 0; i < count; i++) {\n        const type = getUint(buf.slice(offset, offset + 4))\n        const length = getUint(buf.slice(offset + 4, offset + 8))\n        if (type in EXTH_RECORD_TYPE) {\n            const [name, typ, many] = EXTH_RECORD_TYPE[type]\n            const data = buf.slice(offset + 8, offset + length)\n            const value = typ === 'uint' ? getUint(data) : decoder.decode(data)\n            if (many) {\n                results[name] ??= []\n                results[name].push(value)\n            } else results[name] = value\n        }\n        offset += length\n    }\n    return results\n}\n\nconst getFont = async (buf, unzlib) => {\n    const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf)\n    const array = new Uint8Array(buf.slice(dataStart))\n    // deobfuscate font\n    if (flags & 0b10) {\n        const bytes = keyLength === 16 ? 1024 : 1040\n        const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength))\n        const length = Math.min(bytes, array.length)\n        for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    }\n    // decompress font\n    if (flags & 1) try {\n        return await unzlib(array)\n    } catch (e) {\n        console.warn(e)\n        console.warn('Failed to decompress font')\n    }\n    return array\n}\n\nexport const isMOBI = async file => {\n    const magic = getString(await file.slice(60, 68).arrayBuffer())\n    return magic === 'BOOKMOBI'// || magic === 'TEXtREAd'\n}\n\nclass PDB {\n    #file\n    #offsets\n    pdb\n    async open(file) {\n        this.#file = file\n        const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer())\n        this.pdb = pdb\n        const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer()\n        // get start and end offsets for each record\n        this.#offsets = Array.from({ length: pdb.numRecords },\n            (_, i) => getUint(buffer.slice(i * 8, i * 8 + 4)))\n            .map((x, i, a) => [x, a[i + 1]])\n    }\n    loadRecord(index) {\n        const offsets = this.#offsets[index]\n        if (!offsets) throw new RangeError('Record index out of bounds')\n        return this.#file.slice(...offsets).arrayBuffer()\n    }\n    async loadMagic(index) {\n        const start = this.#offsets[index][0]\n        return getString(await this.#file.slice(start, start + 4).arrayBuffer())\n    }\n}\n\nexport class MOBI extends PDB {\n    #start = 0\n    #resourceStart\n    #decoder\n    #encoder\n    #decompress\n    #removeTrailingEntries\n    constructor({ unzlib }) {\n        super()\n        this.unzlib = unzlib\n    }\n    async open(file) {\n        await super.open(file)\n        // TODO: if (this.pdb.type === 'TEXt')\n        this.headers = this.#getHeaders(await super.loadRecord(0))\n        this.#resourceStart = this.headers.mobi.resourceStart\n        let isKF8 = this.headers.mobi.version >= 8\n        if (!isKF8) {\n            const boundary = this.headers.exth?.boundary\n            if (boundary < 0xffffffff) try {\n                // it's a \"combo\" MOBI/KF8 file; try to open the KF8 part\n                this.headers = this.#getHeaders(await super.loadRecord(boundary))\n                this.#start = boundary\n                isKF8 = true\n            } catch (e) {\n                console.warn(e)\n                console.warn('Failed to open KF8; falling back to MOBI')\n            }\n        }\n        await this.#setup()\n        return isKF8 ? new KF8(this).init() : new MOBI6(this).init()\n    }\n    #getHeaders(buf) {\n        const palmdoc = getStruct(PALMDOC_HEADER, buf)\n        const mobi = getStruct(MOBI_HEADER, buf)\n        if (mobi.magic !== 'MOBI') throw new Error('Missing MOBI header')\n\n        const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi\n        mobi.title = buf.slice(titleOffset, titleOffset + titleLength)\n        const lang = MOBI_LANG[localeLanguage]\n        mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0]\n\n        const exth = mobi.exthFlag & 0b100_0000\n            ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null\n        const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null\n        return { palmdoc, mobi, exth, kf8 }\n    }\n    async #setup() {\n        const { palmdoc, mobi } = this.headers\n        this.#decoder = getDecoder(mobi.encoding)\n        // `TextEncoder` only supports UTF-8\n        // we are only encoding ASCII anyway, so I think it's fine\n        this.#encoder = new TextEncoder()\n\n        // set up decompressor\n        const { compression } = palmdoc\n        this.#decompress = compression === 1 ? f => f\n            : compression === 2 ? decompressPalmDOC\n            : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this))\n            : null\n        if (!this.#decompress) throw new Error('Unknown compression type')\n\n        // set up function for removing trailing bytes\n        const { trailingFlags } = mobi\n        const multibyte = trailingFlags & 1\n        const numTrailingEntries = countBitsSet(trailingFlags >>> 1)\n        this.#removeTrailingEntries = array => {\n            for (let i = 0; i < numTrailingEntries; i++) {\n                const length = getVarLenFromEnd(array)\n                array = array.subarray(0, -length)\n            }\n            if (multibyte) {\n                const length = (array[array.length - 1] & 0b11) + 1\n                array = array.subarray(0, -length)\n            }\n            return array\n        }\n    }\n    decode(...args) {\n        return this.#decoder.decode(...args)\n    }\n    encode(...args) {\n        return this.#encoder.encode(...args)\n    }\n    loadRecord(index) {\n        return super.loadRecord(this.#start + index)\n    }\n    loadMagic(index) {\n        return super.loadMagic(this.#start + index)\n    }\n    loadText(index) {\n        return this.loadRecord(index + 1)\n            .then(buf => new Uint8Array(buf))\n            .then(this.#removeTrailingEntries)\n            .then(this.#decompress)\n    }\n    async loadResource(index) {\n        const buf = await super.loadRecord(this.#resourceStart + index)\n        const magic = getString(buf.slice(0, 4))\n        if (magic === 'FONT') return getFont(buf, this.unzlib)\n        if (magic === 'VIDE' || magic === 'AUDI') return buf.slice(12)\n        return buf\n    }\n    getNCX() {\n        const index = this.headers.mobi.indx\n        if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this))\n    }\n    getMetadata() {\n        const { mobi, exth } = this.headers\n        return {\n            identifier: mobi.uid.toString(),\n            title: unescapeHTML(exth?.title || this.decode(mobi.title)),\n            author: exth?.creator?.map(unescapeHTML),\n            publisher: unescapeHTML(exth?.publisher),\n            language: exth?.language ?? mobi.language,\n            published: exth?.date,\n            description: unescapeHTML(exth?.description),\n            subject: exth?.subject?.map(unescapeHTML),\n            rights: unescapeHTML(exth?.rights),\n            contributor: exth?.contributor,\n        }\n    }\n    async getCover() {\n        const { exth } = this.headers\n        const offset = exth?.coverOffset < 0xffffffff ? exth?.coverOffset\n            : exth?.thumbnailOffset < 0xffffffff ? exth?.thumbnailOffset : null\n        if (offset != null) {\n            const buf = await this.loadResource(offset)\n            return new Blob([buf])\n        }\n    }\n}\n\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi\nconst fileposRegex = /<[^<>]+filepos=['\"]{0,1}(\\d+)[^<>]*>/gi\n\nconst getIndent = el => {\n    let x = 0\n    while (el) {\n        const parent = el.parentElement\n        if (parent) {\n            const tag = parent.tagName.toLowerCase()\n            if (tag === 'p') x += 1.5\n            else if (tag === 'blockquote') x += 2\n        }\n        el = parent\n    }\n    return x\n}\n\nfunction rawBytesToString(uint8Array) {\n    const chunkSize = 0x8000\n    let result = ''\n    for (let i = 0; i < uint8Array.length; i += chunkSize) {\n        result += String.fromCharCode.apply(null, uint8Array.subarray(i, i + chunkSize))\n    }\n    return result\n}\n\nclass MOBI6 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #resourceCache = new Map()\n    #textCache = new Map()\n    #cache = new Map()\n    #sections\n    #fileposList = []\n    #type = MIME.HTML\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const recordBuffers = []\n        for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++) {\n            const buf = await this.mobi.loadText(i)\n            recordBuffers.push(buf)\n        }\n        const totalLength = recordBuffers.reduce((sum, buf) => sum + buf.byteLength, 0)\n        // load all text records in an array\n        const array = new Uint8Array(totalLength)\n        recordBuffers.reduce((offset, buf) => {\n            array.set(new Uint8Array(buf), offset)\n            return offset + buf.byteLength\n        }, 0)\n        // convert to string so we can use regex\n        // note that `filepos` are byte offsets\n        // so it needs to preserve each byte as a separate character\n        // (see https://stackoverflow.com/q/50198017)\n        const str = rawBytesToString(array)\n\n        // split content into sections at each `<mbp:pagebreak>`\n        this.#sections = [0]\n            .concat(Array.from(str.matchAll(mbpPagebreakRegex), m => m.index))\n            .map((start, i, a) => {\n                const end = a[i + 1] ?? array.length\n                return { book: this, raw: array.subarray(start, end) }\n            })\n            // get start and end filepos for each section\n            .map((section, i, arr) => {\n                section.start = arr[i - 1]?.end ?? 0\n                section.end = section.start + section.raw.byteLength\n                return section\n            })\n\n        this.sections = this.#sections.map((section, index) => ({\n            id: index,\n            load: () => this.loadSection(section),\n            createDocument: () => this.createDocument(section),\n            size: section.end - section.start,\n        }))\n\n        try {\n            this.landmarks = await this.getGuide()\n            const tocHref = this.landmarks\n                .find(({ type }) => type?.includes('toc'))?.href\n            if (tocHref) {\n                const { index } = this.resolveHref(tocHref)\n                const doc = await this.sections[index].createDocument()\n                let lastItem\n                let lastLevel = 0\n                let lastIndent = 0\n                const lastLevelOfIndent = new Map()\n                const lastParentOfLevel = new Map()\n                this.toc = Array.from(doc.querySelectorAll('a[filepos]'))\n                    .reduce((arr, a) => {\n                        const indent = getIndent(a)\n                        const item = {\n                            label: a.innerText?.trim() ?? '',\n                            href: `filepos:${a.getAttribute('filepos')}`,\n                        }\n                        const level = indent > lastIndent ? lastLevel + 1\n                            : indent === lastIndent ? lastLevel\n                            : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1)\n                        if (level > lastLevel) {\n                            if (lastItem) {\n                                lastItem.subitems ??= []\n                                lastItem.subitems.push(item)\n                                lastParentOfLevel.set(level, lastItem)\n                            }\n                            else arr.push(item)\n                        }\n                        else {\n                            const parent = lastParentOfLevel.get(level)\n                            if (parent) parent.subitems.push(item)\n                            else arr.push(item)\n                        }\n                        lastItem = item\n                        lastLevel = level\n                        lastIndent = indent\n                        lastLevelOfIndent.set(indent, level)\n                        return arr\n                    }, [])\n            }\n        } catch(e) {\n            console.warn(e)\n        }\n\n        // get list of all `filepos` references in the book,\n        // which will be used to insert anchor elements\n        // because only then can they be referenced in the DOM\n        this.#fileposList = [...new Set(\n            Array.from(str.matchAll(fileposRegex), m => m[1]))]\n            .map(filepos => ({ filepos, number: Number(filepos) }))\n            .sort((a, b) => a.number - b.number)\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    async getGuide() {\n        const doc = await this.createDocument(this.#sections[0])\n        return Array.from(doc.getElementsByTagName('reference'), ref => ({\n            label: ref.getAttribute('title'),\n            type: ref.getAttribute('type')?.split(/\\s/),\n            href: `filepos:${ref.getAttribute('filepos')}`,\n        }))\n    }\n    async loadResource(index) {\n        if (this.#resourceCache.has(index)) return this.#resourceCache.get(index)\n        const raw = await this.mobi.loadResource(index)\n        const url = URL.createObjectURL(new Blob([raw]))\n        this.#resourceCache.set(index, url)\n        return url\n    }\n    async loadRecindex(recindex) {\n        return this.loadResource(Number(recindex) - 1)\n    }\n    async replaceResources(doc) {\n        for (const img of doc.querySelectorAll('img[recindex]')) {\n            const recindex = img.getAttribute('recindex')\n            try {\n                img.src = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load image ${recindex}`)\n            }\n        }\n        for (const media of doc.querySelectorAll('[mediarecindex]')) {\n            const mediarecindex = media.getAttribute('mediarecindex')\n            const recindex = media.getAttribute('recindex')\n            try {\n                media.src = await this.loadRecindex(mediarecindex)\n                if (recindex) media.poster = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load media ${mediarecindex}`)\n            }\n        }\n        for (const a of doc.querySelectorAll('[filepos]')) {\n            const filepos = a.getAttribute('filepos')\n            a.href = `filepos:${filepos}`\n        }\n    }\n    async loadText(section) {\n        if (this.#textCache.has(section)) return this.#textCache.get(section)\n        const { raw } = section\n\n        // insert anchor elements for each `filepos`\n        const fileposList = this.#fileposList\n            .filter(({ number }) => number >= section.start && number < section.end)\n            .map(obj => ({ ...obj, offset: obj.number - section.start }))\n        let arr = raw\n        if (fileposList.length) {\n            arr = raw.subarray(0, fileposList[0].offset)\n            fileposList.forEach(({ filepos, offset }, i) => {\n                const next = fileposList[i + 1]\n                const a = this.mobi.encode(`<a id=\"filepos${filepos}\"></a>`)\n                arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset))\n            })\n        }\n        const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, '')\n        this.#textCache.set(section, str)\n        return str\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const doc = await this.createDocument(section)\n\n        // inject default stylesheet\n        const style = doc.createElement('style')\n        doc.head.append(style)\n        // blockquotes in MOBI seem to have only a small left margin by default\n        // many books seem to rely on this, as it's the only way to set margin\n        // (since there's no CSS)\n        style.append(doc.createTextNode(`blockquote {\n            margin-block-start: 0;\n            margin-block-end: 0;\n            margin-inline-start: 1em;\n            margin-inline-end: 0;\n        }`))\n\n        await this.replaceResources(doc)\n        const result = this.serializer.serializeToString(doc)\n        const url = URL.createObjectURL(new Blob([result], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    resolveHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        const anchor = doc => doc.getElementById(`filepos${filepos}`)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        return [index, `filepos${filepos}`]\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n    }\n    isExternal(uri) {\n        return /^(?!blob|filepos)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url)\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\n// handlers for `kindle:` uris\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/\nconst parseResourceURI = str => {\n    const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1)\n    return { resourceType, id: parseInt(id, 32), type }\n}\nconst parsePosURI = str => {\n    const [fid, off] = str.match(kindlePosRegex).slice(1)\n    return { fid: parseInt(fid, 32), off: parseInt(off, 32) }\n}\nconst makePosURI = (fid = 0, off = 0) =>\n    `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, '0')\n    }:off:${off.toString(32).toUpperCase().padStart(10, '0')}`\n\n// `kindle:pos:` links are originally links that contain fragments identifiers\n// so there should exist an element with `id` or `name`\n// otherwise try to find one with an `aid` attribute\nconst getFragmentSelector = str => {\n    const match = str.match(/\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i)\n    if (!match) return\n    const [, attr, value] = match\n    return `[${attr}=\"${CSS.escape(value)}\"]`\n}\n\n// replace asynchronously and sequentially\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nclass KF8 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    transformTarget = new EventTarget()\n    #cache = new Map()\n    #fragmentOffsets = new Map()\n    #fragmentSelectors = new Map()\n    #tables = {}\n    #sections\n    #fullRawLength\n    #rawHead = new Uint8Array()\n    #rawTail = new Uint8Array()\n    #lastLoadedHead = -1\n    #lastLoadedTail = -1\n    #type = MIME.XHTML\n    #inlineMap = new Map()\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n        const { kf8 } = this.mobi.headers\n\n        try {\n            const fdstBuffer = await loadRecord(kf8.fdst)\n            const fdst = getStruct(FDST_HEADER, fdstBuffer)\n            if (fdst.magic !== 'FDST') throw new Error('Missing FDST record')\n            const fdstTable = Array.from({ length: fdst.numEntries },\n                (_, i) => 12 + i * 8)\n                .map(offset => [\n                    getUint(fdstBuffer.slice(offset, offset + 4)),\n                    getUint(fdstBuffer.slice(offset + 4, offset + 8))])\n            this.#tables.fdstTable = fdstTable\n            this.#fullRawLength = fdstTable[fdstTable.length - 1][1]\n        } catch {}\n\n        const skelTable = (await getIndexData(kf8.skel, loadRecord)).table\n            .map(({ name, tagMap }, index) => ({\n                index, name,\n                numFrag: tagMap[1][0],\n                offset: tagMap[6][0],\n                length: tagMap[6][1],\n            }))\n        const fragData = await getIndexData(kf8.frag, loadRecord)\n        const fragTable = fragData.table.map(({ name, tagMap }) => ({\n            insertOffset: parseInt(name),\n            selector: fragData.cncx[tagMap[2][0]],\n            index: tagMap[4][0],\n            offset: tagMap[6][0],\n            length: tagMap[6][1],\n        }))\n        this.#tables.skelTable = skelTable\n        this.#tables.fragTable = fragTable\n\n        this.#sections = skelTable.reduce((arr, skel) => {\n            const last = arr[arr.length - 1]\n            const fragStart = last?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag\n            const frags = fragTable.slice(fragStart, fragEnd)\n            const length = skel.length + frags.map(f => f.length).reduce((a, b) => a + b, 0)\n            const totalLength = (last?.totalLength ?? 0) + length\n            return arr.concat({ skel, frags, fragEnd, length, totalLength })\n        }, [])\n\n        const resources = await this.getResourcesByMagic(['RESC', 'PAGE'])\n        const pageSpreads = new Map()\n        if (resources.RESC) {\n            const buf = await this.mobi.loadRecord(resources.RESC)\n            const str = this.mobi.decode(buf.slice(16)).replace(/\\0/g, '')\n            // the RESC record lacks the root `<package>` element\n            // but seem to be otherwise valid XML\n            const index = str.search(/\\?>/)\n            const xmlStr = `<package>${str.slice(index)}</package>`\n            const opf = this.parser.parseFromString(xmlStr, MIME.XML)\n            for (const $itemref of opf.querySelectorAll('spine > itemref')) {\n                const i = parseInt($itemref.getAttribute('skelid'))\n                pageSpreads.set(i, getPageSpread(\n                    $itemref.getAttribute('properties')?.split(' ') ?? []))\n            }\n        }\n\n        this.sections = this.#sections.map((section, index) =>\n            section.frags.length ? ({\n                id: index,\n                load: () => this.loadSection(section),\n                createDocument: () => this.createDocument(section),\n                size: section.length,\n                pageSpread: pageSpreads.get(index),\n            }) : ({ linear: 'no' }))\n\n        try {\n            const ncx = await this.mobi.getNCX()\n            const map = ({ label, pos, children }) => {\n                const [fid, off] = pos\n                const href = makePosURI(fid, off)\n                const arr = this.#fragmentOffsets.get(fid)\n                if (arr) arr.push(off)\n                else this.#fragmentOffsets.set(fid, [off])\n                return { label: unescapeHTML(label), href, subitems: children?.map(map) }\n            }\n            this.toc = ncx?.map(map)\n            this.landmarks = await this.getGuide()\n        } catch(e) {\n            console.warn(e)\n        }\n\n        const { exth } = this.mobi.headers\n        this.dir = exth.pageProgressionDirection\n        this.rendition = {\n            layout: exth.fixedLayout === 'true' ? 'pre-paginated' : 'reflowable',\n            viewport: Object.fromEntries(exth.originalResolution\n                ?.split('x')?.slice(0, 2)\n                ?.map((x, i) => [i ? 'height' : 'width', x]) ?? []),\n        }\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    // is this really the only way of getting to RESC, PAGE, etc.?\n    async getResourcesByMagic(keys) {\n        const results = {}\n        const start = this.mobi.headers.kf8.resourceStart\n        const end = this.mobi.pdb.numRecords\n        for (let i = start; i < end; i++) {\n            try {\n                const magic = await this.mobi.loadMagic(i)\n                const match = keys.find(key => key === magic)\n                if (match) results[match] = i\n            } catch {}\n        }\n        return results\n    }\n    async getGuide() {\n        const index = this.mobi.headers.kf8.guide\n        if (index < 0xffffffff) {\n            const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n            const { table, cncx } = await getIndexData(index, loadRecord)\n            return table.map(({ name, tagMap }) => ({\n                label: cncx[tagMap[1][0]] ?? '',\n                type: name?.split(/\\s/),\n                href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),\n            }))\n        }\n    }\n    async loadResourceBlob(str) {\n        const { resourceType, id, type } = parseResourceURI(str)\n        const raw = resourceType === 'flow' ? await this.loadFlow(id)\n            : await this.mobi.loadResource(id - 1)\n        const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type)\n            ? await this.replaceResources(this.mobi.decode(raw)) : raw\n        const detail = { data: result, type }\n        const event = new CustomEvent('data', { detail })\n        this.transformTarget.dispatchEvent(event)\n        const newData = await event.detail.data\n        const newType = await event.detail.type\n        const doc = newType === MIME.SVG ? this.parser.parseFromString(newData, newType) : null\n        return [new Blob([newData], { newType }),\n            // SVG wrappers need to be inlined\n            // as browsers don't allow external resources when loading SVG as an image\n            doc?.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')?.length\n                ? doc.documentElement : null]\n    }\n    async loadResource(str) {\n        if (this.#cache.has(str)) return this.#cache.get(str)\n        const [blob, inline] = await this.loadResourceBlob(str)\n        const url = inline ? str : URL.createObjectURL(blob)\n        if (inline) this.#inlineMap.set(url, inline)\n        this.#cache.set(str, url)\n        return url\n    }\n    replaceResources(str) {\n        const regex = new RegExp(kindleResourceRegex, 'g')\n        return replaceSeries(str, regex, this.loadResource.bind(this))\n    }\n    // NOTE: there doesn't seem to be a way to access text randomly?\n    // how to know the decompressed size of the records without decompressing?\n    // 4096 is just the maximum size\n    async loadRaw(start, end) {\n        // here we load either from the front or back until we have reached the\n        // required offsets; at worst you'd have to load half the book at once\n        const distanceHead = end - this.#rawHead.length\n        const distanceEnd = this.#fullRawLength == null ? Infinity\n            : (this.#fullRawLength - this.#rawTail.length) - start\n        // load from the start\n        if (distanceHead < 0 || distanceHead < distanceEnd) {\n            while (this.#rawHead.length < end) {\n                const index = ++this.#lastLoadedHead\n                const data = await this.mobi.loadText(index)\n                this.#rawHead = concatTypedArray(this.#rawHead, data)\n            }\n            return this.#rawHead.slice(start, end)\n        }\n        // load from the end\n        while (this.#fullRawLength - this.#rawTail.length > start) {\n            const index = this.mobi.headers.palmdoc.numTextRecords - 1\n                - (++this.#lastLoadedTail)\n            const data = await this.mobi.loadText(index)\n            this.#rawTail = concatTypedArray(data, this.#rawTail)\n        }\n        const rawTailStart = this.#fullRawLength - this.#rawTail.length\n        return this.#rawTail.slice(start - rawTailStart, end - rawTailStart)\n    }\n    loadFlow(index) {\n        if (index < 0xffffffff)\n            return this.loadRaw(...this.#tables.fdstTable[index])\n    }\n    async loadText(section) {\n        const { skel, frags, length } = section\n        const raw = await this.loadRaw(skel.offset, skel.offset + length)\n        let skeleton = raw.slice(0, skel.length)\n        for (const frag of frags) {\n            const insertOffset = frag.insertOffset - skel.offset\n            const offset = skel.length + frag.offset\n            const fragRaw = raw.slice(offset, offset + frag.length)\n            skeleton = concatTypedArray3(\n                skeleton.slice(0, insertOffset), fragRaw,\n                skeleton.slice(insertOffset))\n\n            const offsets = this.#fragmentOffsets.get(frag.index)\n            if (offsets) for (const offset of offsets) {\n                const str = this.mobi.decode(fragRaw.slice(offset))\n                const selector = getFragmentSelector(str)\n                this.#setFragmentSelector(frag.index, offset, selector)\n            }\n        }\n        return this.mobi.decode(skeleton)\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const str = await this.loadText(section)\n        const replaced = await this.replaceResources(str)\n\n        // by default, type is XHTML; change to HTML if it's not valid XHTML\n        let doc = this.parser.parseFromString(replaced, this.#type)\n        if (doc.querySelector('parsererror') || !doc.documentElement?.namespaceURI) {\n            this.#type = MIME.HTML\n            doc = this.parser.parseFromString(replaced, this.#type)\n        }\n        for (const [url, node] of this.#inlineMap) {\n            for (const el of doc.querySelectorAll(`img[src=\"${url}\"]`))\n                el.replaceWith(node)\n        }\n        const url = URL.createObjectURL(\n            new Blob([this.serializer.serializeToString(doc)], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    getIndexByFID(fid) {\n        return this.#sections.findIndex(section =>\n            section.frags.some(frag => frag.index === fid))\n    }\n    #setFragmentSelector(id, offset, selector) {\n        const map = this.#fragmentSelectors.get(id)\n        if (map) map.set(offset, selector)\n        else {\n            const map = new Map()\n            this.#fragmentSelectors.set(id, map)\n            map.set(offset, selector)\n        }\n    }\n    async resolveHref(href) {\n        const { fid, off } = parsePosURI(href)\n        const index = this.getIndexByFID(fid)\n        if (index < 0) return\n\n        const saved = this.#fragmentSelectors.get(fid)?.get(off)\n        if (saved) return { index, anchor: doc => doc.querySelector(saved) }\n\n        const { skel, frags } = this.#sections[index]\n        const frag = frags.find(frag => frag.index === fid)\n        const offset = skel.offset + skel.length + frag.offset\n        const fragRaw = await this.loadRaw(offset, offset + frag.length)\n        const str = this.mobi.decode(fragRaw.slice(off))\n        const selector = getFragmentSelector(str)\n        this.#setFragmentSelector(fid, off, selector)\n        const anchor = doc => doc.querySelector(selector)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const pos = parsePosURI(href)\n        const index = this.getIndexByFID(pos.fid)\n        return [index, pos]\n    }\n    getTOCFragment(doc, { fid, off }) {\n        const selector = this.#fragmentSelectors.get(fid)?.get(off)\n        return doc.querySelector(selector)\n    }\n    isExternal(uri) {\n        return /^(?!blob|kindle)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n"],"names":[],"mappings":"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"}
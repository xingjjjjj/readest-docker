{"version":3,"sources":["../../../../../../packages/foliate-js/opds.js","../../../../../../apps/readest-app/src/app/opds/utils/opdsUtils.ts","../../../../../../apps/readest-app/src/app/opds/utils/opdsReq.ts","../../../../../../apps/readest-app/src/libs/storage.ts"],"sourcesContent":["const NS = {\n    ATOM: 'http://www.w3.org/2005/Atom',\n    OPDS: 'http://opds-spec.org/2010/catalog',\n    THR: 'http://purl.org/syndication/thread/1.0',\n    DC: 'http://purl.org/dc/elements/1.1/',\n    DCTERMS: 'http://purl.org/dc/terms/',\n}\n\nconst MIME = {\n    ATOM: 'application/atom+xml',\n    OPDS2: 'application/opds+json',\n}\n\nexport const REL = {\n    ACQ: 'http://opds-spec.org/acquisition',\n    FACET: 'http://opds-spec.org/facet',\n    GROUP: 'http://opds-spec.org/group',\n    COVER: [\n        'http://opds-spec.org/image',\n        'http://opds-spec.org/cover',\n    ],\n    THUMBNAIL: [\n        'http://opds-spec.org/image/thumbnail',\n        'http://opds-spec.org/thumbnail',\n    ],\n}\n\nexport const SYMBOL = {\n    SUMMARY: Symbol('summary'),\n    CONTENT: Symbol('content'),\n}\n\nconst FACET_GROUP = Symbol('facetGroup')\n\nconst groupByArray = (arr, f) => {\n    const map = new Map()\n    if (arr) for (const el of arr) {\n        const keys = f(el)\n        for (const key of [keys].flat()) {\n            const group = map.get(key)\n            if (group) group.push(el)\n            else map.set(key, [el])\n        }\n    }\n    return map\n}\n\n// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1\nconst parseMediaType = str => {\n    if (!str) return null\n    const [mediaType, ...ps] = str.split(/ *; */)\n    return {\n        mediaType: mediaType.toLowerCase(),\n        parameters: Object.fromEntries(ps.map(p => {\n            const [name, val] = p.split('=')\n            return [name.toLowerCase(), val?.replace(/(^\"|\"$)/g, '')]\n        })),\n    }\n}\n\nexport const isOPDSCatalog = str => {\n    const parsed = parseMediaType(str)\n    if (!parsed) return false\n    const { mediaType, parameters } = parsed\n    if (mediaType === MIME.OPDS2) return true\n    return mediaType === MIME.ATOM && parameters.profile?.toLowerCase() === 'opds-catalog'\n}\n\nexport const isOPDSSearch = str => {\n    const parsed = parseMediaType(str)\n    if (!parsed) return false\n    const { mediaType } = parsed\n    return mediaType === MIME.ATOM\n}\n\n// ignore the namespace if it doesn't appear in document at all\nconst useNS = (doc, ns) =>\n    doc.lookupNamespaceURI(null) === ns || doc.lookupPrefix(ns) ? ns : null\n\nconst filterNS = ns => ns\n    ? name => el => el.namespaceURI === ns && el.localName === name\n    : name => el => el.localName === name\n\nconst getContent = el => {\n    if (!el) return\n    const type = el.getAttribute('type') ?? 'text'\n    const value = type === 'xhtml' ? el.innerHTML\n        : type === 'html' ? el.textContent\n            .replaceAll('&lt;', '<')\n            .replaceAll('&gt;', '>')\n            .replaceAll('&amp;', '&')\n        : el.textContent\n    return { value, type }\n}\n\nconst getTextContent = el => {\n    const content = getContent(el)\n    if (content?.type === 'text') return content?.value\n}\n\nconst getSummary = (a, b) => getTextContent(a) ?? getTextContent(b)\n\nconst getPrice = link => {\n    const price = link.getElementsByTagNameNS(NS.OPDS, 'price')[0]\n    return price ? {\n        currency: price.getAttribute('currencycode'),\n        value: price.textContent,\n    } : null\n}\n\nconst getIndirectAcquisition = el => {\n    const ia = el.getElementsByTagNameNS(NS.OPDS, 'indirectAcquisition')[0]\n    if (!ia) return []\n    return [{ type: ia.getAttribute('type') }, ...getIndirectAcquisition(ia)]\n}\n\nconst getLink = link => {\n    const obj = {\n        rel: link.getAttribute('rel')?.split(/ +/),\n        href: link.getAttribute('href'),\n        type: link.getAttribute('type'),\n        title: link.getAttribute('title'),\n        properties: {\n            price: getPrice(link),\n            indirectAcquisition: getIndirectAcquisition(link),\n            numberOfItems: link.getAttributeNS(NS.THR, 'count'),\n        },\n        [FACET_GROUP]: link.getAttributeNS(NS.OPDS, 'facetGroup'),\n    }\n    if (link.getAttributeNS(NS.OPDS, 'activeFacet') === 'true')\n        obj.rel = [obj.rel ?? []].flat().concat('self')\n    return obj\n}\n\nconst getPerson = person => {\n    const NS = person.namespaceURI\n    const uri = person.getElementsByTagNameNS(NS, 'uri')[0]?.textContent\n    return {\n        name: person.getElementsByTagNameNS(NS, 'name')[0]?.textContent ?? '',\n        links: uri ? [{ href: uri }] : [],\n    }\n}\n\nexport const getPublication = entry => {\n    const filter = filterNS(useNS(entry.ownerDocument, NS.ATOM))\n    const children = Array.from(entry.children)\n    const filterDCEL = filterNS(NS.DC)\n    const filterDCTERMS = filterNS(NS.DCTERMS)\n    const filterDC = x => {\n        const a = filterDCEL(x), b = filterDCTERMS(x)\n        return y => a(y) || b(y)\n    }\n    const links = children.filter(filter('link')).map(getLink)\n    const linksByRel = groupByArray(links, link => link.rel)\n    return {\n        metadata: {\n            title: children.find(filter('title'))?.textContent ?? '',\n            author: children.filter(filter('author')).map(getPerson),\n            contributor: children.filter(filter('contributor')).map(getPerson),\n            publisher: children.find(filterDC('publisher'))?.textContent,\n            published: (children.find(filterDCTERMS('issued'))\n                ?? children.find(filterDC('date')))?.textContent,\n            language: children.find(filterDC('language'))?.textContent,\n            identifier: children.find(filterDC('identifier'))?.textContent,\n            subject: children.filter(filter('category')).map(category => ({\n                name: category.getAttribute('label'),\n                code: category.getAttribute('term'),\n                scheme: category.getAttribute('scheme'),\n            })),\n            rights: children.find(filter('rights'))?.textContent ?? '',\n            [SYMBOL.CONTENT]: getContent(children.find(filter('content'))\n                ?? children.find(filter('summary'))),\n        },\n        links,\n        images: REL.COVER.concat(REL.THUMBNAIL)\n            .map(R => linksByRel.get(R)?.[0]).filter(x => x),\n    }\n}\n\nexport const getFeed = doc => {\n    const ns = useNS(doc, NS.ATOM)\n    const filter = filterNS(ns)\n    const children = Array.from(doc.documentElement.children)\n    const entries = children.filter(filter('entry'))\n    const links = children.filter(filter('link')).map(getLink)\n    const linksByRel = groupByArray(links, link => link.rel)\n\n    const groupedItems = new Map([[null, []]])\n    const groupLinkMap = new Map()\n    for (const entry of entries) {\n        const children = Array.from(entry.children)\n        const links = children.filter(filter('link')).map(getLink)\n        const linksByRel = groupByArray(links, link => link.rel)\n        const isPub = [...linksByRel.keys()]\n            .some(rel => rel?.startsWith(REL.ACQ) || rel === 'preview')\n\n        const groupLinks = linksByRel.get(REL.GROUP) ?? linksByRel.get('collection')\n        const groupLink = groupLinks?.length\n            ? groupLinks.find(link => groupedItems.has(link.href)) ?? groupLinks[0] : null\n        if (groupLink && !groupLinkMap.has(groupLink.href))\n            groupLinkMap.set(groupLink.href, groupLink)\n\n        const item = isPub\n            ? getPublication(entry)\n            : Object.assign(links.find(link => isOPDSCatalog(link.type)) ?? links[0] ?? {}, {\n                title: children.find(filter('title'))?.textContent,\n                [SYMBOL.SUMMARY]: getSummary(children.find(filter('summary')),\n                    children.find(filter('content'))),\n            })\n\n        const arr = groupedItems.get(groupLink?.href ?? null)\n        if (arr) arr.push(item)\n        else groupedItems.set(groupLink.href, [item])\n    }\n    const [items, ...groups] = Array.from(groupedItems, ([key, items]) => {\n        const itemsKey = items[0]?.metadata ? 'publications' : 'navigation'\n        if (key == null) return { [itemsKey]: items }\n        const link = groupLinkMap.get(key)\n        return {\n            metadata: {\n                title: link.title,\n                numberOfItems: link.properties.numberOfItems,\n            },\n            links: [{ rel: 'self', href: link.href, type: link.type }],\n            [itemsKey]: items,\n        }\n    })\n    return {\n        metadata: {\n            title: children.find(filter('title'))?.textContent,\n            subtitle: children.find(filter('subtitle'))?.textContent,\n        },\n        links,\n        ...items,\n        groups,\n        facets: Array.from(\n            groupByArray(linksByRel.get(REL.FACET) ?? [], link => link[FACET_GROUP]),\n            ([facet, links]) => ({ metadata: { title: facet }, links })),\n    }\n}\n\nexport const getSearch = async link => {\n    const { replace, getVariables } = await import('./uri-template.js')\n    return {\n        metadata: {\n            title: link.title,\n        },\n        search: map => replace(link.href, map.get(null)),\n        params: Array.from(getVariables(link.href), name => ({ name })),\n    }\n}\n\nexport const getOpenSearch = doc => {\n    const defaultNS = doc.documentElement.namespaceURI\n    const filter = filterNS(defaultNS)\n    const children = Array.from(doc.documentElement.children)\n\n    const $$urls = children.filter(filter('Url'))\n    const $url = $$urls.find(url => isOPDSCatalog(url.getAttribute('type'))) ?? $$urls.find(url => isOPDSSearch(url.getAttribute('type'))) ?? $$urls[0]\n    if (!$url) throw new Error('document must contain at least one Url element')\n\n    const regex = /{(?:([^}]+?):)?(.+?)(\\?)?}/g\n    const defaultMap = new Map([\n        ['count', '100'],\n        ['startIndex', $url.getAttribute('indexOffset') ?? '0'],\n        ['startPage', $url.getAttribute('pageOffset') ?? '0'],\n        ['language', '*'],\n        ['inputEncoding', 'UTF-8'],\n        ['outputEncoding', 'UTF-8'],\n    ])\n\n    const template = $url.getAttribute('template')\n    return {\n        metadata: {\n            title: (children.find(filter('LongName')) ?? children.find(filter('ShortName')))?.textContent,\n            description: children.find(filter('Description'))?.textContent,\n        },\n        search: map => template.replace(regex, (_, prefix, param) => {\n            const namespace = prefix ? $url.lookupNamespaceURI(prefix) : null\n            const ns = namespace === defaultNS ? null : namespace\n            const val = map.get(ns)?.get(param)\n            return encodeURIComponent(val ? val : (!ns ? defaultMap.get(param) ?? '' : ''))\n        }),\n        params: Array.from(template.matchAll(regex), ([, prefix, param, optional]) => {\n            const namespace = prefix ? $url.lookupNamespaceURI(prefix) : null\n            const ns = namespace === defaultNS ? null : namespace\n            return {\n                ns, name: param,\n                required: !optional,\n                value: ns && ns !== defaultNS ? '' : defaultMap.get(param) ?? '',\n            }\n        }),\n    }\n}\n","import { isOPDSCatalog } from 'foliate-js/opds.js';\nimport { OPDSLink } from '@/types/opds';\nimport { EXTS } from '@/libs/document';\nimport { fetchWithAuth } from './opdsReq';\n\nexport const groupByArray = <T, K>(arr: T[] | undefined, f: (el: T) => K | K[]): Map<K, T[]> => {\n  const map = new Map<K, T[]>();\n  if (arr) {\n    for (const el of arr) {\n      const keys = f(el);\n      for (const key of [keys].flat()) {\n        const group = map.get(key as K);\n        if (group) group.push(el);\n        else map.set(key as K, [el]);\n      }\n    }\n  }\n  return map;\n};\n\nexport const MIME = {\n  XML: 'application/xml',\n  ATOM: 'application/atom+xml',\n  XHTML: 'application/xhtml+xml',\n  HTML: 'text/html',\n  EPUB: 'application/epub+zip',\n  PDF: 'application/pdf',\n  OPENSEARCH: 'application/opensearchdescription+xml',\n};\n\nexport const enum VALIDATION_ERROR {\n  INVALID_URL = 'Invalid URL format',\n  LOAD_FAILED = 'Failed to load OPDS feed',\n  NOT_OPDS = 'Invalid OPDS feed URL',\n  NO_OPDS_LINK = 'Document has no link to OPDS feeds',\n  NO_HREF = 'OPDS link has no href attribute',\n  INVALID_HTML = 'Invalid HTML document',\n  INVALID_CONTENT = 'Content is neither valid XML nor JSON',\n}\n\ninterface ValidationResult {\n  isValid: boolean;\n  error?: VALIDATION_ERROR | string;\n  data?: {\n    type: 'feed' | 'entry' | 'opensearch' | 'html';\n    doc: Document;\n    text: string;\n    responseURL: string;\n  };\n}\n\nexport const parseMediaType = (str?: string) => {\n  if (!str) return null;\n  const [mediaType, ...ps] = str.split(/ *; */);\n  if (!mediaType) return null;\n\n  return {\n    mediaType: mediaType.toLowerCase(),\n    parameters: Object.fromEntries(\n      ps\n        .map((p) => {\n          const [name, val] = p.split('=');\n          if (!name) return null;\n          return [name.toLowerCase(), val?.replace(/(^\"|\"$)/g, '')];\n        })\n        .filter((entry): entry is [string, string] => entry !== null),\n    ),\n  };\n};\n\nexport const isSearchLink = (link: OPDSLink): boolean => {\n  const rels = Array.isArray(link.rel) ? link.rel : [link.rel || ''];\n  return rels.includes('search') && (link.type === MIME.OPENSEARCH || link.type === MIME.ATOM);\n};\n\nexport const resolveURL = (url: string, relativeTo: string): string => {\n  if (!url) return '';\n  if (relativeTo.includes('/api/opds/proxy?url=')) {\n    const params = new URLSearchParams(relativeTo.split('?')[1]);\n    const proxiedURL = params.get('url') || '';\n    return resolveURL(url, proxiedURL);\n  }\n  try {\n    if (relativeTo.includes(':')) return new URL(url, relativeTo).toString();\n    const root = 'https://invalid.invalid/';\n    const obj = new URL(url, root + relativeTo);\n    obj.search = '';\n    return decodeURI(obj.href.replace(root, ''));\n  } catch (e) {\n    console.warn(e);\n    return url;\n  }\n};\n\nexport const validateOPDSURL = async (\n  url: string,\n  username?: string,\n  password?: string,\n  useProxy = false,\n): Promise<ValidationResult> => {\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 10000);\n    const res = await fetchWithAuth(url, username, password, useProxy, {\n      signal: controller.signal,\n    });\n    clearTimeout(timeout);\n\n    if (!res.ok) {\n      if (res.status === 401) {\n        return {\n          isValid: false,\n          error: 'Authentication required. Please check your username and password.',\n        };\n      }\n      return {\n        isValid: false,\n        error: `Failed to load OPDS feed: ${res.status} ${res.statusText}`,\n      };\n    }\n\n    const responseURL = res.url;\n    const text = await res.text();\n\n    // Check if it's XML-based OPDS\n    if (text.startsWith('<')) {\n      const doc = new DOMParser().parseFromString(text, MIME.XML as DOMParserSupportedType);\n      const {\n        documentElement: { localName },\n      } = doc;\n\n      if (localName === 'feed') {\n        return {\n          isValid: true,\n          data: { type: 'feed', doc, text, responseURL },\n        };\n      } else if (localName === 'entry') {\n        return {\n          isValid: true,\n          data: { type: 'entry', doc, text, responseURL },\n        };\n      } else if (localName === 'OpenSearchDescription') {\n        return {\n          isValid: true,\n          data: { type: 'opensearch', doc, text, responseURL },\n        };\n      } else {\n        // Check for HTML with OPDS link\n        const contentType = res.headers.get('Content-Type') ?? MIME.HTML;\n        const type = parseMediaType(contentType)?.mediaType ?? MIME.HTML;\n        const htmlDoc = new DOMParser().parseFromString(text, type as DOMParserSupportedType);\n\n        if (!htmlDoc.head) {\n          return {\n            isValid: false,\n            error: VALIDATION_ERROR.NOT_OPDS,\n          };\n        }\n\n        const link = Array.from(htmlDoc.head.querySelectorAll('link')).find((link) =>\n          isOPDSCatalog(link.getAttribute('type') ?? ''),\n        );\n\n        if (!link) {\n          return {\n            isValid: false,\n            error: VALIDATION_ERROR.NOT_OPDS,\n          };\n        }\n\n        const href = link.getAttribute('href');\n        if (!href) {\n          return {\n            isValid: false,\n            error: 'OPDS link has no href attribute',\n          };\n        }\n\n        return {\n          isValid: true,\n          data: { type: 'html', doc: htmlDoc, text, responseURL },\n        };\n      }\n    } else {\n      // Check if it's JSON-based OPDS\n      try {\n        const feed = JSON.parse(text);\n        // Basic validation for OPDS JSON feed\n        if (!feed.metadata && !feed.links && !feed.publications && !feed.navigation) {\n          return {\n            isValid: false,\n            error: VALIDATION_ERROR.NOT_OPDS,\n          };\n        }\n        return {\n          isValid: true,\n          data: {\n            type: 'feed',\n            doc: new Document(),\n            text,\n            responseURL,\n          },\n        };\n      } catch {\n        return {\n          isValid: false,\n          error: VALIDATION_ERROR.NOT_OPDS,\n        };\n      }\n    }\n  } catch (e) {\n    console.error('OPDS validation error:', e);\n    return {\n      isValid: false,\n      error: e instanceof Error ? e.message : VALIDATION_ERROR.NOT_OPDS,\n    };\n  }\n};\n\nexport const getFileExtFromPath = (pathname: string, delimiter = '/'): string => {\n  const parts = pathname.split(delimiter);\n  for (const ext of Object.values(EXTS)) {\n    if (parts.includes(ext)) {\n      return ext;\n    }\n  }\n  return '';\n};\n","import { md5 } from 'js-md5';\nimport {\n  getAPIBaseUrl,\n  getNodeAPIBaseUrl,\n  isTauriAppPlatform,\n  isWebAppPlatform,\n} from '@/services/environment';\nimport { fetch as tauriFetch } from '@tauri-apps/plugin-http';\nimport { READEST_OPDS_USER_AGENT } from '@/services/constants';\n\nconst OPDS_PROXY_URL = `${getAPIBaseUrl()}/opds/proxy`;\nconst NODE_OPDS_PROXY_URL = `${getNodeAPIBaseUrl()}/opds/proxy`;\n/**\n * Extract username and password from URL credentials\n */\nconst extractCredentialsFromURL = (\n  url: string,\n): { url: string; username?: string; password?: string } => {\n  try {\n    const urlObj = new URL(url);\n    const username = decodeURIComponent(urlObj.username) || undefined;\n    const password = decodeURIComponent(urlObj.password) || undefined;\n\n    if (username || password) {\n      urlObj.username = '';\n      urlObj.password = '';\n      return {\n        url: urlObj.toString(),\n        username,\n        password,\n      };\n    }\n  } catch (e) {\n    console.warn('Failed to parse URL:', e);\n  }\n\n  return { url };\n};\n\nexport const needsProxy = (url: string): boolean => {\n  return isWebAppPlatform() && url.startsWith('http');\n};\n\nconst PROXY_OVERRIDES: Record<string, string> = {\n  standardebooks: NODE_OPDS_PROXY_URL,\n};\n\nconst getProxyBaseUrl = (url: string): string => {\n  for (const [domain, proxyUrl] of Object.entries(PROXY_OVERRIDES)) {\n    if (url.includes(domain)) {\n      return proxyUrl;\n    }\n  }\n  return OPDS_PROXY_URL;\n};\n\n/**\n * Generate proxied URL for OPDS requests\n */\nexport const getProxiedURL = (url: string, auth: string = '', stream = false): string => {\n  if (url.startsWith('http')) {\n    const { url: cleanUrl } = extractCredentialsFromURL(url);\n    const params = new URLSearchParams();\n    params.append('url', cleanUrl);\n    params.append('stream', `${stream}`);\n    if (auth) {\n      params.append('auth', auth);\n    }\n    const baseUrl = getProxyBaseUrl(url);\n    const proxyUrl = `${baseUrl}?${params.toString()}`;\n    return proxyUrl;\n  }\n  return url;\n};\n\n/**\n * Parse Digest authentication challenge from WWW-Authenticate header\n */\nconst parseDigestChallenge = (challenge: string): Record<string, string> => {\n  const params: Record<string, string> = {};\n  const regex = /(\\w+)=[\"']?([^\"',]+)[\"']?/g;\n  let match;\n\n  while ((match = regex.exec(challenge)) !== null) {\n    params[match[1]!] = match[2]!;\n  }\n\n  return params;\n};\n\n/**\n * Generate Digest authentication response hash\n */\nconst generateDigestResponse = (\n  username: string,\n  password: string,\n  params: Record<string, string>,\n  method: string,\n  uri: string,\n  nc: string,\n  cnonce: string,\n) => {\n  const realm = params['realm'];\n  const nonce = params['nonce'];\n  const qop = params['qop'];\n  const algorithm = params['algorithm'];\n\n  let ha1 = md5(`${username}:${realm}:${password}`);\n\n  if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\n    ha1 = md5(`${ha1}:${nonce}:${cnonce}`);\n  }\n\n  const ha2 = md5(`${method}:${uri}`);\n\n  let response: string;\n\n  if (qop) {\n    response = md5(`${ha1}:${nonce}:${nc}:${cnonce}:${qop}:${ha2}`);\n  } else {\n    response = md5(`${ha1}:${nonce}:${ha2}`);\n  }\n\n  return response;\n};\n\n/**\n * Create Digest Authorization header\n */\nexport const createDigestAuth = async (\n  username: string,\n  password: string,\n  wwwAuthenticate: string,\n  method: string,\n  uri: string,\n): Promise<string> => {\n  const params = parseDigestChallenge(wwwAuthenticate);\n  const cnonce = Math.random().toString(36).slice(2);\n  const nc = '00000001';\n  const response = await generateDigestResponse(\n    username,\n    password,\n    params,\n    method,\n    uri,\n    nc,\n    cnonce,\n  );\n\n  const parts = [\n    `username=\"${username}\"`,\n    `realm=\"${params['realm']}\"`,\n    `nonce=\"${params['nonce']}\"`,\n    `uri=\"${uri}\"`,\n    `response=\"${response}\"`,\n  ];\n\n  if (params['algorithm']) {\n    parts.push(`algorithm=\"${params['algorithm']}\"`);\n  }\n\n  if (params['opaque']) {\n    parts.push(`opaque=\"${params['opaque']}\"`);\n  }\n\n  if (params['qop']) {\n    parts.push(`qop=\"auth\"`);\n    parts.push(`nc=${nc}`);\n    parts.push(`cnonce=\"${cnonce}\"`);\n  }\n\n  return `Digest ${parts.join(', ')}`;\n};\n\n/**\n * Create Basic Authorization header\n */\nexport const createBasicAuth = (username: string, password: string): string => {\n  const credentials = btoa(`${username}:${password}`);\n  return `Basic ${credentials}`;\n};\n\n/**\n * Probe URL for authentication requirements using HEAD request\n * Returns auth header if authentication is needed, null otherwise\n */\nexport const probeAuth = async (\n  url: string,\n  username?: string,\n  password?: string,\n  useProxy = false,\n): Promise<string | null> => {\n  const {\n    url: cleanUrl,\n    username: urlUsername,\n    password: urlPassword,\n  } = extractCredentialsFromURL(url);\n\n  const finalUsername = username || urlUsername;\n  const finalPassword = password || urlPassword;\n\n  // No credentials provided, can't generate auth header\n  if (!finalUsername || !finalPassword) {\n    return null;\n  }\n\n  const fetchURL = useProxy ? getProxiedURL(cleanUrl) : cleanUrl;\n  const headers: Record<string, string> = {\n    'User-Agent': READEST_OPDS_USER_AGENT,\n    Accept: 'application/atom+xml, application/xml, text/xml, */*',\n  };\n\n  // Probe with HEAD request\n  const fetch = isTauriAppPlatform() ? tauriFetch : window.fetch;\n  const res = await fetch(fetchURL, {\n    method: 'HEAD',\n    headers,\n    danger: { acceptInvalidCerts: true, acceptInvalidHostnames: true },\n  });\n\n  // Check if authentication is required\n  if (res.status === 401 || res.status === 403) {\n    const wwwAuthenticate = res.headers.get('WWW-Authenticate');\n    if (wwwAuthenticate) {\n      if (wwwAuthenticate.toLowerCase().startsWith('digest')) {\n        const urlObj = new URL(cleanUrl);\n        return await createDigestAuth(\n          finalUsername,\n          finalPassword,\n          wwwAuthenticate,\n          'GET',\n          urlObj.pathname + urlObj.search,\n        );\n      } else if (wwwAuthenticate.toLowerCase().startsWith('basic')) {\n        return createBasicAuth(finalUsername, finalPassword);\n      }\n    } else {\n      // Fallback to Basic auth if no WWW-Authenticate header\n      // some older Calibre-Web versions behave this way, see issue #2656\n      return createBasicAuth(finalUsername, finalPassword);\n    }\n  }\n\n  // Komga returns 200 even if requires auth, so we return Basic auth header in this case\n  return createBasicAuth(finalUsername, finalPassword);\n};\n\nexport const probeFilename = async (headers: Record<string, string>) => {\n  const contentDisposition = headers['content-disposition'];\n  if (contentDisposition) {\n    const extendedMatch = contentDisposition.match(\n      /filename\\*\\s*=\\s*(?:utf-8|UTF-8)'[^']*'([^;\\s]+)/i,\n    );\n    if (extendedMatch?.[1]) {\n      return decodeURIComponent(extendedMatch[1]);\n    }\n\n    const plainMatch = contentDisposition.match(/filename\\s*=\\s*[\"']?([^\"';\\s]+)[\"']?/i);\n    if (plainMatch?.[1]) {\n      return decodeURIComponent(plainMatch[1]);\n    }\n  }\n\n  return '';\n};\n\n/**\n * Perform authenticated HTTP request with retry logic for Digest/Basic auth\n */\nexport const fetchWithAuth = async (\n  url: string,\n  username?: string,\n  password?: string,\n  useProxy = false,\n  options: RequestInit = {},\n): Promise<Response> => {\n  const {\n    url: cleanUrl,\n    username: urlUsername,\n    password: urlPassword,\n  } = extractCredentialsFromURL(url);\n\n  const finalUsername = username || urlUsername;\n  const finalPassword = password || urlPassword;\n\n  const fetchURL = useProxy ? getProxiedURL(cleanUrl) : cleanUrl;\n  const headers: Record<string, string> = {\n    'User-Agent': READEST_OPDS_USER_AGENT,\n    Accept: 'application/atom+xml, application/xml, text/xml, */*',\n    ...(options.headers as Record<string, string>),\n  };\n\n  const fetch = isTauriAppPlatform() ? tauriFetch : window.fetch;\n  let res = await fetch(fetchURL, {\n    ...options,\n    method: options.method || 'GET',\n    headers,\n    danger: { acceptInvalidCerts: true, acceptInvalidHostnames: true },\n  });\n\n  // Handle authentication if needed\n  if (!res.ok && (res.status === 401 || res.status === 403) && finalUsername && finalPassword) {\n    const wwwAuthenticate = res.headers.get('WWW-Authenticate');\n    if (wwwAuthenticate) {\n      let authHeader: string | null = null;\n\n      if (wwwAuthenticate.toLowerCase().startsWith('digest')) {\n        const urlObj = new URL(cleanUrl);\n        authHeader = await createDigestAuth(\n          finalUsername,\n          finalPassword,\n          wwwAuthenticate,\n          options.method || 'GET',\n          urlObj.pathname + urlObj.search,\n        );\n      } else if (wwwAuthenticate.toLowerCase().startsWith('basic')) {\n        authHeader = createBasicAuth(finalUsername, finalPassword);\n      }\n\n      if (authHeader) {\n        const finalUrl = useProxy ? `${fetchURL}&auth=${encodeURIComponent(authHeader)}` : fetchURL;\n        res = await fetch(finalUrl, {\n          ...options,\n          method: options.method || 'GET',\n          headers: useProxy ? headers : { ...headers, Authorization: authHeader },\n          danger: { acceptInvalidCerts: true, acceptInvalidHostnames: true },\n        });\n      }\n    }\n  }\n\n  return res;\n};\n","import { getAPIBaseUrl, isWebAppPlatform } from '@/services/environment';\nimport { AppService } from '@/types/system';\nimport { getUserID } from '@/utils/access';\nimport { fetchWithAuth } from '@/utils/fetch';\nimport {\n  tauriUpload,\n  tauriDownload,\n  webUpload,\n  webDownload,\n  ProgressHandler,\n  ProgressPayload,\n} from '@/utils/transfer';\n\nconst STORAGE_MODE = process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote';\nconst isLocalStorageMode = STORAGE_MODE === 'local';\n\nconst API_ENDPOINTS = {\n  upload: getAPIBaseUrl() + '/storage/upload',\n  download: getAPIBaseUrl() + '/storage/download',\n  delete: getAPIBaseUrl() + '/storage/delete',\n  stats: getAPIBaseUrl() + '/storage/stats',\n  list: getAPIBaseUrl() + '/storage/list',\n  purge: getAPIBaseUrl() + '/storage/purge',\n  scan: getAPIBaseUrl() + '/storage/scan',\n  import: getAPIBaseUrl() + '/storage/import',\n};\n\nexport const createProgressHandler = (\n  totalFiles: number,\n  completedFilesRef: { count: number },\n  onProgress?: ProgressHandler,\n) => {\n  return (progress: ProgressPayload) => {\n    const fileProgress = progress.progress / progress.total;\n    const overallProgress = ((completedFilesRef.count + fileProgress) / totalFiles) * 100;\n\n    if (onProgress) {\n      onProgress({\n        progress: overallProgress,\n        total: 100,\n        transferSpeed: progress.transferSpeed,\n      });\n    }\n  };\n};\n\nconst request = async (url: string, options: RequestInit) => {\n  if (!isLocalStorageMode) {\n    return fetchWithAuth(url, options);\n  }\n\n  const res = await fetch(url, options);\n  if (!res.ok) {\n    let message = res.statusText;\n    try {\n      const data = await res.json();\n      message = data.error || message;\n    } catch { }\n    throw new Error(message || 'Request failed');\n  }\n  return res;\n};\n\nconst buildFileKey = async (cfp: string) => {\n  if (isLocalStorageMode) return cfp;\n  const userId = await getUserID();\n  if (!userId) {\n    throw new Error('Not authenticated');\n  }\n  return `${userId}/${cfp}`;\n};\n\nexport const uploadFile = async (\n  file: File,\n  fileFullPath: string,\n  onProgress?: ProgressHandler,\n  bookHash?: string,\n  temp = false,\n  cloudFilePath?: string,\n) => {\n  try {\n    const response = await request(API_ENDPOINTS.upload, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        fileName: file.name,\n        fileSize: file.size,\n        bookHash,\n        temp,\n        cloudPath: cloudFilePath,\n      }),\n    });\n\n    const { uploadUrl, downloadUrl }: { uploadUrl: string; downloadUrl?: string } =\n      await response.json();\n    if (isWebAppPlatform()) {\n      await webUpload(file, uploadUrl, onProgress);\n    } else {\n      await tauriUpload(uploadUrl, fileFullPath, 'PUT', onProgress);\n    }\n    return temp ? downloadUrl : undefined;\n  } catch (error) {\n    console.error('File upload failed:', error);\n    if (error instanceof Error) {\n      throw error;\n    }\n    throw new Error('File upload failed');\n  }\n};\n\nexport const batchGetDownloadUrls = async (files: { lfp: string; cfp: string }[]) => {\n  try {\n    const userId = isLocalStorageMode ? null : await getUserID();\n    if (!isLocalStorageMode && !userId) {\n      throw new Error('Not authenticated');\n    }\n    const filePaths = files.map((file) => file.cfp);\n    const fileKeys = filePaths.map((path) => (isLocalStorageMode ? path : `${userId}/${path}`));\n    const response = await request(`${API_ENDPOINTS.download}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fileKeys }),\n    });\n\n    const { downloadUrls } = await response.json();\n    return files.map((file) => {\n      const fileKey = isLocalStorageMode ? file.cfp : `${userId}/${file.cfp}`;\n      return {\n        lfp: file.lfp,\n        cfp: file.cfp,\n        downloadUrl: downloadUrls[fileKey],\n      };\n    });\n  } catch (error) {\n    console.error('Batch get download URLs failed:', error);\n    throw new Error('Batch get download URLs failed');\n  }\n};\n\ntype DownloadFileParams = {\n  appService: AppService;\n  dst: string;\n  cfp: string;\n  url?: string;\n  headers?: Record<string, string>;\n  singleThreaded?: boolean;\n  skipSslVerification?: boolean;\n  onProgress?: ProgressHandler;\n};\n\nexport const downloadFile = async ({\n  appService,\n  dst,\n  cfp,\n  url,\n  headers,\n  singleThreaded,\n  skipSslVerification,\n  onProgress,\n}: DownloadFileParams) => {\n  try {\n    let downloadUrl = url;\n    if (!downloadUrl) {\n      const fileKey = await buildFileKey(cfp);\n      const response = await request(\n        `${API_ENDPOINTS.download}?fileKey=${encodeURIComponent(fileKey)}`,\n        {\n          method: 'GET',\n        },\n      );\n\n      const { downloadUrl: url } = await response.json();\n      downloadUrl = url;\n    }\n\n    if (!downloadUrl) {\n      throw new Error('No download URL available');\n    }\n\n    if (isWebAppPlatform()) {\n      const { headers: responseHeaders, blob } = await webDownload(\n        downloadUrl,\n        onProgress,\n        headers,\n      );\n      await appService.writeFile(dst, 'None', await blob.arrayBuffer());\n      return responseHeaders;\n    } else {\n      return await tauriDownload(\n        downloadUrl,\n        dst,\n        onProgress,\n        headers,\n        undefined,\n        singleThreaded,\n        skipSslVerification,\n      );\n    }\n  } catch (error) {\n    console.error(`File '${dst}' download failed:`, error);\n    throw error;\n  }\n};\n\nexport const deleteFile = async (filePath: string) => {\n  try {\n    const fileKey = await buildFileKey(filePath);\n    await request(`${API_ENDPOINTS.delete}?fileKey=${encodeURIComponent(fileKey)}`, {\n      method: 'DELETE',\n    });\n  } catch (error) {\n    console.error('File deletion failed:', error);\n    throw new Error('File deletion failed');\n  }\n};\n\nexport interface StorageStats {\n  totalFiles: number;\n  totalSize: number;\n  usage: number;\n  quota: number;\n  usagePercentage: number;\n  byBookHash: Array<{\n    bookHash: string | null;\n    fileCount: number;\n    totalSize: number;\n  }>;\n}\n\nexport const getStorageStats = async (): Promise<StorageStats> => {\n  try {\n    const response = await request(API_ENDPOINTS.stats, {\n      method: 'GET',\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('Get storage stats failed:', error);\n    throw new Error('Get storage stats failed');\n  }\n};\n\nexport interface FileRecord {\n  file_key: string;\n  file_size: number;\n  book_hash: string | null;\n  created_at: string;\n  updated_at: string | null;\n}\n\nexport interface ListFilesParams {\n  page?: number;\n  pageSize?: number;\n  sortBy?: 'created_at' | 'updated_at' | 'file_size' | 'file_key';\n  sortOrder?: 'asc' | 'desc';\n  bookHash?: string;\n  search?: string;\n}\n\ninterface ListFilesResponse {\n  files: FileRecord[];\n  total: number;\n  page: number;\n  pageSize: number;\n  totalPages: number;\n}\n\nexport const listFiles = async (params?: ListFilesParams): Promise<ListFilesResponse> => {\n  try {\n    const queryParams = new URLSearchParams();\n\n    if (params?.page) queryParams.set('page', params.page.toString());\n    if (params?.pageSize) queryParams.set('pageSize', params.pageSize.toString());\n    if (params?.sortBy) queryParams.set('sortBy', params.sortBy);\n    if (params?.sortOrder) queryParams.set('sortOrder', params.sortOrder);\n    if (params?.bookHash) queryParams.set('bookHash', params.bookHash);\n    if (params?.search) queryParams.set('search', params.search);\n\n    const url = queryParams.toString()\n      ? `${API_ENDPOINTS.list}?${queryParams.toString()}`\n      : API_ENDPOINTS.list;\n\n    const response = await request(url, {\n      method: 'GET',\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('List files failed:', error);\n    throw new Error('List files failed');\n  }\n};\n\ninterface PurgeFilesResult {\n  success: string[];\n  failed: Array<{ fileKey: string; error: string }>;\n  deletedCount: number;\n  failedCount: number;\n}\n\nexport const purgeFiles = async (\n  filePathsOrKeys: string[],\n  isFileKeys = false,\n): Promise<PurgeFilesResult> => {\n  try {\n    let fileKeys: string[];\n\n    if (isFileKeys) {\n      fileKeys = filePathsOrKeys;\n    } else {\n      fileKeys = await Promise.all(filePathsOrKeys.map((path) => buildFileKey(path)));\n    }\n\n    const response = await request(API_ENDPOINTS.purge, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fileKeys }),\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('Purge files failed:', error);\n    throw new Error('Purge files failed');\n  }\n};\n\nexport interface ScannedBook {\n  filePath: string;\n  relativePath: string;\n  fileName: string;\n  directory: string;\n  size: number;\n  mtime: number;\n  ext: string;\n}\n\nexport const scanBooks = async (): Promise<{ count: number; books: ScannedBook[] }> => {\n  try {\n    const response = await request(API_ENDPOINTS.scan, {\n      method: 'POST',\n    });\n    return await response.json();\n  } catch (error) {\n    console.error('Scan books failed:', error);\n    throw new Error('Scan books failed');\n  }\n};"],"names":[],"mappings":"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"}
{"version":3,"sources":["../../../../../../apps/readest-app/src/types/book.ts","../../../../../../apps/readest-app/src/utils/serializer.ts","../../../../../../apps/readest-app/src/services/webAppService.ts","../../../../../../apps/readest-app/src/services/apiFileSystem.ts"],"sourcesContent":["import { BookMetadata } from '@/libs/document';\nimport { TTSHighlightOptions } from '@/services/tts/types';\nimport { AnnotationToolType } from './annotator';\n\nexport type BookFormat =\n  | 'EPUB'\n  | 'PDF'\n  | 'MOBI'\n  | 'AZW'\n  | 'AZW3'\n  | 'CBZ'\n  | 'FB2'\n  | 'FBZ'\n  | 'TXT'\n  | 'MD';\nexport type BookNoteType = 'bookmark' | 'annotation' | 'excerpt';\nexport type HighlightStyle = 'highlight' | 'underline' | 'squiggly';\nexport type HighlightColor = 'red' | 'yellow' | 'green' | 'blue' | 'violet';\n\nexport const FIXED_LAYOUT_FORMATS: Set<BookFormat> = new Set(['PDF', 'CBZ']);\n\nexport interface Book {\n  // if Book is a remote book we just lazy load the book content via url\n  url?: string;\n  // if Book is a transient local book we can load the book content via filePath\n  filePath?: string;\n  // For local storage mode: relative path from storage root (e.g., \"fiction/book.epub\")\n  relativePath?: string;\n  // Absolute file path in the file system (for path reconciliation)\n  absolutePath?: string;\n  // Partial md5 hash of the book file, used as the unique identifier\n  hash: string;\n  // Metadata md5 hash, used to aggregate different versions of the same book\n  metaHash?: string;\n  format: BookFormat;\n  title: string; // editable title from metadata\n  sourceTitle?: string; // parsed when the book is imported and used to locate the file\n  author: string;\n  group?: string; // deprecated in favor of groupId and groupName\n  groupId?: string;\n  groupName?: string;\n  tags?: string[];\n  coverImageUrl?: string | null;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n\n  uploadedAt?: number | null;\n  downloadedAt?: number | null;\n  coverDownloadedAt?: number | null;\n  syncedAt?: number | null;\n\n  lastUpdated?: number; // deprecated in favor of updatedAt\n  progress?: [number, number]; // Add progress field: [current, total], 1-based page number\n  primaryLanguage?: string;\n\n  metadata?: BookMetadata;\n}\n\nexport interface BookGroupType {\n  id: string;\n  name: string;\n}\n\nexport interface PageInfo {\n  current: number;\n  next?: number;\n  total: number;\n}\n\n// Remaining time of the book in minutes\nexport interface TimeInfo {\n  section: number;\n  total: number;\n}\n\nexport interface BookNote {\n  bookHash?: string;\n  metaHash?: string;\n  id: string;\n  type: BookNoteType;\n  cfi: string;\n  text?: string;\n  style?: HighlightStyle;\n  color?: HighlightColor;\n  note: string;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n}\n\nexport interface BooknoteGroup {\n  id: number;\n  href: string;\n  label: string;\n  booknotes: BookNote[];\n}\n\nexport type WritingMode = 'auto' | 'horizontal-tb' | 'horizontal-rl' | 'vertical-rl';\n\nexport interface BookLayout {\n  marginTopPx: number;\n  marginBottomPx: number;\n  marginLeftPx: number;\n  marginRightPx: number;\n  marginPx?: number; // deprecated\n  compactMarginTopPx: number;\n  compactMarginBottomPx: number;\n  compactMarginLeftPx: number;\n  compactMarginRightPx: number;\n  compactMarginPx?: number; // deprecated\n  gapPercent: number;\n  scrolled: boolean;\n  disableClick: boolean;\n  fullscreenClickArea: boolean;\n  swapClickArea: boolean;\n  disableDoubleClick: boolean;\n  volumeKeysToFlip: boolean;\n  continuousScroll: boolean;\n  maxColumnCount: number;\n  maxInlineSize: number;\n  maxBlockSize: number;\n  animated: boolean;\n  isEink: boolean;\n  writingMode: WritingMode;\n  vertical: boolean;\n  rtl: boolean;\n  scrollingOverlap: number;\n  allowScript: boolean;\n}\n\nexport interface BookStyle {\n  zoomLevel: number;\n  paragraphMargin: number;\n  lineHeight: number;\n  wordSpacing: number;\n  letterSpacing: number;\n  textIndent: number;\n  fullJustification: boolean;\n  hyphenation: boolean;\n  invertImgColorInDark: boolean;\n  theme: string;\n  overrideFont: boolean;\n  overrideLayout: boolean;\n  overrideColor: boolean;\n  backgroundTextureId: string;\n  backgroundOpacity: number;\n  backgroundSize: string;\n  codeHighlighting: boolean;\n  codeLanguage: string;\n  userStylesheet: string;\n  userUIStylesheet: string;\n\n  // fixed-layout specific\n  zoomMode: 'fit-page' | 'fit-width' | 'original-size' | 'custom';\n  spreadMode: 'auto' | 'none';\n  keepCoverSpread: boolean;\n}\n\nexport interface BookFont {\n  serifFont: string;\n  sansSerifFont: string;\n  monospaceFont: string;\n  defaultFont: string;\n  defaultCJKFont: string;\n  defaultFontSize: number;\n  minimumFontSize: number;\n  fontWeight: number;\n}\n\nexport type ConvertChineseVariant =\n  | 'none'\n  | 's2t'\n  | 't2s'\n  | 's2tw'\n  | 's2hk'\n  | 's2twp'\n  | 'tw2s'\n  | 'hk2s'\n  | 'tw2sp';\n\nexport interface BookLanguage {\n  replaceQuotationMarks: boolean;\n  convertChineseVariant: ConvertChineseVariant;\n}\n\nexport interface ViewConfig {\n  sideBarTab: string;\n  uiLanguage: string;\n  sortedTOC: boolean;\n\n  doubleBorder: boolean;\n  borderColor: string;\n\n  showHeader: boolean;\n  showFooter: boolean;\n  showRemainingTime: boolean;\n  showRemainingPages: boolean;\n  showProgressInfo: boolean;\n  tapToToggleFooter: boolean;\n  showBarsOnScroll: boolean;\n  showMarginsOnScroll: boolean;\n  progressStyle: 'percentage' | 'fraction';\n  progressInfoMode: 'remaining' | 'progress' | 'all' | 'none';\n}\n\nexport interface TTSConfig {\n  ttsRate: number;\n  ttsVoice: string;\n  ttsLocation: string;\n  showTTSBar: boolean;\n  ttsHighlightOptions: TTSHighlightOptions;\n}\n\nexport interface TranslatorConfig {\n  translationEnabled: boolean;\n  translationProvider: string;\n  translateTargetLang: string;\n  showTranslateSource: boolean;\n  ttsReadAloudText: string;\n}\n\nexport interface NoteExportConfig {\n  includeTitle: boolean;\n  includeAuthor: boolean;\n  includeDate: boolean;\n  includeChapterTitles: boolean;\n  includeQuotes: boolean;\n  includeNotes: boolean;\n  includeTimestamp: boolean;\n  includeChapterSeparator: boolean;\n  noteSeparator: string;\n  useCustomTemplate: boolean;\n  customTemplate: string;\n}\n\nexport interface AnnotatorConfig {\n  enableAnnotationQuickActions: boolean;\n  annotationQuickAction: AnnotationToolType | null;\n  copyToNotebook: boolean;\n  noteExportConfig: NoteExportConfig;\n}\n\nexport interface ScreenConfig {\n  screenOrientation: 'auto' | 'portrait' | 'landscape';\n}\n\nexport type ProofreadScope = 'selection' | 'book' | 'library';\n\nexport interface ProofreadRule {\n  id: string;\n  scope: ProofreadScope;\n  pattern: string;\n  replacement: string;\n  cfi?: string;\n  sectionHref?: string;\n  enabled: boolean;\n  isRegex: boolean;\n  order: number; // Lower numbers apply first\n  wholeWord?: boolean; // Match whole words only (uses \\b word boundaries)\n  caseSensitive?: boolean; // Case-sensitive matching (default true)\n  onlyForTTS?: boolean; // Only replace text for TTS, not in the book display (only for book/library scope)\n}\n\nexport interface ProofreadRulesConfig {\n  proofreadRules?: ProofreadRule[];\n}\n\nexport interface ViewSettings\n  extends BookLayout,\n  BookStyle,\n  BookFont,\n  BookLanguage,\n  ViewConfig,\n  TTSConfig,\n  TranslatorConfig,\n  ScreenConfig,\n  ProofreadRulesConfig,\n  AnnotatorConfig { }\n\nexport interface BookProgress {\n  location: string;\n  sectionId: number;\n  sectionHref: string;\n  sectionLabel: string;\n  section: PageInfo;\n  pageinfo: PageInfo;\n  timeinfo: TimeInfo;\n  range: Range;\n}\n\nexport interface BookSearchConfig {\n  scope: 'book' | 'section';\n  matchCase: boolean;\n  matchWholeWords: boolean;\n  matchDiacritics: boolean;\n  index?: number;\n  query?: string;\n  acceptNode?: (node: Node) => number;\n\n  // pre-cached search results\n  results?: BookSearchResult[] | BookSearchMatch[] | null;\n}\n\nexport interface SearchExcerpt {\n  pre: string;\n  match: string;\n  post: string;\n}\n\nexport interface BookSearchMatch {\n  cfi: string;\n  excerpt: SearchExcerpt;\n}\n\nexport interface BookSearchResult {\n  index?: number;\n  label: string;\n  subitems: BookSearchMatch[];\n  progress?: number;\n}\n\nexport interface BookConfig {\n  bookHash?: string;\n  metaHash?: string;\n  progress?: [number, number]; // [current pagenum, total pagenum], 1-based page number\n  location?: string; // CFI of the current location\n  xpointer?: string; // XPointer of the current location (for Koreader interoperability)\n  booknotes?: BookNote[];\n  searchConfig?: Partial<BookSearchConfig>;\n  viewSettings?: Partial<ViewSettings>;\n\n  lastSyncedAtConfig?: number;\n  lastSyncedAtNotes?: number;\n\n  updatedAt: number;\n}\n\nexport interface BookDataRecord {\n  id: string;\n  book_hash: string;\n  meta_hash?: string;\n  user_id: string;\n  updated_at: number | null;\n  deleted_at: number | null;\n}\n\nexport interface BooksGroup {\n  id: string;\n  name: string;\n  displayName: string;\n  books: Book[];\n\n  updatedAt: number;\n}\nexport interface BookContent {\n  book: Book;\n  file: File;\n}\n","import { BookConfig, BookSearchConfig, ViewSettings } from '@/types/book';\n\nexport const serializeConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  config = JSON.parse(JSON.stringify(config));\n  const viewSettings = config.viewSettings as Partial<ViewSettings>;\n  const searchConfig = config.searchConfig as Partial<BookSearchConfig>;\n  config.viewSettings = Object.entries(viewSettings).reduce(\n    (acc: Partial<Record<keyof ViewSettings, unknown>>, [key, value]) => {\n      if (globalViewSettings[key as keyof ViewSettings] !== value) {\n        acc[key as keyof ViewSettings] = value;\n      }\n      return acc;\n    },\n    {} as Partial<Record<keyof ViewSettings, unknown>>,\n  ) as Partial<ViewSettings>;\n  config.searchConfig = Object.entries(searchConfig).reduce(\n    (acc: Partial<Record<keyof BookSearchConfig, unknown>>, [key, value]) => {\n      if (defaultSearchConfig[key as keyof BookSearchConfig] !== value) {\n        acc[key as keyof BookSearchConfig] = value;\n      }\n      return acc;\n    },\n    {} as Partial<BookSearchConfig>,\n  ) as Partial<BookSearchConfig>;\n\n  return JSON.stringify(config);\n};\n\nexport const deserializeConfig = (\n  str: string,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): BookConfig => {\n  const config = JSON.parse(str) as BookConfig;\n  const { viewSettings, searchConfig } = config;\n  config.viewSettings = { ...globalViewSettings, ...viewSettings };\n  config.searchConfig = { ...defaultSearchConfig, ...searchConfig };\n  config.updatedAt ??= Date.now();\n  return config;\n};\n\nexport const compressConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  return JSON.parse(serializeConfig(config, globalViewSettings, defaultSearchConfig));\n};\n","import { FileSystem, BaseDir, AppPlatform, ResolvedPath, FileItem } from '@/types/system';\nimport { getOSPlatform, isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { isPWA } from './environment';\nimport { BaseAppService } from './appService';\nimport {\n  DATA_SUBDIR,\n  LOCAL_BOOKS_SUBDIR,\n  LOCAL_FONTS_SUBDIR,\n  LOCAL_IMAGES_SUBDIR,\n} from './constants';\nimport { apiFileSystem } from './apiFileSystem';\n\n// Check storage mode at runtime to support window.__STORAGE_MODE__ set by Providers\nconst getIsLocalStorageMode = (): boolean => {\n  // First check window.__STORAGE_MODE__ (runtime set by Providers)\n  if (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') {\n    return true;\n  }\n  // Fallback to compile-time environment variable\n  return (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n};\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n  switch (base) {\n    case 'Data':\n      return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n    case 'Books':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_BOOKS_SUBDIR}/${path}`, base };\n    case 'Fonts':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n    case 'Images':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n    case 'None':\n      return { baseDir: 0, basePrefix, fp: path, base };\n    default:\n      return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n  }\n};\n\nconst dbName = 'AppFileSystem';\nconst dbVersion = 1;\n\nasync function openIndexedDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(dbName, dbVersion);\n\n    request.onupgradeneeded = () => {\n      const db = request.result;\n      if (!db.objectStoreNames.contains('files')) {\n        db.createObjectStore('files', { keyPath: 'path' });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst indexedDBFileSystem: FileSystem = {\n  resolvePath,\n  async getPrefix(base: BaseDir) {\n    const { basePrefix, fp } = this.resolvePath('', base);\n    const basePath = await basePrefix();\n    const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n    return prefix.replace(/\\/+$/, '');\n  },\n  getURL(path: string) {\n    if (isValidURL(path)) {\n      return path;\n    } else {\n      return URL.createObjectURL(new Blob([path]));\n    }\n  },\n  async getBlobURL(path: string, base: BaseDir) {\n    try {\n      const content = await this.readFile(path, base, 'binary');\n      return URL.createObjectURL(new Blob([content]));\n    } catch {\n      return path;\n    }\n  },\n  async getImageURL(path: string) {\n    return await this.getBlobURL(path, 'None');\n  },\n  async openFile(path: string, base: BaseDir, filename?: string) {\n    if (isValidURL(path)) {\n      return await new RemoteFile(path, filename).open();\n    } else {\n      const content = await this.readFile(path, base, 'binary');\n      return new File([content], filename || path);\n    }\n  },\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n    const { fp } = this.resolvePath(dstPath, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const getRequest = store.get(srcPath);\n\n      getRequest.onsuccess = () => {\n        const data = getRequest.result;\n        if (data) {\n          store.put({ path: fp, content: data.content });\n          resolve();\n        } else {\n          reject(new Error(`File not found: ${srcPath}`));\n        }\n      };\n\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  },\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<string | ArrayBuffer>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = async () => {\n        if (request.result) {\n          const content = request.result.content;\n          if (mode === 'text') resolve(content);\n          else {\n            if (content instanceof Blob) {\n              const arrayBuffer = await content.arrayBuffer();\n              resolve(arrayBuffer);\n            } else if (content instanceof ArrayBuffer) {\n              resolve(content);\n            } else if (typeof content === 'string') {\n              resolve(new TextEncoder().encode(content).buffer as ArrayBuffer);\n            } else {\n              reject(new Error('Unsupported content type in IndexedDB'));\n            }\n          }\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    if (content instanceof File) {\n      content = await content.arrayBuffer();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.put({ path: fp, content });\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async removeFile(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.delete(fp);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async createDir(path: string, base: BaseDir) {\n    return await this.writeFile(path, base, '');\n  },\n  async removeDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string }[];\n        files.forEach((file) => {\n          if (file.path.startsWith(fp)) {\n            store.delete(file.path);\n          }\n        });\n      };\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async readDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<FileItem[]>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string; content: string | ArrayBuffer | Blob }[];\n        resolve(\n          files\n            .filter((file) => file.path.startsWith(fp))\n            .map((file) => ({\n              path: file.path.slice(fp.length + 1),\n              size:\n                file.content instanceof Blob\n                  ? file.content.size\n                  : typeof file.content === 'string'\n                    ? file.content.length\n                    : file.content instanceof ArrayBuffer\n                      ? file.content.byteLength\n                      : 0,\n            })),\n        );\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async exists(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<boolean>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => resolve(!!request.result);\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async stats(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (result) {\n          const content = result.content;\n          const size =\n            content instanceof Blob\n              ? content.size\n              : typeof content === 'string'\n                ? content.length\n                : content instanceof ArrayBuffer\n                  ? content.byteLength\n                  : 0;\n          resolve({\n            isFile: true,\n            isDirectory: false,\n            size,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n          });\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n};\n\nexport class WebAppService extends BaseAppService {\n  // Use getter to check storage mode dynamically at runtime\n  get fs(): FileSystem {\n    return getIsLocalStorageMode() ? apiFileSystem : indexedDBFileSystem;\n  }\n  override isMobile = ['android', 'ios'].includes(getOSPlatform());\n  override appPlatform = 'web' as AppPlatform;\n  override hasSafeAreaInset = isPWA();\n\n  override async init() {\n    await this.loadSettings();\n    await this.prepareBooksDir();\n    await this.runMigrations();\n  }\n\n  override async runMigrations() {\n    try {\n      const settings = await this.loadSettings();\n      const lastMigrationVersion = settings.migrationVersion || 0;\n\n      await super.runMigrations(lastMigrationVersion);\n\n      if (lastMigrationVersion < this.CURRENT_MIGRATION_VERSION) {\n        await this.saveSettings({\n          ...settings,\n          migrationVersion: this.CURRENT_MIGRATION_VERSION,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to run migrations:', error);\n    }\n  }\n\n  override resolvePath(fp: string, base: BaseDir): ResolvedPath {\n    return this.fs.resolvePath(fp, base);\n  }\n\n  async setCustomRootDir() {\n    // No-op in web environment\n  }\n\n  async selectDirectory(): Promise<string> {\n    throw new Error('selectDirectory is not supported in browser');\n  }\n\n  async selectFiles(): Promise<string[]> {\n    throw new Error('selectFiles is not supported in browser');\n  }\n\n  async saveFile(filename: string, content: string | ArrayBuffer, mimeType?: string): Promise<boolean> {\n    try {\n      const blob = new Blob([content], { type: mimeType || 'application/octet-stream' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      return true;\n    } catch (error) {\n      console.error('Failed to save file:', error);\n      return false;\n    }\n  }\n}\n","import { FileSystem, BaseDir, ResolvedPath, FileItem } from '@/types/system';\nimport { isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { LOCAL_BOOKS_SUBDIR, LOCAL_FONTS_SUBDIR, LOCAL_IMAGES_SUBDIR, DATA_SUBDIR } from './constants';\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n    // Check if we're in local storage mode\n    const isLocalMode = (typeof process !== 'undefined' && process.env?.['NEXT_PUBLIC_STORAGE_MODE'] === 'local') ||\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local');\n\n    if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        console.log('[ResolvePath] Env Check - NEXT_PUBLIC_STORAGE_MODE:', process.env?.['NEXT_PUBLIC_STORAGE_MODE'], 'isLocalMode:', isLocalMode, 'base:', base, 'path:', path);\n    }\n\n    switch (base) {\n        case 'Data':\n            return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n        case 'Settings':\n            // Settings files now stored in .readest directory\n            return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n        case 'Books':\n            // Always use flat storage structure (no Readest/Books/ prefix)\n            // Library metadata files now go to .readest directory\n            if (path === 'library.json' || path === 'library.json.bak' || path === 'library_backup.json') {\n                console.log('[ResolvePath] Books/Library detected, routing to .readest');\n                return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n            }\n            // All book files and metadata use flat structure (no Readest/Books/ prefix)\n            console.log('[ResolvePath] ✓ Books base, flat path (no prefix):', path);\n            console.log('[ResolvePath] ✓ Returning fp:', path);\n            return { baseDir: 0, basePrefix, fp: path, base };\n        case 'Fonts':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n        case 'Images':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n        case 'None':\n            return { baseDir: 0, basePrefix, fp: path, base };\n        default:\n            return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n    }\n};\n\nexport const apiFileSystem: FileSystem = {\n    resolvePath,\n    async getPrefix(base: BaseDir) {\n        const { basePrefix, fp } = this.resolvePath('', base);\n        const basePath = await basePrefix();\n        const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n        return prefix.replace(/\\/+$/, '');\n    },\n    getURL(path: string) {\n        if (isValidURL(path)) {\n            return path;\n        }\n        return `/api/storage/file?filePath=${encodeURIComponent(path)}`;\n    },\n    async getBlobURL(path: string, base: BaseDir) {\n        try {\n            const content = await this.readFile(path, base, 'binary');\n            return URL.createObjectURL(new Blob([content]));\n        } catch {\n            return path;\n        }\n    },\n    async getImageURL(path: string) {\n        return this.getURL(path);\n    },\n    async openFile(path: string, base: BaseDir, filename?: string) {\n        if (isValidURL(path)) {\n            return await new RemoteFile(path, filename).open();\n        }\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        return new File([await res.arrayBuffer()], filename || path);\n    },\n    async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n        const file = await this.openFile(srcPath, base);\n        await this.writeFile(dstPath, base, file);\n    },\n    async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error(`File not found: ${fp}`);\n        return mode === 'text' ? await res.text() : await res.arrayBuffer();\n    },\n    async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n        const { fp } = this.resolvePath(path, base);\n        console.log('[APIFileSystem.writeFile] 11. Input path:', path);\n        console.log('[APIFileSystem.writeFile] 12. Base:', base);\n        console.log('[APIFileSystem.writeFile] 13. Resolved fp:', fp);\n        let buffer: Buffer;\n        if (content instanceof File) {\n            buffer = Buffer.from(await content.arrayBuffer());\n        } else if (typeof content === 'string') {\n            buffer = Buffer.from(content);\n        } else {\n            buffer = Buffer.from(content);\n        }\n        console.log('[APIFileSystem.writeFile] 14. Calling PUT /api/storage/file with filePath:', fp);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`, {\n            method: 'PUT',\n            body: buffer,\n        });\n        if (!res.ok) throw new Error('Failed to write file');\n    },\n    async removeFile(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/delete?fileKey=${encodeURIComponent(fp)}`, {\n            method: 'DELETE',\n        });\n        if (!res.ok) throw new Error('Failed to delete file');\n    },\n    async createDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async removeDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async readDir(path: string, base: BaseDir): Promise<FileItem[]> {\n        return [];\n    },\n    async exists(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        return res.ok;\n    },\n    async stats(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        const buffer = await res.arrayBuffer();\n        return {\n            isFile: true,\n            isDirectory: false,\n            size: buffer.byteLength,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n        };\n    },\n};\n"],"names":[],"mappings":"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"}
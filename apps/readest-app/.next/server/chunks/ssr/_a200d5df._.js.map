{"version":3,"sources":["../../../../../../packages/foliate-js/epubcfi.js","../../../../../../apps/readest-app/src/libs/document.ts","../../../../../../apps/readest-app/src/utils/book.ts"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n","import { BookFormat } from '@/types/book';\nimport { Contributor, Identifier, LanguageMap } from '@/utils/book';\nimport * as epubcfi from 'foliate-js/epubcfi.js';\n\nexport const CFI = epubcfi;\n\nexport type DocumentFile = File;\n\nexport type Location = {\n  current: number;\n  next: number;\n  total: number;\n};\n\nexport interface TOCItem {\n  id: number;\n  label: string;\n  href: string;\n  cfi?: string;\n  location?: Location;\n  subitems?: TOCItem[];\n}\n\nexport interface SectionItem {\n  id: string;\n  cfi: string;\n  size: number;\n  linear: string;\n  location?: Location;\n  pageSpread?: 'left' | 'right' | 'center' | '';\n\n  createDocument: () => Promise<Document>;\n}\n\nexport type BookMetadata = {\n  // NOTE: the title and author fields should be formatted\n  title: string | LanguageMap;\n  author: string | Contributor;\n  language: string | string[];\n  editor?: string;\n  publisher?: string;\n  published?: string;\n  description?: string;\n  subject?: string | string[] | Contributor;\n  identifier?: string;\n  altIdentifier?: string | string[] | Identifier;\n\n  subtitle?: string;\n  series?: string;\n  seriesIndex?: number;\n  seriesTotal?: number;\n\n  coverImageFile?: string;\n  coverImageUrl?: string;\n  coverImageBlobUrl?: string;\n};\n\nexport interface BookDoc {\n  metadata: BookMetadata;\n  rendition?: {\n    layout?: 'pre-paginated' | 'reflowable';\n    spread?: 'auto' | 'none';\n    viewport?: { width: number; height: number };\n  };\n  dir: string;\n  toc?: Array<TOCItem>;\n  sections?: Array<SectionItem>;\n  transformTarget?: EventTarget;\n  splitTOCHref(href: string): Array<string | number>;\n  getCover(): Promise<Blob | null>;\n}\n\nexport const EXTS: Record<BookFormat, string> = {\n  EPUB: 'epub',\n  PDF: 'pdf',\n  MOBI: 'mobi',\n  AZW: 'azw',\n  AZW3: 'azw3',\n  CBZ: 'cbz',\n  FB2: 'fb2',\n  FBZ: 'fbz',\n  TXT: 'txt',\n  MD: 'md',\n};\n\nexport const MIMETYPES: Record<BookFormat, string[]> = {\n  EPUB: ['application/epub+zip'],\n  PDF: ['application/pdf'],\n  MOBI: ['application/x-mobipocket-ebook'],\n  AZW: ['application/vnd.amazon.ebook'],\n  AZW3: ['application/vnd.amazon.mobi8-ebook', 'application/x-mobi8-ebook'],\n  CBZ: ['application/vnd.comicbook+zip', 'application/zip', 'application/x-cbz'],\n  FB2: ['application/x-fictionbook+xml', 'text/xml', 'application/xml'],\n  FBZ: ['application/x-zip-compressed-fb2', 'application/zip'],\n  TXT: ['text/plain'],\n  MD: ['text/markdown', 'text/x-markdown'],\n};\n\nexport class DocumentLoader {\n  private file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  private async isZip(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 4).arrayBuffer());\n    return arr[0] === 0x50 && arr[1] === 0x4b && arr[2] === 0x03 && arr[3] === 0x04;\n  }\n\n  private async isPDF(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 5).arrayBuffer());\n    return (\n      arr[0] === 0x25 && arr[1] === 0x50 && arr[2] === 0x44 && arr[3] === 0x46 && arr[4] === 0x2d\n    );\n  }\n\n  private async makeZipLoader() {\n    const getComment = async (): Promise<string | null> => {\n      const EOCD_SIGNATURE = [0x50, 0x4b, 0x05, 0x06];\n      const maxEOCDSearch = 1024 * 64;\n\n      const sliceSize = Math.min(maxEOCDSearch, this.file.size);\n      const tail = await this.file.slice(this.file.size - sliceSize, this.file.size).arrayBuffer();\n      const bytes = new Uint8Array(tail);\n\n      for (let i = bytes.length - 22; i >= 0; i--) {\n        if (\n          bytes[i] === EOCD_SIGNATURE[0] &&\n          bytes[i + 1] === EOCD_SIGNATURE[1] &&\n          bytes[i + 2] === EOCD_SIGNATURE[2] &&\n          bytes[i + 3] === EOCD_SIGNATURE[3]\n        ) {\n          const commentLength = bytes[i + 20]! + (bytes[i + 21]! << 8);\n          const commentStart = i + 22;\n          const commentBytes = bytes.slice(commentStart, commentStart + commentLength);\n          return new TextDecoder().decode(commentBytes);\n        }\n      }\n\n      return null;\n    };\n\n    const { configure, ZipReader, BlobReader, TextWriter, BlobWriter } = await import(\n      '@zip.js/zip.js'\n    );\n    type Entry = import('@zip.js/zip.js').Entry;\n    configure({ useWebWorkers: false });\n    const reader = new ZipReader(new BlobReader(this.file));\n    const entries = await reader.getEntries();\n    const map = new Map(entries.map((entry) => [entry.filename, entry]));\n    const load =\n      (f: (entry: Entry, type?: string) => Promise<string | Blob> | null) =>\n      (name: string, ...args: [string?]) =>\n        map.has(name) ? f(map.get(name)!, ...args) : null;\n\n    const loadText = load((entry: Entry) =>\n      entry.getData ? entry.getData(new TextWriter()) : null,\n    );\n    const loadBlob = load((entry: Entry, type?: string) =>\n      entry.getData ? entry.getData(new BlobWriter(type!)) : null,\n    );\n    const getSize = (name: string) => map.get(name)?.uncompressedSize ?? 0;\n\n    return { entries, loadText, loadBlob, getSize, getComment, sha1: undefined };\n  }\n\n  private isCBZ(): boolean {\n    return (\n      this.file.type === 'application/vnd.comicbook+zip' || this.file.name.endsWith(`.${EXTS.CBZ}`)\n    );\n  }\n\n  private isFB2(): boolean {\n    return (\n      this.file.type === 'application/x-fictionbook+xml' || this.file.name.endsWith(`.${EXTS.FB2}`)\n    );\n  }\n\n  private isFBZ(): boolean {\n    return (\n      this.file.type === 'application/x-zip-compressed-fb2' ||\n      this.file.name.endsWith('.fb.zip') ||\n      this.file.name.endsWith('.fb2.zip') ||\n      this.file.name.endsWith(`.${EXTS.FBZ}`)\n    );\n  }\n\n  public async open(): Promise<{ book: BookDoc; format: BookFormat }> {\n    let book = null;\n    let format: BookFormat = 'EPUB';\n    if (!this.file.size) {\n      throw new Error('File is empty');\n    }\n    try {\n      if (await this.isZip()) {\n        const loader = await this.makeZipLoader();\n        const { entries } = loader;\n\n        if (this.isCBZ()) {\n          const { makeComicBook } = await import('foliate-js/comic-book.js');\n          book = await makeComicBook(loader, this.file);\n          format = 'CBZ';\n        } else if (this.isFBZ()) {\n          const entry = entries.find((entry) => entry.filename.endsWith(`.${EXTS.FB2}`));\n          const blob = await loader.loadBlob((entry ?? entries[0]!).filename);\n          const { makeFB2 } = await import('foliate-js/fb2.js');\n          book = await makeFB2(blob);\n          format = 'FBZ';\n        } else {\n          const { EPUB } = await import('foliate-js/epub.js');\n          book = await new EPUB(loader).init();\n          format = 'EPUB';\n        }\n      } else if (await this.isPDF()) {\n        const { makePDF } = await import('foliate-js/pdf.js');\n        book = await makePDF(this.file);\n        format = 'PDF';\n      } else if (await (await import('foliate-js/mobi.js')).isMOBI(this.file)) {\n        const fflate = await import('foliate-js/vendor/fflate.js');\n        const { MOBI } = await import('foliate-js/mobi.js');\n        book = await new MOBI({ unzlib: fflate.unzlibSync }).open(this.file);\n        const ext = this.file.name.split('.').pop()?.toLowerCase();\n        switch (ext) {\n          case 'azw':\n            format = 'AZW';\n            break;\n          case 'azw3':\n            format = 'AZW3';\n            break;\n          default:\n            format = 'MOBI';\n        }\n      } else if (this.isFB2()) {\n        const { makeFB2 } = await import('foliate-js/fb2.js');\n        book = await makeFB2(this.file);\n        format = 'FB2';\n      }\n    } catch (e: unknown) {\n      console.error('Failed to open document:', e);\n      if (e instanceof Error && e.message?.includes('not a valid zip')) {\n        throw new Error('Unsupported or corrupted book file');\n      }\n      throw e;\n    }\n    return { book, format } as { book: BookDoc; format: BookFormat };\n  }\n}\n\nexport const getDirection = (doc: Document) => {\n  const { defaultView } = doc;\n  const { writingMode, direction } = defaultView!.getComputedStyle(doc.body);\n  const vertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr';\n  const rtl = doc.body.dir === 'rtl' || direction === 'rtl' || doc.documentElement.dir === 'rtl';\n  return { vertical, rtl };\n};\n\nexport const getFileExtFromMimeType = (mimeType?: string): string => {\n  if (!mimeType) return '';\n\n  for (const format in MIMETYPES) {\n    const list = MIMETYPES[format as BookFormat];\n    if (list.includes(mimeType)) {\n      return EXTS[format as BookFormat];\n    }\n  }\n  return '';\n};\n\nexport const getMimeTypeFromFileExt = (ext: string): string => {\n  ext = ext.toLowerCase();\n  for (const format in EXTS) {\n    if (EXTS[format as BookFormat] === ext) {\n      const mimeTypes = MIMETYPES[format as BookFormat];\n      return mimeTypes[0] || 'application/octet-stream';\n    }\n  }\n  return 'application/octet-stream';\n};\n","import { BookMetadata, EXTS } from '@/libs/document';\nimport { Book, BookConfig, BookProgress, WritingMode } from '@/types/book';\nimport { SUPPORTED_LANGS } from '@/services/constants';\nimport { getUserLang } from './misc';\nimport { getDirFromLanguage } from './rtl';\nimport { code6392to6391, isValidLang, normalizedLangCode } from './lang';\nimport { md5 } from './md5';\n\nexport const getDir = (book: Book) => {\n  // In local storage mode, return the folder name (same as book name without extension)\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath.replace(/\\.[^.]+$/, '');\n};\nexport const getLibraryFilename = () => {\n  return 'library.json';\n};\nexport const getLibraryBackupFilename = () => {\n  return 'library_backup.json';\n};\nexport const getLocalBookFilename = (book: Book) => {\n  // In local storage mode, books are stored in their original relative paths\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath;\n};\nexport const getCoverFilename = (book: Book) => {\n  // In local storage mode, covers are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  const result = `${pathWithoutExt}/cover.png`;\n  console.log('[getCoverFilename] ✓ Using relativePath:', book.relativePath);\n  console.log('[getCoverFilename] ✓ Cover path result:', result);\n  return result;\n};\nexport const getConfigFilename = (book: Book) => {\n  // In local storage mode, configs are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  return `${pathWithoutExt}/config.json`;\n};\nexport const isBookFile = (filename: string) => {\n  return Object.values(EXTS).includes(filename.split('.').pop()!);\n};\n\nexport const INIT_BOOK_CONFIG: BookConfig = {\n  updatedAt: 0,\n};\n\nexport interface LanguageMap {\n  [key: string]: string;\n}\n\nexport interface Identifier {\n  scheme: string;\n  value: string;\n}\n\nexport interface Contributor {\n  name: LanguageMap;\n}\n\nconst formatLanguageMap = (x: string | LanguageMap, defaultLang = false): string => {\n  const userLang = getUserLang();\n  if (!x) return '';\n  if (typeof x === 'string') return x;\n  const keys = Object.keys(x);\n  return defaultLang ? x[keys[0]!]! : x[userLang] || x[keys[0]!]!;\n};\n\nexport const listFormater = (narrow = false, lang = '') => {\n  lang = lang ? lang : getUserLang();\n  if (narrow) {\n    return new Intl.ListFormat('en', { style: 'narrow', type: 'unit' });\n  } else {\n    return new Intl.ListFormat(lang, { style: 'long', type: 'conjunction' });\n  }\n};\n\nexport const getBookLangCode = (lang: string | string[] | undefined) => {\n  try {\n    const bookLang = typeof lang === 'string' ? lang : lang?.[0];\n    return bookLang ? bookLang.split('-')[0]! : '';\n  } catch {\n    return '';\n  }\n};\n\nexport const flattenContributors = (\n  contributors: string | string[] | Contributor | Contributor[],\n) => {\n  if (!contributors) return '';\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string' ? contributor : formatLanguageMap(contributor?.name),\n      )\n      .join(', ')\n    : typeof contributors === 'string'\n      ? contributors\n      : formatLanguageMap(contributors?.name);\n};\n\n// prettier-ignore\nconst LASTNAME_AUTHOR_SORT_LANGS = ['ar', 'bo', 'de', 'en', 'es', 'fr', 'hi', 'it', 'nl', 'pl', 'pt', 'ru', 'th', 'tr', 'uk'];\n\nconst formatAuthorName = (name: string, lastNameFirst: boolean) => {\n  if (!name) return '';\n  const parts = name.split(' ');\n  if (lastNameFirst && parts.length > 1) {\n    return `${parts[parts.length - 1]}, ${parts.slice(0, -1).join(' ')}`;\n  }\n  return name;\n};\n\nexport const formatAuthors = (\n  contributors: string | string[] | Contributor | Contributor[],\n  bookLang?: string | string[],\n  sortAs?: boolean,\n) => {\n  const langCode = getBookLangCode(bookLang) || 'en';\n  const lastNameFirst = !!sortAs && LASTNAME_AUTHOR_SORT_LANGS.includes(langCode);\n  return Array.isArray(contributors)\n    ? listFormater(langCode === 'zh', langCode).format(\n      contributors.map((contributor) =>\n        typeof contributor === 'string'\n          ? formatAuthorName(contributor, lastNameFirst)\n          : formatAuthorName(formatLanguageMap(contributor?.name), lastNameFirst),\n      ),\n    )\n    : typeof contributors === 'string'\n      ? formatAuthorName(contributors, lastNameFirst)\n      : formatAuthorName(formatLanguageMap(contributors?.name), lastNameFirst);\n};\n\nexport const formatTitle = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title);\n};\n\nexport const formatDescription = (description?: string | LanguageMap) => {\n  if (!description) return '';\n  const text = typeof description === 'string' ? description : formatLanguageMap(description);\n  return text\n    .replace(/<\\/?[^>]+(>|$)/g, '')\n    .replace(/&#\\d+;/g, '')\n    .trim();\n};\n\nexport const formatPublisher = (publisher: string | LanguageMap) => {\n  return typeof publisher === 'string' ? publisher : formatLanguageMap(publisher);\n};\n\nconst langCodeToLangName = (langCode: string) => {\n  return SUPPORTED_LANGS[langCode] || langCode.toUpperCase();\n};\n\nexport const formatLanguage = (lang: string | string[] | undefined): string => {\n  return Array.isArray(lang)\n    ? lang.map(langCodeToLangName).join(', ')\n    : langCodeToLangName(lang || '');\n};\n\n// Should return valid ISO-639-1 language code, fallback to 'en' if not valid\nexport const getPrimaryLanguage = (lang: string | string[] | undefined) => {\n  const primaryLang = Array.isArray(lang) ? lang[0] : lang;\n  if (isValidLang(primaryLang)) {\n    const normalizedLang = normalizedLangCode(primaryLang);\n    return code6392to6391(normalizedLang) || normalizedLang;\n  }\n  return 'en';\n};\n\nexport const formatDate = (date: string | number | Date | null | undefined, isUTC = false) => {\n  if (!date) return;\n  const userLang = getUserLang();\n  try {\n    return new Date(date).toLocaleDateString(userLang, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      timeZone: isUTC ? 'UTC' : undefined,\n    });\n  } catch {\n    return;\n  }\n};\n\nexport const formatBytes = (bytes?: number | null, locale = 'en-US') => {\n  if (!bytes) return '';\n  const units = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte'];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  const value = bytes / Math.pow(1024, i);\n  const formatter = new Intl.NumberFormat(locale, {\n    style: 'unit',\n    unit: units[i],\n    unitDisplay: 'short',\n    maximumFractionDigits: 2,\n  });\n  return formatter.format(value);\n};\n\nexport const getCurrentPage = (book: Book, progress: BookProgress) => {\n  const bookFormat = book.format;\n  const { section, pageinfo } = progress;\n  return bookFormat === 'PDF'\n    ? section\n      ? section.current + 1\n      : 0\n    : pageinfo\n      ? pageinfo.current + 1\n      : 0;\n};\n\nexport const getBookDirFromWritingMode = (writingMode: WritingMode) => {\n  switch (writingMode) {\n    case 'horizontal-tb':\n      return 'ltr';\n    case 'horizontal-rl':\n    case 'vertical-rl':\n      return 'rtl';\n    default:\n      return 'auto';\n  }\n};\n\nexport const getBookDirFromLanguage = (language: string | string[] | undefined) => {\n  const lang = getPrimaryLanguage(language) || '';\n  return getDirFromLanguage(lang);\n};\n\nconst getTitleForHash = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title, true);\n};\n\nconst getAuthorsList = (contributors: string | string[] | Contributor | Contributor[]) => {\n  if (!contributors) return [];\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string'\n          ? contributor\n          : formatLanguageMap(contributor?.name, true),\n      )\n      .filter(Boolean)\n    : [\n      typeof contributors === 'string'\n        ? contributors\n        : formatLanguageMap(contributors?.name, true),\n    ];\n};\n\nconst normalizeIdentifier = (identifier: string) => {\n  try {\n    if (identifier.includes('urn:')) {\n      // Slice after the last ':'\n      return identifier.match(/[^:]+$/)?.[0] || '';\n    } else if (identifier.includes(':')) {\n      // Slice after the first ':'\n      return identifier.match(/^[^:]+:(.+)$/)?.[1] || '';\n    }\n  } catch {\n    return identifier;\n  }\n  return identifier;\n};\n\nconst getPreferredIdentifier = (identifiers: string[] | Identifier[]) => {\n  for (const scheme of ['uuid', 'calibre', 'isbn']) {\n    const found = identifiers.find((identifier) =>\n      typeof identifier === 'string'\n        ? identifier.toLowerCase().includes(scheme)\n        : identifier.scheme.toLowerCase() === scheme,\n    );\n    if (found) {\n      return typeof found === 'string' ? normalizeIdentifier(found) : found.value;\n    }\n  }\n  return;\n};\n\nconst getIdentifiersList = (\n  identifiers: undefined | string | string[] | Identifier | Identifier[],\n) => {\n  if (!identifiers) return [];\n  if (Array.isArray(identifiers)) {\n    const preferred = getPreferredIdentifier(identifiers);\n    if (preferred) {\n      return [preferred];\n    }\n  }\n  return Array.isArray(identifiers)\n    ? identifiers\n      .map((identifier) =>\n        typeof identifier === 'string' ? normalizeIdentifier(identifier) : identifier.value,\n      )\n      .filter(Boolean)\n    : typeof identifiers === 'string'\n      ? [normalizeIdentifier(identifiers)]\n      : [identifiers.value];\n};\n\nexport const getMetadataHash = (metadata: BookMetadata) => {\n  try {\n    const title = getTitleForHash(metadata.title);\n    const authors = getAuthorsList(metadata.author).join(',');\n    const identifiers = getIdentifiersList(metadata.altIdentifier || metadata.identifier).join(',');\n    const hashSource = `${title}|${authors}|${identifiers}`;\n    const metaHash = md5(hashSource.normalize('NFC'));\n    return metaHash;\n  } catch (error) {\n    console.error('Error generating metadata hash:', error);\n  }\n  return;\n};\n"],"names":[],"mappings":"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"}
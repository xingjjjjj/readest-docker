{"version":3,"sources":["../../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-fs%402.4.5/node_modules/%40tauri-apps/plugin-fs/dist-js/index.js","../../../../../../apps/readest-app/src/utils/file.ts","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/native.js","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/rng.js","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/regex.js","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/validate.js","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/stringify.js","../../../../../../node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm/v4.js","../../../../../../apps/readest-app/src/services/appService.ts","../../../../../../apps/readest-app/src/utils/indexedDBCache.ts","../../../../../../apps/readest-app/src/utils/cachedFetch.ts","../../../../../../apps/readest-app/src/utils/txt.ts","../../../../../../apps/readest-app/src/services/errors.ts","../../../../../../apps/readest-app/src/utils/font.ts","../../../../../../apps/readest-app/src/utils/svg.ts"],"sourcesContent":["export { BaseDirectory } from '@tauri-apps/api/path';\nimport { Resource, invoke, Channel } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Access the file system.\n *\n * ## Security\n *\n * This module prevents path traversal, not allowing parent directory accessors to be used\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/ | path API}.\n *\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\n *\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:scope\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:allow-exists\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\n *\n * The available variables are:\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\n *\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nvar SeekMode;\n(function (SeekMode) {\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\n})(SeekMode || (SeekMode = {}));\nfunction parseFileInfo(r) {\n    return {\n        isFile: r.isFile,\n        isDirectory: r.isDirectory,\n        isSymlink: r.isSymlink,\n        size: r.size,\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\n        atime: r.atime !== null ? new Date(r.atime) : null,\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\n        readonly: r.readonly,\n        fileAttributes: r.fileAttributes,\n        dev: r.dev,\n        ino: r.ino,\n        mode: r.mode,\n        nlink: r.nlink,\n        uid: r.uid,\n        gid: r.gid,\n        rdev: r.rdev,\n        blksize: r.blksize,\n        blocks: r.blocks\n    };\n}\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\n/** Converts a big-endian eight byte array to number  */\nfunction fromBytes(buffer) {\n    const bytes = new Uint8ClampedArray(buffer);\n    const size = bytes.byteLength;\n    let x = 0;\n    for (let i = 0; i < size; i++) {\n        // eslint-disable-next-line security/detect-object-injection\n        const byte = bytes[i];\n        x *= 0x100;\n        x += byte;\n    }\n    return x;\n}\n/**\n *  The Tauri abstraction for reading and writing files.\n *\n * @since 2.0.0\n */\nclass FileHandle extends Resource {\n    /**\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async read(buffer) {\n        if (buffer.byteLength === 0) {\n            return 0;\n        }\n        const data = await invoke('plugin:fs|read', {\n            rid: this.rid,\n            len: buffer.byteLength\n        });\n        // Rust side will never return an empty array for this command and\n        // ensure there is at least 8 elements there.\n        //\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\n        // at the end of returned array to avoid serialization overhead of separate values.\n        const nread = fromBytes(data.slice(-8));\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        buffer.set(bytes.slice(0, bytes.length - 8));\n        return nread === 0 ? null : nread;\n    }\n    /**\n     * Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     *\n     * @example\n     * ```typescript\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\n     *\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async seek(offset, whence) {\n        return await invoke('plugin:fs|seek', {\n            rid: this.rid,\n            offset,\n            whence\n        });\n    }\n    /**\n     * Returns a {@linkcode FileInfo } for this file.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\n     * const fileInfo = await file.stat();\n     * console.log(fileInfo.isFile); // true\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async stat() {\n        const res = await invoke('plugin:fs|fstat', {\n            rid: this.rid\n        });\n        return parseFileInfo(res);\n    }\n    /**\n     * Truncates or extends this file, to reach the specified `len`.\n     * If `len` is not specified then the entire file contents are truncated.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // truncate the entire file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.truncate();\n     *\n     * // truncate part of the file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(7);\n     * const data = new Uint8Array(32);\n     * await file.read(data);\n     * console.log(new TextDecoder().decode(data)); // Hello W\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async truncate(len) {\n        await invoke('plugin:fs|ftruncate', {\n            rid: this.rid,\n            len\n        });\n    }\n    /**\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\n     * `data.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * @example\n     * ```typescript\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\n     * const bytesWritten = await file.write(data); // 11\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async write(data) {\n        return await invoke('plugin:fs|write', {\n            rid: this.rid,\n            data\n        });\n    }\n}\n/**\n * Creates a file if none exists or truncates an existing file and resolves to\n *  an instance of {@linkcode FileHandle }.\n *\n * @example\n * ```typescript\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n * await file.write(new TextEncoder().encode(\"Hello world\"));\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function create(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|create', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\n * file does not need to previously exist if using the `create` or `createNew`\n * open options. It is the callers responsibility to close the file when finished\n * with it.\n *\n * @example\n * ```typescript\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\n * // Do work with file\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function open(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|open', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function copyFile(fromPath, toPath, options) {\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:')\n        || (toPath instanceof URL && toPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|copy_file', {\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\n        options\n    });\n}\n/**\n * Creates a new directory with the specified path.\n * @example\n * ```typescript\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function mkdir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|mkdir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads the directory given by path and returns an array of `DirEntry`.\n * @example\n * ```typescript\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * import { join } from '@tauri-apps/api/path';\n * const dir = \"users\"\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\n * processEntriesRecursively(dir, entries);\n * async function processEntriesRecursively(parent, entries) {\n *   for (const entry of entries) {\n *     console.log(`Entry: ${entry.name}`);\n *     if (entry.isDirectory) {\n *        const dir = await join(parent, entry.name);\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\n *     }\n *   }\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function readDir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|read_dir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads and resolves to the entire contents of a file as an array of bytes.\n * TextDecoder can be used to transform the bytes to string if required.\n * @example\n * ```typescript\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\n * ```\n *\n * @since 2.0.0\n */\nasync function readFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n}\n/**\n * Reads and returns the entire contents of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function readTextFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_text_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\n * for await (const line of lines) {\n *   console.log(line);\n * }\n * ```\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\n * iterator so you can lazily read the next line whenever you want.\n *\n * @since 2.0.0\n */\nasync function readTextFileLines(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const pathStr = path instanceof URL ? path.toString() : path;\n    return await Promise.resolve({\n        path: pathStr,\n        rid: null,\n        async next() {\n            if (this.rid === null) {\n                this.rid = await invoke('plugin:fs|read_text_file_lines', {\n                    path: pathStr,\n                    options\n                });\n            }\n            const arr = await invoke('plugin:fs|read_text_file_lines_next', { rid: this.rid });\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n            // Rust side will never return an empty array for this command and\n            // ensure there is at least one elements there.\n            //\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\n            // at the end of returned array to avoid serialization overhead of separate values.\n            const done = bytes[bytes.byteLength - 1] === 1;\n            if (done) {\n                // a full iteration is over, reset rid for next iteration\n                this.rid = null;\n                return { value: null, done };\n            }\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength - 1));\n            return {\n                value: line,\n                done\n            };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    });\n}\n/**\n * Removes the named file or directory.\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\n * @example\n * ```typescript\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function remove(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|remove', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\n * If newpath already exists and is not a directory, rename() replaces it.\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\n *\n * On Unix, this operation does not follow symlinks at either path.\n *\n * @example\n * ```typescript\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function rename(oldPath, newPath, options) {\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:')\n        || (newPath instanceof URL && newPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|rename', {\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\n        options\n    });\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\n *\n * @example\n * ```typescript\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function stat(path, options) {\n    const res = await invoke('plugin:fs|stat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\n * symlink, information for the symlink will be returned instead of what it\n * points to.\n *\n * @example\n * ```typescript\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function lstat(path, options) {\n    const res = await invoke('plugin:fs|lstat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Truncates or extends the specified file, to reach the specified `len`.\n * If `len` is `0` or not specified, then the entire file contents are truncated.\n *\n * @example\n * ```typescript\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // truncate the entire file\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\n *\n * // truncate part of the file\n * const filePath = \"file.txt\";\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\n * console.log(data);  // \"Hello W\"\n * ```\n *\n * @since 2.0.0\n */\nasync function truncate(path, len, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|truncate', {\n        path: path instanceof URL ? path.toString() : path,\n        len,\n        options\n    });\n}\n/**\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n *\n * let encoder = new TextEncoder();\n * let data = encoder.encode(\"Hello World\");\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function writeFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    if (data instanceof ReadableStream) {\n        const file = await open(path, {\n            read: false,\n            create: true,\n            write: true,\n            ...options\n        });\n        const reader = data.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                await file.write(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n            await file.close();\n        }\n    }\n    else {\n        await invoke('plugin:fs|write_file', data, {\n            headers: {\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n                options: JSON.stringify(options)\n            }\n        });\n    }\n}\n/**\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\n    @example\n  * ```typescript\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n  *\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\n  * ```\n  *\n  * @since 2.0.0\n  */\nasync function writeTextFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const encoder = new TextEncoder();\n    await invoke('plugin:fs|write_text_file', encoder.encode(data), {\n        headers: {\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n            options: JSON.stringify(options)\n        }\n    });\n}\n/**\n * Check if a path exists.\n * @example\n * ```typescript\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Check if the `$APPDATA/avatar.png` file exists\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\n * ```\n *\n * @since 2.0.0\n */\nasync function exists(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|exists', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\nclass Watcher extends Resource {\n}\nasync function watchInternal(paths, cb, options) {\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new Channel();\n    onEvent.onmessage = cb;\n    const rid = await invoke('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options,\n        onEvent\n    });\n    const watcher = new Watcher(rid);\n    return () => {\n        void watcher.close();\n    };\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes (after a delay) on files or directories.\n *\n * @since 2.0.0\n */\nasync function watch(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        delayMs: 2000,\n        ...options\n    });\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes on files or directories.\n *\n * @since 2.0.0\n */\nasync function watchImmediate(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        ...options,\n        delayMs: undefined\n    });\n}\n/**\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\n *\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\n *\n * @example\n * ```typescript\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Get the size of the `$APPDATA/tauri` directory.\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\n * console.log(dirSize); // 1024\n * ```\n *\n * @since 2.1.0\n */\nasync function size(path) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|size', {\n        path: path instanceof URL ? path.toString() : path\n    });\n}\n\nexport { FileHandle, SeekMode, copyFile, create, exists, lstat, mkdir, open, readDir, readFile, readTextFile, readTextFileLines, remove, rename, size, stat, truncate, watch, watchImmediate, writeFile, writeTextFile };\n","import { FileHandle, open, BaseDirectory, SeekMode } from '@tauri-apps/plugin-fs';\nimport { getOSPlatform } from './misc';\n\nclass DeferredBlob extends Blob {\n  #dataPromise: Promise<ArrayBuffer>;\n  #type: string;\n\n  constructor(dataPromise: Promise<ArrayBuffer>, type: string) {\n    super();\n    this.#dataPromise = dataPromise;\n    this.#type = type;\n  }\n\n  override async arrayBuffer() {\n    const data = await this.#dataPromise;\n    return data;\n  }\n\n  override async text() {\n    const data = await this.#dataPromise;\n    return new TextDecoder().decode(data);\n  }\n\n  override stream() {\n    return new ReadableStream({\n      start: async (controller) => {\n        const data = await this.#dataPromise;\n        const reader = new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(data));\n            controller.close();\n          },\n        }).getReader();\n        const pump = () =>\n          reader.read().then(({ done, value }): Promise<void> => {\n            if (done) {\n              controller.close();\n              return Promise.resolve();\n            }\n            controller.enqueue(value);\n            return pump();\n          });\n        return pump();\n      },\n    });\n  }\n\n  override get type() {\n    return this.#type;\n  }\n}\n\nexport interface ClosableFile extends File {\n  open(): Promise<this>;\n  close(): Promise<void>;\n}\n\nexport class NativeFile extends File implements ClosableFile {\n  #handle: FileHandle | null = null;\n  #fp: string;\n  #name: string;\n  #baseDir: BaseDirectory | null;\n  #lastModified: number = 0;\n  #size: number = -1;\n  #type: string = '';\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 1024;\n  static MAX_CACHE_ITEMS_SIZE = 50;\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map();\n  #pendingReads: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  constructor(fp: string, name?: string, baseDir: BaseDirectory | null = null, type = '') {\n    super([], name || fp, { type });\n    this.#fp = fp;\n    this.#baseDir = baseDir;\n    this.#name = name || fp;\n  }\n\n  async open() {\n    this.#handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    const stats = await this.#handle.stat();\n    this.#size = stats.size;\n    this.#lastModified = stats.mtime ? stats.mtime.getTime() : Date.now();\n    return this;\n  }\n\n  async close() {\n    if (this.#handle) {\n      await this.#handle.close();\n      this.#handle = null;\n    }\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async stat() {\n    return this.#handle?.stat();\n  }\n\n  async seek(offset: number, whence: SeekMode): Promise<number> {\n    if (!this.#handle) {\n      throw new Error('File handle is not open');\n    }\n    return this.#handle.seek(offset, whence);\n  }\n\n  // exclusive reading of the end: [start, end)\n  async readData(start: number, end: number): Promise<ArrayBuffer> {\n    start = Math.max(0, start);\n    end = Math.max(start, Math.min(this.size, end));\n    const size = end - start;\n\n    if (size > NativeFile.MAX_CACHE_CHUNK_SIZE) {\n      const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n      try {\n        await handle.seek(start, SeekMode.Start);\n        const buffer = new Uint8Array(size);\n        await handle.read(buffer);\n        return buffer.buffer;\n      } finally {\n        await handle.close();\n      }\n    }\n\n    const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n      const buffer = this.#cache.get(chunkStart)!;\n      return start >= chunkStart && end <= chunkStart + buffer.byteLength;\n    });\n\n    if (cachedChunkStart !== undefined) {\n      this.#updateAccessOrder(cachedChunkStart);\n      const buffer = this.#cache.get(cachedChunkStart)!;\n      const offset = start - cachedChunkStart;\n      return buffer.slice(offset, offset + size);\n    }\n\n    const readKey = `${start}-${end}`;\n    const pendingRead = this.#pendingReads.get(readKey);\n\n    if (pendingRead) {\n      return pendingRead;\n    }\n\n    const readPromise = this.#readAndCacheChunkSafe(start, size);\n    this.#pendingReads.set(readKey, readPromise);\n\n    try {\n      return await readPromise;\n    } finally {\n      this.#pendingReads.delete(readKey);\n    }\n  }\n\n  async #readAndCacheChunkSafe(start: number, size: number): Promise<ArrayBuffer> {\n    const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    try {\n      const chunkStart = Math.max(0, start - 1024);\n      const chunkEnd = Math.min(this.size, start + NativeFile.MAX_CACHE_CHUNK_SIZE);\n      const chunkSize = chunkEnd - chunkStart;\n\n      await handle.seek(chunkStart, SeekMode.Start);\n      const buffer = new Uint8Array(chunkSize);\n      await handle.read(buffer);\n\n      // Only one thread reaches here per unique range\n      this.#cache.set(chunkStart, buffer.buffer);\n      this.#updateAccessOrder(chunkStart);\n      this.#ensureCacheSize();\n\n      const offset = start - chunkStart;\n      return buffer.buffer.slice(offset, offset + size);\n    } finally {\n      await handle.close();\n    }\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > NativeFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.readData(start, end);\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override stream(): ReadableStream<Uint8Array<ArrayBuffer>> {\n    const CHUNK_SIZE = 1024 * 1024;\n    let offset = 0;\n\n    return new ReadableStream<Uint8Array<ArrayBuffer>>({\n      pull: async (controller) => {\n        if (!this.#handle) {\n          controller.error(new Error('File handle is not open'));\n          return;\n        }\n\n        if (offset >= this.size) {\n          controller.close();\n          return;\n        }\n\n        const end = Math.min(offset + CHUNK_SIZE, this.size);\n        const buffer = new Uint8Array(end - offset);\n\n        await this.#handle.seek(offset, SeekMode.Start);\n        const bytesRead = await this.#handle.read(buffer);\n\n        if (bytesRead === null || bytesRead === 0) {\n          controller.close();\n          return;\n        }\n\n        controller.enqueue(buffer.subarray(0, bytesRead));\n        offset += bytesRead;\n      },\n\n      cancel: async () => {\n        await this.#handle?.close();\n      },\n    });\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n\nexport class RemoteFile extends File implements ClosableFile {\n  url: string;\n  #name: string;\n  #lastModified: number;\n  #size: number = -1;\n  #type: string = '';\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map(); // LRU cache\n  #pendingFetches: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 128;\n  static MAX_CACHE_ITEMS_SIZE: number = 128;\n\n  constructor(url: string, name?: string, type = '', lastModified = Date.now()) {\n    const basename = url.split('/').pop() || 'remote-file';\n    super([], name || basename, { type, lastModified });\n    this.url = url;\n    this.#name = name || basename;\n    this.#type = type;\n    this.#lastModified = lastModified;\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async _open_with_head() {\n    const response = await fetch(this.url, { method: 'HEAD' });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-length'));\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async _open_with_range() {\n    const response = await fetch(this.url, { headers: { Range: `bytes=${0}-${1023}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-range')?.split('/')[1]);\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async open() {\n    // FIXME: currently HEAD request in asset protocol is not supported on Android\n    if (getOSPlatform() === 'android') {\n      return this._open_with_range();\n    } else {\n      return this._open_with_head();\n    }\n  }\n\n  async close(): Promise<void> {\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  async fetchRangePart(start: number, end: number) {\n    start = Math.max(0, start);\n    end = Math.min(this.size - 1, end);\n    // console.log(`Fetching range: ${start}-${end}, size: ${end - start + 1}`);\n    const response = await fetch(this.url, { headers: { Range: `bytes=${start}-${end}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch range: ${response.status}`);\n    }\n    return response.arrayBuffer();\n  }\n\n  // inclusive reading of the end: [start, end]\n  async fetchRange(start: number, end: number): Promise<ArrayBuffer> {\n    const rangeSize = end - start + 1;\n    const MAX_RANGE_LEN = 1024 * 1000;\n\n    if (rangeSize > MAX_RANGE_LEN) {\n      const buffers: ArrayBuffer[] = [];\n      for (let currentStart = start; currentStart <= end; currentStart += MAX_RANGE_LEN) {\n        const currentEnd = Math.min(currentStart + MAX_RANGE_LEN - 1, end);\n        buffers.push(await this.fetchRangePart(currentStart, currentEnd));\n      }\n      const totalSize = buffers.reduce((sum, buffer) => sum + buffer.byteLength, 0);\n      const combinedBuffer = new Uint8Array(totalSize);\n      let offset = 0;\n      for (const buffer of buffers) {\n        combinedBuffer.set(new Uint8Array(buffer), offset);\n        offset += buffer.byteLength;\n      }\n      return combinedBuffer.buffer;\n    } else if (rangeSize > RemoteFile.MAX_CACHE_CHUNK_SIZE) {\n      return this.fetchRangePart(start, end);\n    } else {\n      const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n        const buffer = this.#cache.get(chunkStart)!;\n        const bufferSize = buffer.byteLength;\n        return start >= chunkStart && end <= chunkStart + bufferSize;\n      });\n      if (cachedChunkStart !== undefined) {\n        this.#updateAccessOrder(cachedChunkStart);\n        const buffer = this.#cache.get(cachedChunkStart)!;\n        const offset = start - cachedChunkStart;\n        return buffer.slice(offset, offset + rangeSize);\n      }\n\n      const fetchKey = `${start}-${end}`;\n      const pendingFetch = this.#pendingFetches.get(fetchKey);\n\n      if (pendingFetch) {\n        return pendingFetch;\n      }\n\n      const fetchPromise = this.#fetchAndCacheChunkSafe(start, end, rangeSize);\n      this.#pendingFetches.set(fetchKey, fetchPromise);\n      try {\n        return await fetchPromise;\n      } finally {\n        this.#pendingFetches.delete(fetchKey);\n      }\n    }\n  }\n\n  async #fetchAndCacheChunkSafe(\n    start: number,\n    end: number,\n    rangeSize: number,\n  ): Promise<ArrayBuffer> {\n    const chunkStart = Math.max(0, start - 1024);\n    const chunkEnd = Math.max(end, start + RemoteFile.MAX_CACHE_CHUNK_SIZE - 1024 - 1);\n    const buffer = await this.fetchRangePart(chunkStart, chunkEnd);\n\n    // Only one thread reaches here per unique range\n    this.#cache.set(chunkStart, buffer);\n    this.#updateAccessOrder(chunkStart);\n    this.#ensureCacheSize();\n\n    const offset = start - chunkStart;\n    return buffer.slice(offset, offset + rangeSize);\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > RemoteFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.fetchRange(start, end - 1);\n\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n","import { randomUUID } from 'crypto';\nexport default { randomUUID };\n","import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n","import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { v4 as uuidv4 } from 'uuid';\nimport { SystemSettings } from '@/types/settings';\nimport {\n  AppPlatform,\n  AppService,\n  DistChannel,\n  FileItem,\n  OsPlatform,\n  ResolvedPath,\n  SelectDirectoryMode,\n} from '@/types/system';\nimport { FileSystem, BaseDir, DeleteAction } from '@/types/system';\nimport {\n  Book,\n  BookConfig,\n  BookContent,\n  BookFormat,\n  FIXED_LAYOUT_FORMATS,\n  ViewSettings,\n} from '@/types/book';\nimport {\n  getDir,\n  getLocalBookFilename,\n  getCoverFilename,\n  getConfigFilename,\n  getLibraryFilename,\n  INIT_BOOK_CONFIG,\n  formatTitle,\n  formatAuthors,\n  getPrimaryLanguage,\n  getLibraryBackupFilename,\n} from '@/utils/book';\nimport { md5, partialMD5, md5Fingerprint } from '@/utils/md5';\nimport { getBaseFilename, getFilename } from '@/utils/path';\nimport { BookDoc, DocumentLoader, EXTS } from '@/libs/document';\nimport {\n  DEFAULT_BOOK_LAYOUT,\n  DEFAULT_BOOK_STYLE,\n  DEFAULT_BOOK_FONT,\n  DEFAULT_BOOK_LANGUAGE,\n  DEFAULT_VIEW_CONFIG,\n  DEFAULT_READSETTINGS,\n  SYSTEM_SETTINGS_VERSION,\n  DEFAULT_BOOK_SEARCH_CONFIG,\n  DEFAULT_TTS_CONFIG,\n  DEFAULT_MOBILE_VIEW_SETTINGS,\n  DEFAULT_SYSTEM_SETTINGS,\n  DEFAULT_CJK_VIEW_SETTINGS,\n  DEFAULT_MOBILE_READSETTINGS,\n  DEFAULT_SCREEN_CONFIG,\n  DEFAULT_TRANSLATOR_CONFIG,\n  DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS,\n  SETTINGS_FILENAME,\n  DEFAULT_MOBILE_SYSTEM_SETTINGS,\n  DEFAULT_ANNOTATOR_CONFIG,\n  DEFAULT_EINK_VIEW_SETTINGS,\n} from './constants';\nimport { cachedFetchAsUrl } from '@/utils/cachedFetch';\nimport { fetch as tauriFetch } from '@tauri-apps/plugin-http';\nimport {\n  getOSPlatform,\n  getTargetLang,\n  isCJKEnv,\n  isContentURI,\n  isValidURL,\n  makeSafeFilename,\n} from '@/utils/misc';\nimport { deserializeConfig, serializeConfig } from '@/utils/serializer';\nimport { ClosableFile } from '@/utils/file';\nimport { TxtToEpubConverter } from '@/utils/txt';\nimport { BOOK_FILE_NOT_FOUND_ERROR } from './errors';\nimport { CustomTextureInfo } from '@/styles/textures';\nimport { CustomFont, CustomFontInfo } from '@/styles/fonts';\nimport { parseFontInfo } from '@/utils/font';\nimport { svg2png } from '@/utils/svg';\n\nexport abstract class BaseAppService implements AppService {\n  osPlatform: OsPlatform = getOSPlatform();\n  appPlatform: AppPlatform = 'tauri';\n  localBooksDir = '';\n  isMobile = false;\n  isMacOSApp = false;\n  isLinuxApp = false;\n  isAppDataSandbox = false;\n  isAndroidApp = false;\n  isIOSApp = false;\n  isMobileApp = false;\n  isPortableApp = false;\n  isDesktopApp = false;\n  isEink = false;\n  hasTrafficLight = false;\n  hasWindow = false;\n  hasWindowBar = false;\n  hasContextMenu = false;\n  hasRoundedWindow = false;\n  hasSafeAreaInset = false;\n  hasHaptics = false;\n  hasUpdater = false;\n  hasOrientationLock = false;\n  hasScreenBrightness = false;\n  hasIAP = false;\n  canCustomizeRootDir = false;\n  canReadExternalDir = false;\n  distChannel = 'readest' as DistChannel;\n\n  protected CURRENT_MIGRATION_VERSION = 20260121;\n\n  protected abstract fs: FileSystem;\n  protected abstract resolvePath(fp: string, base: BaseDir): ResolvedPath;\n\n  abstract init(): Promise<void>;\n  abstract setCustomRootDir(customRootDir: string): Promise<void>;\n  abstract selectDirectory(mode: SelectDirectoryMode): Promise<string>;\n  abstract selectFiles(name: string, extensions: string[]): Promise<string[]>;\n  abstract saveFile(\n    filename: string,\n    content: string | ArrayBuffer,\n    filepath: string,\n    mimeType?: string,\n  ): Promise<boolean>;\n\n  protected async runMigrations(lastMigrationVersion: number): Promise<void> {\n    if (lastMigrationVersion < 20251124) {\n      try {\n        await this.migrate20251124();\n      } catch (error) {\n        console.error('Error migrating to version 20251124:', error);\n      }\n    }\n\n    if (lastMigrationVersion < 20260121) {\n      try {\n        await this.migrate20260121();\n      } catch (error) {\n        console.error('Error migrating to version 20260121:', error);\n      }\n    }\n  }\n\n  async prepareBooksDir() {\n    this.localBooksDir = await this.fs.getPrefix('Books');\n    // Initialize configuration files in .readest directory\n    await this.ensureConfigFilesExist();\n  }\n\n  /**\n   * Ensure settings.json and library.json exist in .readest directory\n   * If they don't exist, create them with default values\n   */\n  private async ensureConfigFilesExist(): Promise<void> {\n    try {\n      // Check and create settings.json if needed\n      const settingsExists = await this.fs.exists(SETTINGS_FILENAME, 'Settings');\n      if (!settingsExists) {\n        console.log('[Init] settings.json not found, creating with defaults...');\n        const defaultSettings = {\n          ...DEFAULT_SYSTEM_SETTINGS,\n          ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n          version: SYSTEM_SETTINGS_VERSION,\n          localBooksDir: await this.fs.getPrefix('Books'),\n          globalReadSettings: {\n            ...DEFAULT_READSETTINGS,\n            ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n          },\n          globalViewSettings: this.getDefaultViewSettings(),\n        } as SystemSettings;\n        await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', defaultSettings);\n        console.log('[Init]  settings.json created successfully');\n      }\n\n      // Check and create library.json if needed\n      const libraryFilename = getLibraryFilename();\n      const libraryExists = await this.fs.exists(libraryFilename, 'Books');\n      if (!libraryExists) {\n        console.log('[Init] library.json not found, creating with defaults...');\n        await this.safeSaveJSON(libraryFilename, 'Books', []);\n        console.log('[Init]  library.json created successfully');\n      }\n\n      console.log('[Init]  All configuration files are ready');\n    } catch (error) {\n      console.error('[Init] Error ensuring config files exist:', error);\n      // Don't throw, continue with defaults\n    }\n  }\n\n  async openFile(path: string, base: BaseDir): Promise<File> {\n    return await this.fs.openFile(path, base);\n  }\n\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir): Promise<void> {\n    return await this.fs.copyFile(srcPath, dstPath, base);\n  }\n\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    return await this.fs.readFile(path, base, mode);\n  }\n\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    return await this.fs.writeFile(path, base, content);\n  }\n\n  async createDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.createDir(path, base, recursive);\n  }\n\n  async deleteFile(path: string, base: BaseDir): Promise<void> {\n    return await this.fs.removeFile(path, base);\n  }\n\n  async deleteDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.removeDir(path, base, recursive);\n  }\n\n  async resolveFilePath(path: string, base: BaseDir): Promise<string> {\n    const prefix = await this.fs.getPrefix(base);\n    return path ? `${prefix}/${path}` : prefix;\n  }\n\n  async readDirectory(path: string, base: BaseDir): Promise<FileItem[]> {\n    return await this.fs.readDir(path, base);\n  }\n\n  async exists(path: string, base: BaseDir): Promise<boolean> {\n    return await this.fs.exists(path, base);\n  }\n\n  async getImageURL(path: string): Promise<string> {\n    return await this.fs.getImageURL(path);\n  }\n\n  getCoverImageUrl = (book: Book): string => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n    const resolvedPath = this.fs.resolvePath(coverPath, 'Books');\n    return this.fs.getURL(resolvedPath.fp) || `${this.localBooksDir}/${coverPath}`;\n  };\n\n  getCoverImageBlobUrl = async (book: Book): Promise<string> => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n\n    //  web  Blob URL\n    if (this.appPlatform === 'web') {\n      try {\n        const coverUrl = this.fs.getURL(this.fs.resolvePath(coverPath, 'Books').fp) ||\n          `${this.localBooksDir}/${coverPath}`;\n\n        //  Blob URL 30 \n        return await cachedFetchAsUrl(coverUrl, {\n          cacheStrategy: 'cache-first',\n          cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n        }).catch(() => {\n          // \n          return `${this.localBooksDir}/${coverPath}`;\n        });\n      } catch {\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    } else {\n      try {\n        return await this.fs.getBlobURL(coverPath, 'Books');\n      } catch {\n        // Fallback to old path if the new path doesn't exist\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    }\n  };\n\n  async getCachedImageUrl(pathOrUrl: string): Promise<string> {\n    const cachedKey = `img_${md5(pathOrUrl)}`;\n    const cachePrefix = await this.fs.getPrefix('Cache');\n    const cachedPath = `${cachePrefix}/${cachedKey}`;\n    if (await this.fs.exists(cachedPath, 'None')) {\n      return await this.fs.getImageURL(cachedPath);\n    } else {\n      const file = await this.fs.openFile(pathOrUrl, 'None');\n      await this.fs.writeFile(cachedKey, 'Cache', await file.arrayBuffer());\n      return await this.fs.getImageURL(cachedPath);\n    }\n  }\n\n  getDefaultViewSettings(): ViewSettings {\n    return {\n      ...DEFAULT_BOOK_LAYOUT,\n      ...DEFAULT_BOOK_STYLE,\n      ...DEFAULT_BOOK_FONT,\n      ...DEFAULT_BOOK_LANGUAGE,\n      ...(this.isMobile ? DEFAULT_MOBILE_VIEW_SETTINGS : {}),\n      ...(this.isEink ? DEFAULT_EINK_VIEW_SETTINGS : {}),\n      ...(isCJKEnv() ? DEFAULT_CJK_VIEW_SETTINGS : {}),\n      ...DEFAULT_VIEW_CONFIG,\n      ...DEFAULT_TTS_CONFIG,\n      ...DEFAULT_SCREEN_CONFIG,\n      ...DEFAULT_ANNOTATOR_CONFIG,\n      ...{ ...DEFAULT_TRANSLATOR_CONFIG, translateTargetLang: getTargetLang() },\n    };\n  }\n\n  async loadSettings(): Promise<SystemSettings> {\n    const defaultSettings: SystemSettings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      version: SYSTEM_SETTINGS_VERSION,\n      localBooksDir: await this.fs.getPrefix('Books'),\n      koreaderSyncDeviceId: uuidv4(),\n      globalReadSettings: {\n        ...DEFAULT_READSETTINGS,\n        ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      },\n      globalViewSettings: this.getDefaultViewSettings(),\n    } as SystemSettings;\n\n    let settings = await this.safeLoadJSON<SystemSettings>(\n      SETTINGS_FILENAME,\n      'Settings',\n      defaultSettings,\n    );\n\n    const version = settings.version ?? 0;\n    if (this.isAppDataSandbox || version < SYSTEM_SETTINGS_VERSION) {\n      settings.version = SYSTEM_SETTINGS_VERSION;\n    }\n    settings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      ...settings,\n    };\n    settings.globalReadSettings = {\n      ...DEFAULT_READSETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      ...settings.globalReadSettings,\n    };\n    settings.globalViewSettings = {\n      ...this.getDefaultViewSettings(),\n      ...settings.globalViewSettings,\n    };\n\n    settings.localBooksDir = await this.fs.getPrefix('Books');\n\n    if (!settings.kosync.deviceId) {\n      settings.kosync.deviceId = uuidv4();\n      await this.saveSettings(settings);\n    }\n\n    this.localBooksDir = settings.localBooksDir;\n    return settings;\n  }\n\n  async saveSettings(settings: SystemSettings): Promise<void> {\n    await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', settings);\n  }\n\n  async importFont(file?: string | File): Promise<CustomFontInfo | null> {\n    let fontPath: string;\n    let fontFile: File;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      fontPath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, fontPath, 'Fonts');\n      fontFile = await this.fs.openFile(fontPath, 'Fonts');\n    } else if (file) {\n      fontPath = getFilename(file.name);\n      await this.fs.writeFile(fontPath, 'Fonts', file);\n      fontFile = file;\n    } else {\n      return null;\n    }\n\n    return {\n      path: fontPath,\n      ...parseFontInfo(await fontFile.arrayBuffer(), fontPath),\n    };\n  }\n\n  async deleteFont(font: CustomFont): Promise<void> {\n    await this.fs.removeFile(font.path, 'Fonts');\n  }\n\n  async importImage(file?: string | File): Promise<CustomTextureInfo | null> {\n    let imagePath: string;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      imagePath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, imagePath, 'Images');\n    } else if (file) {\n      imagePath = getFilename(file.name);\n      await this.fs.writeFile(imagePath, 'Images', file);\n    } else {\n      return null;\n    }\n\n    return {\n      name: imagePath.replace(/\\.[^/.]+$/, ''),\n      path: imagePath,\n    };\n  }\n\n  async deleteImage(texture: CustomTextureInfo): Promise<void> {\n    await this.fs.removeFile(texture.path, 'Images');\n  }\n\n  async importBook(\n    // file might be:\n    // 1.1 absolute path for local file on Desktop\n    // 1.2 /private/var inbox file path on iOS\n    // 2. remote url\n    // 3. content provider uri\n    // 4. File object from browsers\n    file: string | File,\n    books: Book[],\n    saveBook: boolean = true,\n    saveCover: boolean = true,\n    overwrite: boolean = false,\n    transient: boolean = false,\n    options?: {\n      /** Desired relative path (e.g. \"/.epub\"), only used in local mode */\n      targetRelativePath?: string;\n      /** Desired group name, used to derive path when targetRelativePath is not provided */\n      targetGroupName?: string;\n    },\n  ): Promise<Book | null> {\n    const startTime = Date.now();\n    let filename = '';\n\n    try {\n      let loadedBook: BookDoc;\n      let format: BookFormat;\n      let fileobj: File;\n\n      if (transient && typeof file !== 'string') {\n        throw new Error('Transient import is only supported for file paths');\n      }\n\n      try {\n        if (typeof file === 'string') {\n          fileobj = await this.fs.openFile(file, 'None');\n          filename = fileobj.name || getFilename(file);\n        } else {\n          fileobj = file;\n          filename = file.name;\n        }\n\n        // \n        const fileSizeMB = fileobj.size / (1024 * 1024);\n        console.log(`[importBook] Processing: ${filename}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // \n        if (fileobj.size === 0) {\n          throw new Error('Invalid or empty book file');\n        }\n\n        // \n        if (fileobj.size > 100 * 1024 * 1024) {\n          console.warn(`[importBook]  Large file: ${fileSizeMB.toFixed(2)} MB, processing may take longer`);\n        }\n\n        if (/\\.txt$/i.test(filename)) {\n          const txt2epub = new TxtToEpubConverter();\n          ({ file: fileobj } = await txt2epub.convert({ file: fileobj }));\n        }\n\n        console.log(`[importBook] Opening document: ${filename}`);\n        ({ book: loadedBook, format } = await new DocumentLoader(fileobj).open());\n\n        if (!loadedBook) {\n          throw new Error('Unsupported or corrupted book file');\n        }\n        const metadataTitle = formatTitle(loadedBook.metadata.title);\n        if (!metadataTitle || !metadataTitle.trim() || metadataTitle === filename) {\n          loadedBook.metadata.title = getBaseFilename(filename);\n        }\n\n        console.log(`[importBook]  Document opened successfully: ${filename}`);\n      } catch (error) {\n        const errorMsg = (error as Error).message || String(error);\n        console.error(`[importBook]  Failed to open book: ${filename}`, errorMsg);\n        throw new Error(`Failed to open the book: ${errorMsg}`);\n      }\n\n      console.log(`[importBook] Computing hash for: ${filename}`);\n      const hash = await partialMD5(fileobj);\n      const existingBook = books.filter((b) => b.hash === hash)[0];\n      const now = Date.now();\n      if (existingBook) {\n        if (!transient) {\n          existingBook.deletedAt = null;\n        }\n        existingBook.createdAt = now;\n        existingBook.updatedAt = now;\n      }\n\n      const primaryLanguage = getPrimaryLanguage(loadedBook.metadata.language);\n      const book: Book = {\n        hash,\n        format,\n        title: formatTitle(loadedBook.metadata.title),\n        sourceTitle: formatTitle(loadedBook.metadata.title),\n        primaryLanguage,\n        author: formatAuthors(loadedBook.metadata.author, primaryLanguage),\n        createdAt: existingBook ? existingBook.createdAt : now,\n        uploadedAt: existingBook ? existingBook.uploadedAt : (transient ? null : now),\n        deletedAt: transient ? now : null,\n        downloadedAt: now,\n        updatedAt: now,\n      };\n      // update book metadata when reimporting the same book\n      if (existingBook) {\n        existingBook.format = book.format;\n        existingBook.title = existingBook.title.trim() ? existingBook.title.trim() : book.title;\n        existingBook.sourceTitle = existingBook.sourceTitle ?? book.sourceTitle;\n        existingBook.author = existingBook.author ?? book.author;\n        existingBook.primaryLanguage = existingBook.primaryLanguage ?? book.primaryLanguage;\n        existingBook.downloadedAt = Date.now();\n      }\n\n      // Decide whether to use new flat local storage path\n      // Check runtime window.__STORAGE_MODE__ first (set by Providers), then fallback to compile-time env var\n      const isLocalStorageMode =\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') ||\n        process.env['NEXT_PUBLIC_STORAGE_MODE'] === 'local';\n      const shouldUseLocalFlatStorage = this.appPlatform === 'web' && isLocalStorageMode;\n\n      console.log('[ImportBook] appPlatform:', this.appPlatform, 'STORAGE_MODE (runtime):', (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__), 'STORAGE_MODE (env):', process.env['NEXT_PUBLIC_STORAGE_MODE'], 'shouldUseLocalFlatStorage:', shouldUseLocalFlatStorage);\n\n      const fileExt = EXTS[format] || format.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title);\n      const targetGroupName = options?.targetGroupName?.trim();\n\n      // Compute target relative path for local mode\n      if (shouldUseLocalFlatStorage) {\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n\n        if (!derivedRelativePath) {\n          throw new Error('targetRelativePath is required for local storage mode. Please provide a valid relative path.');\n        }\n\n        book.relativePath = derivedRelativePath;\n        console.log('[ImportBook] 5. Setting book.relativePath to:', derivedRelativePath);\n        console.log('[ImportBook] 6. Book hash:', book.hash);\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n        if (targetGroupName && !book.groupName) {\n          book.groupName = targetGroupName;\n          if (existingBook && !existingBook.groupName) {\n            existingBook.groupName = targetGroupName;\n          }\n        }\n      } else if (this.appPlatform === 'web') {\n        // For web platform in remote mode, still require relativePath for consistency\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n        book.relativePath = derivedRelativePath;\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n      }\n\n      // Ensure destination directories exist (new flat structure or legacy hash-based)\n      await this.ensureLocalBookDirs(book);\n\n      const bookFilename = getLocalBookFilename(book);\n      if (saveBook && !transient && (!(await this.fs.exists(bookFilename, 'Books')) || overwrite)) {\n        if (/\\.txt$/i.test(filename)) {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        } else if (typeof file === 'string' && isContentURI(file)) {\n          await this.fs.copyFile(file, bookFilename, 'Books');\n        } else if (typeof file === 'string' && !isValidURL(file)) {\n          try {\n            // try to copy the file directly first in case of large files to avoid memory issues\n            // on desktop when reading recursively from selected directory the direct copy will fail\n            // due to permission issues, then fallback to read and write files\n            await this.fs.copyFile(file, bookFilename, 'Books');\n          } catch {\n            await this.fs.writeFile(bookFilename, 'Books', await fileobj.arrayBuffer());\n          }\n        } else {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        }\n      }\n      if (saveCover && (!(await this.fs.exists(getCoverFilename(book), 'Books')) || overwrite)) {\n        console.log('[ImportBook] 7. Preparing to save cover');\n        let cover = await loadedBook.getCover();\n        if (cover?.type === 'image/svg+xml') {\n          try {\n            console.log('[ImportBook] Converting SVG cover to PNG...');\n            cover = await svg2png(cover);\n          } catch { }\n        }\n        if (cover) {\n          const coverFilename = getCoverFilename(book);\n          console.log('[ImportBook] 8. Saving cover with filename:', coverFilename);\n          console.log('[ImportBook] 9. Cover size:', cover.size, 'bytes');\n          await this.fs.writeFile(coverFilename, 'Books', await cover.arrayBuffer());\n          console.log('[ImportBook] 10. Cover saved successfully');\n        }\n      }\n      // Never overwrite the config file only when it's not existed\n      if (!existingBook) {\n        await this.saveBookConfig(book, INIT_BOOK_CONFIG);\n        books.splice(0, 0, book);\n      }\n\n      // update file links with url or path or content uri\n      if (typeof file === 'string') {\n        if (isValidURL(file)) {\n          book.url = file;\n          if (existingBook) existingBook.url = file;\n        }\n        if (transient) {\n          book.filePath = file;\n          if (existingBook) existingBook.filePath = file;\n        }\n      }\n      book.coverImageUrl = await this.generateCoverImageUrl(book);\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n\n      const elapsed = Date.now() - startTime;\n      console.log(`[importBook]  Import completed in ${elapsed}ms: ${filename}`);\n\n      return existingBook || book;\n    } catch (error) {\n      const elapsed = Date.now() - startTime;\n      const errorMsg = (error as Error).message || String(error);\n      const errorStack = (error as Error).stack;\n\n      console.error(`[importBook]  Import failed after ${elapsed}ms`);\n      console.error(`[importBook] File: ${filename || (typeof file === 'string' ? file : 'unknown')}`);\n      console.error(`[importBook] Error: ${errorMsg}`);\n      if (errorStack) {\n        console.error(`[importBook] Stack trace:`, errorStack);\n      }\n\n      // \n      if (errorMsg.includes('memory') || errorMsg.includes('ENOMEM')) {\n        throw new Error(`${errorMsg}`);\n      }\n\n      // \n      if (errorMsg.includes('too large') || errorMsg.includes('Maximum size')) {\n        throw error;\n      }\n\n      throw error;\n    }\n  }\n\n  async importBookFromPath(\n    filePath: string,\n    relativePath: string,\n    books: Book[],\n  ): Promise<Book | null> {\n    try {\n      // Extract directory structure for grouping\n      const directory = relativePath.split('/').slice(0, -1).join('/');\n      const groupName = directory || '';\n\n      // Import the book as transient (don't copy, just reference)\n      const book = await this.importBook(\n        filePath,\n        books,\n        false, // saveBook = false\n        true,  // saveCover = true\n        false, // overwrite = false\n        true,  // transient = true\n        {\n          targetRelativePath: relativePath,\n          targetGroupName: groupName,\n        },\n      );\n\n      return book;\n    } catch (error) {\n      console.error('Error importing book from path:', filePath, error);\n      return null;\n    }\n  }\n\n  /**\n   *  - \n   * \n   */\n  async reclassifyBook(book: Book, newGroupName: string, oldGroupName?: string): Promise<void> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reclassify] ');\n      return;\n    }\n\n    //  relativePath hash-based \n    if (!book.relativePath) {\n      console.log('[Reclassify] :', book.title);\n      return;\n    }\n\n    try {\n      // \n      const settings = await this.loadSettings();\n      const groupDirectories = settings.groupDirectories || {};\n\n      //  relativePath \n      const oldRelativePath = book.relativePath;\n\n      // \n      let filename: string;\n      if (oldGroupName && oldRelativePath.startsWith(`${oldGroupName}/`)) {\n        // \n        filename = oldRelativePath.substring(oldGroupName.length + 1);\n      } else {\n        // relativePath \n        // \n        const parts = oldRelativePath.split('/');\n        filename = parts[parts.length - 1] || '';\n      }\n\n      // \n      // 1.  groupDirectories \n      // 2. \n      let targetDirectory: string;\n      if (newGroupName && groupDirectories[newGroupName]) {\n        targetDirectory = groupDirectories[newGroupName];\n      } else if (newGroupName) {\n        targetDirectory = newGroupName;\n      } else {\n        targetDirectory = '';\n      }\n\n      const newRelativePath = targetDirectory\n        ? `${targetDirectory}/${filename}`\n        : filename;\n\n      // \n      if (oldRelativePath === newRelativePath) {\n        console.log('[Reclassify] ');\n        return;\n      }\n\n      console.log('[Reclassify] ');\n      console.log('  :', oldRelativePath);\n      console.log('  :', newRelativePath);\n      console.log('  :', filename);\n      console.log('  :', newGroupName);\n      console.log('  :', targetDirectory);\n\n      //  API \n      const response = await fetch('/api/storage/reclassify', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          oldPath: oldRelativePath,\n          newPath: newRelativePath,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reclassify] :', error);\n        throw new Error(`Failed to move book files: ${error}`);\n      }\n\n      const result = await response.json();\n\n      //  book \n      book.relativePath = newRelativePath;\n      book.groupName = newGroupName || undefined;\n      //  API \n      if (result.absolutePath) {\n        book.absolutePath = result.absolutePath;\n      }\n\n      console.log('[Reclassify] :', result);\n    } catch (error) {\n      console.error('[Reclassify] :', error);\n      throw error;\n    }\n  }\n\n  async deleteBook(book: Book, deleteAction: DeleteAction): Promise<void> {\n    console.log('Deleting book with action:', deleteAction, book.title);\n    if (deleteAction === 'local' || deleteAction === 'both') {\n      const localDeleteFps =\n        deleteAction === 'local'\n          ? [getLocalBookFilename(book)]\n          : [getLocalBookFilename(book), getCoverFilename(book)];\n      for (const fp of localDeleteFps) {\n        console.log('Deleting local file:', fp);\n        await this.fs.removeFile(fp, 'Books');\n      }\n      if (deleteAction === 'local') {\n        book.downloadedAt = null;\n      } else {\n        book.deletedAt = Date.now();\n        book.downloadedAt = null;\n        book.coverDownloadedAt = null;\n      }\n    }\n    // Cloud storage delete functionality removed - using local server storage only\n    if ((deleteAction === 'cloud' || deleteAction === 'both') && book.uploadedAt) {\n      console.log('Cloud delete operation skipped - cloud storage removed');\n      book.uploadedAt = null;\n    }\n  }\n\n  // Cloud storage methods removed - using local server storage only\n\n  async exportBook(book: Book): Promise<boolean> {\n    const { file } = await this.loadBookContent(book);\n    const content = await file.arrayBuffer();\n    const filename = `${makeSafeFilename(book.title)}.${book.format.toLowerCase()}`;\n    const filepath = await this.resolveFilePath(getLocalBookFilename(book), 'Books');\n    const fileType = file.type || 'application/octet-stream';\n    return await this.saveFile(filename, content, filepath, fileType);\n  }\n\n  async isBookAvailable(book: Book): Promise<boolean> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      return true;\n    }\n    if (book.filePath) {\n      return await this.fs.exists(book.filePath, 'None');\n    }\n    if (book.url) {\n      return isValidURL(book.url);\n    }\n    return false;\n  }\n\n  async getBookFileSize(book: Book): Promise<number | null> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      const file = await this.fs.openFile(fp, 'Books');\n      const size = file.size;\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n      return size;\n    }\n    return null;\n  }\n\n  async loadBookContent(book: Book): Promise<BookContent> {\n    let file: File;\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      file = await this.fs.openFile(fp, 'Books');\n    } else if (book.filePath) {\n      file = await this.fs.openFile(book.filePath, 'None');\n    } else if (book.url) {\n      file = await this.fs.openFile(book.url, 'None');\n    } else {\n      // 0.9.64 has a bug that book.title might be modified but the filename is not updated\n      const bookDir = getDir(book);\n      const files = await this.fs.readDir(getDir(book), 'Books');\n      if (files.length > 0) {\n        const bookFile = files.find((f) => f.path.endsWith(`.${EXTS[book.format]}`));\n        if (bookFile) {\n          file = await this.fs.openFile(`${bookDir}/${bookFile.path}`, 'Books');\n        } else {\n          throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n        }\n      } else {\n        throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n      }\n    }\n    return { book, file };\n  }\n\n  async loadBookConfig(book: Book, settings: SystemSettings): Promise<BookConfig> {\n    const globalViewSettings = {\n      ...settings.globalViewSettings,\n      ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n    };\n    try {\n      let str = '{}';\n      if (await this.fs.exists(getConfigFilename(book), 'Books')) {\n        str = (await this.fs.readFile(getConfigFilename(book), 'Books', 'text')) as string;\n      }\n      return deserializeConfig(str, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } catch {\n      return deserializeConfig('{}', globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    }\n  }\n\n  async fetchBookDetails(book: Book) {\n    const fp = getLocalBookFilename(book);\n    if (!(await this.fs.exists(fp, 'Books')) && book.uploadedAt) {\n      // Cloud download functionality removed - books should already be stored locally\n      console.warn('Book file not found locally and cloud download is disabled:', book.title);\n      throw new Error('Book file not found locally');\n    }\n    const { file } = await this.loadBookContent(book);\n    const bookDoc = (await new DocumentLoader(file).open()).book;\n    const f = file as ClosableFile;\n    if (f && f.close) {\n      await f.close();\n    }\n    return bookDoc.metadata;\n  }\n\n  async saveBookConfig(book: Book, config: BookConfig, settings?: SystemSettings) {\n    let serializedConfig: string;\n    if (settings) {\n      const globalViewSettings = {\n        ...settings.globalViewSettings,\n        ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n      };\n      serializedConfig = serializeConfig(config, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } else {\n      serializedConfig = JSON.stringify(config);\n    }\n    await this.fs.writeFile(getConfigFilename(book), 'Books', serializedConfig);\n  }\n\n  async generateCoverImageUrl(book: Book): Promise<string> {\n    return this.appPlatform === 'web'\n      ? await this.getCoverImageBlobUrl(book)\n      : this.getCoverImageUrl(book);\n  }\n\n  async loadLibraryBooks(): Promise<Book[]> {\n    console.log('Loading library books...');\n    const libraryFilename = getLibraryFilename();\n\n    if (!(await this.fs.exists('', 'Books'))) {\n      await this.fs.createDir('', 'Books', true);\n    }\n\n    const books = await this.safeLoadJSON<Book[]>(libraryFilename, 'Books', []);\n\n    await Promise.all(\n      books.map(async (book) => {\n        book.coverImageUrl = await this.generateCoverImageUrl(book);\n        book.updatedAt ??= book.lastUpdated || Date.now();\n        return book;\n      }),\n    );\n\n    return books;\n  }\n\n  async saveLibraryBooks(books: Book[]): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const libraryBooks = books.map(({ coverImageUrl, ...rest }) => rest);\n    await this.safeSaveJSON(getLibraryFilename(), 'Books', libraryBooks);\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async reconcileBookPaths(books: Book[]): Promise<any> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reconcile] ');\n      return { success: false, error: 'Not in local storage mode' };\n    }\n\n    try {\n      console.log('[Reconcile] ', books.length, '');\n\n      // \n      const libraryData = books\n        .filter(book => !book.deletedAt)\n        .map(book => ({\n          hash: book.hash,\n          relativePath: book.relativePath,\n          absolutePath: book.absolutePath,\n          title: book.title,\n          groupName: book.groupName,\n        }));\n\n      const response = await fetch('/api/storage/reconcile', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ library: libraryData }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reconcile] :', error);\n        throw new Error(`Failed to reconcile paths: ${error}`);\n      }\n\n      const result = await response.json();\n      console.log('[Reconcile] :', result.summary);\n      return result;\n    } catch (error) {\n      console.error('[Reconcile] :', error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async applyReconciliation(books: Book[], reconcileResults: any[]): Promise<Book[]> {\n    const updatedBooks = [...books];\n\n    for (const result of reconcileResults) {\n      if (result.status === 'moved') {\n        // \n        const bookIndex = updatedBooks.findIndex(b => b.hash === result.hash);\n        if (bookIndex !== -1) {\n          const book = updatedBooks[bookIndex];\n          if (book) {\n            book.relativePath = result.newRelativePath;\n            book.absolutePath = result.absolutePath;\n            if (result.suggestedGroupName !== undefined) {\n              book.groupName = result.suggestedGroupName;\n              //  groupId\n              book.groupId = result.suggestedGroupName\n                ? md5Fingerprint(result.suggestedGroupName)\n                : '';\n            }\n            book.updatedAt = Date.now();\n            console.log('[Reconcile] :', book.title, ':', book.relativePath);\n          }\n        }\n      }\n    }\n\n    await this.saveLibraryBooks(updatedBooks);\n    return updatedBooks;\n  }\n\n  private imageToArrayBuffer(imageUrl?: string, imageFile?: string): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      if (!imageUrl && !imageFile) {\n        reject(new Error('No image URL or file provided'));\n        return;\n      }\n      if (this.appPlatform === 'web' && imageUrl && imageUrl.startsWith('blob:')) {\n        fetch(imageUrl)\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageFile) {\n        this.fs\n          .openFile(imageFile, 'None')\n          .then((file) => file.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageUrl) {\n        tauriFetch(imageUrl, { method: 'GET' })\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else {\n        reject(new Error('Unsupported platform or missing image data'));\n      }\n    });\n  }\n\n  async updateCoverImage(book: Book, imageUrl?: string, imageFile?: string): Promise<void> {\n    if (imageUrl === '_blank') {\n      await this.fs.removeFile(getCoverFilename(book), 'Books');\n    } else if (imageUrl || imageFile) {\n      const arrayBuffer = await this.imageToArrayBuffer(imageUrl, imageFile);\n      await this.fs.writeFile(getCoverFilename(book), 'Books', arrayBuffer);\n    }\n  }\n\n  private async loadJSONFile(\n    path: string,\n    base: BaseDir,\n  ): Promise<{ success: boolean; data?: unknown; error?: unknown }> {\n    try {\n      const txt = await this.fs.readFile(path, base, 'text');\n      if (!txt || typeof txt !== 'string' || txt.trim().length === 0) {\n        return { success: false, error: 'File is empty or invalid' };\n      }\n      try {\n        const data = JSON.parse(txt as string);\n        return { success: true, data };\n      } catch (parseError) {\n        return { success: false, error: `JSON parse error: ${parseError}` };\n      }\n    } catch (error) {\n      return { success: false, error };\n    }\n  }\n\n  /**\n   * Safely loads a JSON file with automatic backup fallback.\n   * If the main file is corrupted, attempts to load from backup.\n   * @param filename - The name of the file to load (without .bak extension)\n   * @param base - The base directory\n   * @param defaultValue - Default value to return if both files fail\n   */\n  private async safeLoadJSON<T>(filename: string, base: BaseDir, defaultValue: T): Promise<T> {\n    const backupFilename = `${filename}.bak`;\n\n    // Try loading main file\n    const mainResult = await this.loadJSONFile(filename, base);\n    if (mainResult.success) {\n      return mainResult.data as T;\n    }\n\n    console.warn(`Failed to load ${filename}, attempting backup...`, mainResult.error);\n\n    // Try loading backup file\n    const backupResult = await this.loadJSONFile(backupFilename, base);\n    if (backupResult.success) {\n      console.warn(`Loaded from backup: ${backupFilename}`);\n      // Restore the main file from backup\n      try {\n        const backupData = JSON.stringify(backupResult.data, null, 2);\n        await this.fs.writeFile(filename, base, backupData);\n        console.log(`Restored ${filename} from backup`);\n      } catch (error) {\n        console.error(`Failed to restore ${filename} from backup:`, error);\n      }\n      return backupResult.data as T;\n    }\n\n    console.error(`Both ${filename} and ${backupFilename} failed to load`);\n    return defaultValue;\n  }\n\n  /**\n   * Safely saves a JSON file with atomic write using backup strategy.\n   * Strategy: write to backup first, then to main file.\n   * This ensures at least one valid copy exists at all times.\n   * @param filename - The name of the file to save (without .bak extension)\n   * @param base - The base directory\n   * @param data - The data to save\n   */\n  private async safeSaveJSON(filename: string, base: BaseDir, data: unknown): Promise<void> {\n    const backupFilename = `${filename}.bak`;\n    const jsonData = JSON.stringify(data, null, 2);\n\n    // Strategy: Always write to backup first, then to main file\n    // This ensures we always have at least one valid copy\n    try {\n      // Step 1: Write to backup file\n      await this.fs.writeFile(backupFilename, base, jsonData);\n\n      // Step 2: Write to main file\n      await this.fs.writeFile(filename, base, jsonData);\n    } catch (error) {\n      console.error(`Failed to save ${filename}:`, error);\n      throw new Error(`Failed to save ${filename}: ${error}`);\n    }\n  }\n\n  /** Ensure necessary directories exist for a book (both legacy hash-based and new flat local paths). */\n  private async ensureLocalBookDirs(book: Book): Promise<void> {\n    if (book.relativePath) {\n      const segments = book.relativePath.split('/');\n      const fileDir = segments.slice(0, -1).join('/');\n      const metadataDir = book.relativePath.replace(/\\.[^.]+$/, '');\n\n      if (fileDir) {\n        await this.fs.createDir(fileDir, 'Books', true);\n      }\n      await this.fs.createDir(metadataDir, 'Books', true);\n      return;\n    }\n\n    // Legacy hash-based storage\n    if (!(await this.fs.exists(getDir(book), 'Books'))) {\n      await this.fs.createDir(getDir(book), 'Books');\n    }\n  }\n\n  private async migrate20251124(): Promise<void> {\n    console.log('Running migration for version 20251124 to rename the backup library file...');\n    const oldBackupFilename = getLibraryBackupFilename();\n    const newBackupFilename = `${getLibraryFilename()}.bak`;\n    if (await this.fs.exists(oldBackupFilename, 'Books')) {\n      try {\n        const content = await this.fs.readFile(oldBackupFilename, 'Books', 'text');\n        await this.fs.writeFile(newBackupFilename, 'Books', content);\n        await this.fs.removeFile(oldBackupFilename, 'Books');\n        console.log('Migration to rename backup library file completed successfully.');\n      } catch (error) {\n        console.error('Error during migration to rename backup library file:', error);\n      }\n    }\n  }\n\n  /**\n   * Migration 20260121: move legacy hash-based local books to flat relativePath layout in local mode.\n   * - Applies only when appPlatform === 'web' and STORAGE_MODE is local\n   * - For any book without relativePath, derive a flat path and move files + metadata\n   */\n  private async migrate20260121(): Promise<void> {\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    const isLocalMode = (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') === 'local';\n    if (this.appPlatform !== 'web' || !isLocalMode) {\n      console.log('[Migration 20260121] Skip (not web/local mode)');\n      return;\n    }\n\n    console.log('[Migration 20260121] Start migrating legacy hash-based books to flat layout');\n\n    const books = await this.loadLibraryBooks();\n    let migrated = 0;\n\n    for (const book of books) {\n      if (book.relativePath) continue;\n\n      const ext = EXTS[book.format] || book.format?.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title || book.hash);\n      const newRelativePath = `${book.groupName ? `${book.groupName}/` : ''}${safeBaseName}.${ext}`;\n\n      // Legacy paths\n      const legacyBookPath = `${book.hash}/${safeBaseName}.${ext}`;\n      const legacyCoverPath = `${book.hash}/cover.png`;\n      const legacyConfigPath = `${book.hash}/config.json`;\n\n      // New paths\n      const newBookPath = newRelativePath;\n      const newCoverPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/cover.png';\n      const newConfigPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/config.json';\n\n      try {\n        // Move book file if present\n        if (await this.fs.exists(legacyBookPath, 'Books')) {\n          await this.ensureLocalBookDirs({ ...book, relativePath: newRelativePath } as Book);\n          const file = await this.fs.openFile(legacyBookPath, 'Books');\n          await this.fs.writeFile(newBookPath, 'Books', file);\n          await this.fs.removeFile(legacyBookPath, 'Books');\n        }\n\n        // Move cover\n        if (await this.fs.exists(legacyCoverPath, 'Books')) {\n          const coverFile = await this.fs.openFile(legacyCoverPath, 'Books');\n          await this.fs.writeFile(newCoverPath, 'Books', coverFile);\n          await this.fs.removeFile(legacyCoverPath, 'Books');\n        }\n\n        // Move config\n        if (await this.fs.exists(legacyConfigPath, 'Books')) {\n          const configContent = await this.fs.readFile(legacyConfigPath, 'Books', 'text');\n          await this.fs.writeFile(newConfigPath, 'Books', configContent);\n          await this.fs.removeFile(legacyConfigPath, 'Books');\n        }\n\n        // Update in-memory book\n        book.relativePath = newRelativePath;\n        migrated++;\n      } catch (error) {\n        console.error('[Migration 20260121] Failed to migrate book:', book.title, error);\n      }\n    }\n\n    if (migrated > 0) {\n      await this.saveLibraryBooks(books);\n      console.log(`[Migration 20260121] Migrated ${migrated} book(s) to flat layout`);\n    } else {\n      console.log('[Migration 20260121] No legacy books to migrate');\n    }\n  }\n}\n","/**\n * IndexedDB \n * \n */\n\nconst DB_NAME = 'readest-cache';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'files';\n\nexport interface CacheEntry {\n    key: string; //  URL\n    data: ArrayBuffer;\n    etag?: string;\n    mimeType: string;\n    timestamp: number;\n    expiresAt?: number; // \n}\n\nclass IndexedDBCache {\n    private db: IDBDatabase | null = null;\n    private initPromise: Promise<void> | null = null;\n\n    async init(): Promise<void> {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n\n        this.initPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onerror = () => {\n                console.error('[IndexedDBCache] Failed to open database:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                console.log('[IndexedDBCache]  Database opened successfully');\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(STORE_NAME)) {\n                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });\n                    store.createIndex('expiresAt', 'expiresAt', { unique: false });\n                    console.log('[IndexedDBCache]  Object store created');\n                }\n            };\n        });\n\n        return this.initPromise;\n    }\n\n    /**\n     * \n     */\n    async get(key: string): Promise<CacheEntry | null> {\n        await this.init();\n        if (!this.db) return null;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entry = request.result as CacheEntry | undefined;\n\n                // \n                if (entry && entry.expiresAt && Date.now() > entry.expiresAt) {\n                    console.log('[IndexedDBCache] Cache expired for:', key);\n                    // \n                    this.delete(key).catch(e => console.error('Failed to delete expired cache:', e));\n                    resolve(null);\n                } else {\n                    if (entry) {\n                        console.log('[IndexedDBCache]  Cache hit for:', key);\n                    }\n                    resolve(entry || null);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async set(\n        key: string,\n        data: ArrayBuffer,\n        mimeType: string,\n        options?: {\n            etag?: string;\n            ttl?: number; // \n        },\n    ): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        const entry: CacheEntry = {\n            key,\n            data,\n            mimeType,\n            etag: options?.etag,\n            timestamp: Date.now(),\n            expiresAt: options?.ttl ? Date.now() + options.ttl : undefined,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(entry);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache saved for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async delete(key: string): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache deleted for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clear(): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  All caches cleared');\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clearExpired(): Promise<number> {\n        await this.init();\n        if (!this.db) return 0;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const index = store.index('expiresAt');\n            const range = IDBKeyRange.upperBound(Date.now());\n            const request = index.openCursor(range);\n\n            let deletedCount = 0;\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = (event) => {\n                const cursor = (event.target as IDBRequest).result;\n                if (cursor) {\n                    console.log('[IndexedDBCache] Deleting expired cache:', cursor.key);\n                    store.delete(cursor.primaryKey);\n                    deletedCount++;\n                    cursor.continue();\n                } else {\n                    console.log('[IndexedDBCache]  Cleared', deletedCount, 'expired caches');\n                    resolve(deletedCount);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async getStats(): Promise<{\n        totalEntries: number;\n        totalSize: number; // \n        oldestEntry?: { key: string; timestamp: number };\n        newestEntry?: { key: string; timestamp: number };\n    }> {\n        await this.init();\n        if (!this.db) {\n            return { totalEntries: 0, totalSize: 0 };\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.getAll();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entries = request.result as CacheEntry[];\n                let totalSize = 0;\n                let oldestEntry: { key: string; timestamp: number } | undefined;\n                let newestEntry: { key: string; timestamp: number } | undefined;\n\n                entries.forEach((entry) => {\n                    totalSize += entry.data.byteLength;\n                    if (!oldestEntry || entry.timestamp < oldestEntry.timestamp) {\n                        oldestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                    if (!newestEntry || entry.timestamp > newestEntry.timestamp) {\n                        newestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                });\n\n                console.log('[IndexedDBCache] Stats:', {\n                    entries: entries.length,\n                    size: (totalSize / 1024 / 1024).toFixed(2) + ' MB',\n                });\n\n                resolve({\n                    totalEntries: entries.length,\n                    totalSize,\n                    oldestEntry,\n                    newestEntry,\n                });\n            };\n        });\n    }\n}\n\nexport const indexedDBCache = new IndexedDBCache();\n","/**\n * \n * HTTP   IndexedDB  \n */\n\nimport { indexedDBCache } from './indexedDBCache';\n\nexport type FetchOptions = {\n    /**  */\n    cacheStrategy?: 'network-first' | 'cache-first' | 'stale-while-revalidate';\n    /** 0  */\n    cacheTTL?: number;\n    /**  */\n    bypassCache?: boolean;\n    /**  HTTP  */\n    headers?: Record<string, string>;\n    /**  */\n    onProgress?: (progress: number) => void;\n};\n\nconst DEFAULT_OPTIONS: FetchOptions = {\n    cacheStrategy: 'cache-first',\n    cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n};\n\n/**\n * \n */\nfunction generateCacheKey(url: string): string {\n    return `file_${url}`;\n}\n\n/**\n *  fetch \n */\nexport async function cachedFetch(\n    url: string,\n    options: FetchOptions = {},\n): Promise<{ data: ArrayBuffer; headers: Headers; fromCache: boolean }> {\n    const finalOptions = { ...DEFAULT_OPTIONS, ...options };\n    const cacheKey = generateCacheKey(url);\n\n    console.log(`[cachedFetch] Fetching: ${url}, strategy: ${finalOptions.cacheStrategy}`);\n\n    try {\n        //  1: cache-first - \n        if (\n            finalOptions.cacheStrategy === 'cache-first' &&\n            !finalOptions.bypassCache\n        ) {\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                console.log(`[cachedFetch]  Using cached data for: ${url}`);\n                // \n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    ...(cached.etag && { 'ETag': cached.etag }),\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        // \n        const fetchHeaders = new Headers(finalOptions.headers || {});\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: fetchHeaders,\n            signal: AbortSignal.timeout(30000), // 30\n        });\n\n        //  304 Not Modified\n        if (response.status === 304) {\n            console.log(`[cachedFetch] 304 Not Modified for: ${url}`);\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    'ETag': response.headers.get('ETag') || cached.etag || '',\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // \n        const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);\n        const reader = response.body?.getReader();\n        const chunks: Uint8Array[] = [];\n        let receivedLength = 0;\n\n        if (reader) {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                chunks.push(value);\n                receivedLength += value.length;\n\n                // \n                if (contentLength > 0 && finalOptions.onProgress) {\n                    const progress = Math.round((receivedLength / contentLength) * 100);\n                    finalOptions.onProgress(progress);\n                }\n            }\n        } else {\n            // Fallback  ReadableStream \n            chunks.push(new Uint8Array(await response.arrayBuffer()));\n        }\n\n        // \n        const data = new ArrayBuffer(receivedLength);\n        const dataView = new Uint8Array(data);\n        let offset = 0;\n        for (const chunk of chunks) {\n            dataView.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        // \n        const mimeType = response.headers.get('Content-Type') || 'application/octet-stream';\n        const etag = response.headers.get('ETag');\n\n        // \n        if (!finalOptions.bypassCache && response.status === 200) {\n            indexedDBCache\n                .set(cacheKey, data, mimeType, {\n                    etag: etag || undefined,\n                    ttl: finalOptions.cacheTTL,\n                })\n                .catch((error) => {\n                    console.warn(`[cachedFetch] Failed to cache ${url}:`, error);\n                });\n        }\n\n        console.log(`[cachedFetch]  Fetched ${(data.byteLength / 1024 / 1024).toFixed(2)} MB from network`);\n\n        return { data, headers: response.headers, fromCache: false };\n    } catch (error) {\n        //  network-first \n        console.warn(`[cachedFetch] Network error for ${url}:`, error);\n        const cached = await indexedDBCache.get(cacheKey);\n        if (cached) {\n            console.log(`[cachedFetch]  Using stale cache due to network error: ${url}`);\n            const headers = new Headers({\n                'Content-Type': cached.mimeType,\n                'Content-Length': cached.data.byteLength.toString(),\n                'Warning': '199 - \"Stale cache used due to network error\"',\n            });\n            return { data: cached.data, headers, fromCache: true };\n        }\n\n        throw error;\n    }\n}\n\n/**\n *  Blob URL\n */\nexport async function cachedFetchAsUrl(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data, headers } = await cachedFetch(url, options);\n    const mimeType = headers.get('Content-Type') || 'application/octet-stream';\n    const blob = new Blob([data], { type: mimeType });\n    return URL.createObjectURL(blob);\n}\n\n/**\n *  Base64\n */\nexport async function cachedFetchAsBase64(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data } = await cachedFetch(url, options);\n    const bytes = new Uint8Array(data);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]!);\n    }\n    return btoa(binary);\n}\n\n/**\n * \n */\nexport async function clearFileCache(url?: string): Promise<void> {\n    if (url) {\n        const cacheKey = generateCacheKey(url);\n        await indexedDBCache.delete(cacheKey);\n        console.log(`[cachedFetch] Cleared cache for: ${url}`);\n    } else {\n        await indexedDBCache.clear();\n        console.log('[cachedFetch] Cleared all file caches');\n    }\n}\n\n/**\n * \n */\nexport async function clearExpiredFileCache(): Promise<number> {\n    return await indexedDBCache.clearExpired();\n}\n\n/**\n * \n */\nexport async function getFileCacheStats() {\n    return await indexedDBCache.getStats();\n}\n","import { partialMD5 } from './md5';\nimport { getBaseFilename } from './path';\nimport { detectLanguage } from './lang';\n\ninterface Metadata {\n  bookTitle: string;\n  author: string;\n  language: string;\n  identifier: string;\n}\n\ninterface Chapter {\n  title: string;\n  content: string;\n  text: string;\n  isVolume: boolean;\n}\n\ninterface Txt2EpubOptions {\n  file: File;\n  author?: string;\n  language?: string;\n}\n\ninterface ExtractChapterOptions {\n  linesBetweenSegments: number;\n  fallbackParagraphsPerChapter: number;\n}\n\ninterface ConversionResult {\n  file: File;\n  bookTitle: string;\n  chapterCount: number;\n  language: string;\n}\n\nconst zipWriteOptions = {\n  lastAccessDate: new Date(0),\n  lastModDate: new Date(0),\n};\n\nconst escapeXml = (str: string) => {\n  if (!str) return '';\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n};\n\nexport class TxtToEpubConverter {\n  public async convert(options: Txt2EpubOptions): Promise<ConversionResult> {\n    const { file: txtFile, author: providedAuthor, language: providedLanguage } = options;\n\n    const fileContent = await txtFile.arrayBuffer();\n    const detectedEncoding = this.detectEncoding(fileContent) || 'utf-8';\n    console.log(`Detected encoding: ${detectedEncoding}`);\n    const decoder = new TextDecoder(detectedEncoding);\n    const txtContent = decoder.decode(fileContent).trim();\n\n    const bookTitle = this.extractBookTitle(getBaseFilename(txtFile.name));\n    const fileName = `${bookTitle}.epub`;\n\n    const fileHeader = txtContent.slice(0, 1024);\n    const authorMatch =\n      fileHeader.match(/[\\[]?[\\]]?[:\\s]\\s*(.+)\\r?\\n/) ||\n      fileHeader.match(/[\\[]?\\s*(.+)\\s+\\s*[\\]]?\\r?\\n/);\n    let matchedAuthor = authorMatch ? authorMatch[1]!.trim() : providedAuthor || '';\n    try {\n      matchedAuthor = matchedAuthor.replace(/^[\\p{P}\\p{S}]+|[\\p{P}\\p{S}]+$/gu, '');\n    } catch {}\n    const author = matchedAuthor || providedAuthor || '';\n    const language = providedLanguage || detectLanguage(fileHeader);\n    console.log(`Detected language: ${language}`);\n    const identifier = await partialMD5(txtFile);\n    const metadata = { bookTitle, author, language, identifier };\n\n    let chapters: Chapter[] = [];\n    for (let i = 8; i >= 6; i--) {\n      chapters = this.extractChapters(txtContent, metadata, {\n        linesBetweenSegments: i,\n        fallbackParagraphsPerChapter: 100,\n      });\n\n      if (chapters.length === 0) {\n        throw new Error('No chapters detected.');\n      } else if (chapters.length > 1) {\n        break;\n      }\n    }\n\n    const blob = await this.createEpub(chapters, metadata);\n    return {\n      file: new File([blob], fileName),\n      bookTitle,\n      chapterCount: chapters.length,\n      language,\n    };\n  }\n\n  private extractChapters(\n    txtContent: string,\n    metadata: Metadata,\n    option: ExtractChapterOptions,\n  ): Chapter[] {\n    const { language } = metadata;\n    const { linesBetweenSegments, fallbackParagraphsPerChapter } = option;\n    const segmentRegex = new RegExp(`(?:\\\\r?\\\\n){${linesBetweenSegments},}|-{8,}\\r?\\n`);\n    const chapterRegexps: RegExp[] = [];\n    if (language === 'zh') {\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[0-9][0-9]*(?:[])(?:[: \\(\\)0-9]*[^\\n-]{0,24})(?!\\S)`,\n              String.raw`(?:||||||||)(?:[: ][^\\n-]{0,24})?(?!\\S)`,\n              String.raw`chapter[\\s.]*[0-9]+(?:[:. ]+[^\\n-]{0,50})?(?!\\S)`,\n            ].join('|') +\n            ')',\n          'gui',\n        ),\n      );\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[][]?[: ][^\\n-]{0,24}(?=\\n|$)`,\n              String.raw`[0-9]+[^\\n]{0,16}(?=\\n|$)`,\n            ].join('|') +\n            ')',\n          'gu',\n        ),\n      );\n    } else {\n      const chapterKeywords = ['Chapter', 'Part', 'Section', 'Book', 'Volume', 'Act'];\n\n      const prefaceKeywords = [\n        'Prologue',\n        'Epilogue',\n        'Introduction',\n        'Foreword',\n        'Preface',\n        'Afterword',\n      ];\n\n      const numberPattern = String.raw`(\\d+|(?:[IVXLCDM]{2,}|V|X|L|C|D|M)\\b)`;\n      const dotNumberPattern = String.raw`\\.\\d{1,4}`;\n      const titlePattern = String.raw`[^\\n]{0,50}`;\n\n      const normalChapterPattern = chapterKeywords\n        .map(\n          (k) =>\n            String.raw`${k}\\s*(?:${numberPattern}|${dotNumberPattern})(?:[:.\\-]?\\s*${titlePattern})?`,\n        )\n        .join('|');\n\n      const prefacePattern = prefaceKeywords\n        .map((k) => String.raw`${k}(?:[:.\\-]?\\s*${titlePattern})?`)\n        .join('|');\n\n      const combinedPattern = String.raw`(?:^|\\n|\\s)(?:${normalChapterPattern}|${prefacePattern})(?=\\s|$)`;\n\n      chapterRegexps.push(new RegExp(combinedPattern, 'gi'));\n    }\n\n    const formatSegment = (segment: string): string => {\n      segment = escapeXml(segment);\n      return segment\n        .replace(/-{8,}|_{8,}/g, '\\n')\n        .split(/\\n+/)\n        .map((line) => line.trim())\n        .filter((line) => line)\n        .join('</p><p>');\n    };\n\n    const joinAroundUndefined = (arr: (string | undefined)[]) =>\n      arr.reduce<string[]>((acc, curr, i, src) => {\n        if (\n          curr === undefined &&\n          i > 0 &&\n          i < src.length - 1 &&\n          src[i - 1] !== undefined &&\n          src[i + 1] !== undefined\n        ) {\n          acc[acc.length - 1] += src[i + 1]!;\n          return acc;\n        }\n        if (curr !== undefined && (i === 0 || src[i - 1] !== undefined)) {\n          acc.push(curr);\n        }\n        return acc;\n      }, []);\n\n    const isGoodMatches = (matches: string[], maxLength: number = 100000): boolean => {\n      const meaningfulParts = matches.filter((part) => part && part.trim().length > 0);\n      if (meaningfulParts.length <= 1) return false;\n\n      const hasLongParts = meaningfulParts.some((part) => part.length > maxLength);\n      return !hasLongParts;\n    };\n\n    const chapters: Chapter[] = [];\n    const segments = txtContent.split(segmentRegex);\n    for (const segment of segments) {\n      const trimmedSegment = segment.replace(/<!--.*?-->/g, '').trim();\n      if (!trimmedSegment) continue;\n\n      const segmentChapters: Chapter[] = [];\n      let matches: string[] = [];\n      for (const chapterRegex of chapterRegexps) {\n        const tryMatches = trimmedSegment.split(chapterRegex);\n        if (isGoodMatches(tryMatches)) {\n          matches = joinAroundUndefined(tryMatches);\n          break;\n        }\n      }\n\n      if (matches.length === 0 && fallbackParagraphsPerChapter > 0) {\n        const paragraphs = trimmedSegment.split(/\\n+/);\n        const totalParagraphs = paragraphs.length;\n        for (let i = 0; i < totalParagraphs; i += fallbackParagraphsPerChapter) {\n          const chunks = paragraphs.slice(i, i + fallbackParagraphsPerChapter);\n          const formattedSegment = formatSegment(chunks.join('\\n'));\n          const title = `${chapters.length + 1}`;\n          const content = `<h2>${title}</h2><p>${formattedSegment}</p>`;\n          chapters.push({ title, content, text: chunks.join('\\n'), isVolume: false });\n        }\n        continue;\n      }\n\n      for (let j = 1; j < matches.length; j += 2) {\n        const title = matches[j]?.trim() || '';\n        const content = matches[j + 1]?.trim() || '';\n\n        let isVolume = false;\n        if (language === 'zh') {\n          isVolume = /[0-9]+(|||)/.test(title);\n        } else {\n          isVolume = /\\b(Part|Volume|Book)\\b/i.test(title);\n        }\n\n        const headTitle = isVolume ? `<h1>${title}</h1>` : `<h2>${title}</h2>`;\n        const formattedSegment = formatSegment(content);\n        segmentChapters.push({\n          title: escapeXml(title),\n          content: `${headTitle}<p>${formattedSegment}</p>`,\n          text: content,\n          isVolume: isVolume,\n        });\n      }\n\n      if (matches[0] && matches[0].trim()) {\n        const initialContent = matches[0].trim();\n        const firstLine = initialContent.split('\\n')[0]!.trim();\n        const segmentTitle =\n          (firstLine.length > 16 ? initialContent.split(/[\\n\\s\\p{P}]/u)[0]!.trim() : firstLine) ||\n          initialContent.slice(0, 16);\n        const formattedSegment = formatSegment(initialContent);\n        segmentChapters.unshift({\n          title: escapeXml(segmentTitle),\n          content: `<h3></h3><p>${formattedSegment}</p>`,\n          text: initialContent,\n          isVolume: false,\n        });\n      }\n      chapters.push(...segmentChapters);\n    }\n\n    return chapters;\n  }\n\n  private async createEpub(chapters: Chapter[], metadata: Metadata): Promise<Blob> {\n    const { BlobWriter, TextReader, ZipWriter } = await import('@zip.js/zip.js');\n    const { bookTitle, author, language, identifier } = metadata;\n\n    const zipWriter = new ZipWriter(new BlobWriter('application/epub+zip'), {\n      extendedTimestamp: false,\n    });\n    await zipWriter.add('mimetype', new TextReader('application/epub+zip'), zipWriteOptions);\n\n    // Add META-INF/container.xml\n    const containerXml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <container xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\" version=\"1.0\">\n      <rootfiles>\n        <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n      </rootfiles>\n    </container>`.trim();\n\n    await zipWriter.add('META-INF/container.xml', new TextReader(containerXml), zipWriteOptions);\n\n    // Create navigation points for TOC\n    let isNested = false;\n    let navPoints = ``;\n    for (let i = 0; i < chapters.length; i++) {\n      const id = `chapter${i + 1}`;\n      const playOrder = i + 1;\n      if (chapters[i]!.isVolume && isNested) {\n        navPoints += `</navPoint>\\n`;\n        isNested = !isNested;\n      }\n      navPoints +=\n        `<navPoint id=\"navPoint-${id}\" playOrder=\"${playOrder}\">\\n` +\n        `<navLabel><text>${chapters[i]!.title}</text></navLabel>\\n` +\n        `<content src=\"./OEBPS/${id}.xhtml\" />\\n`;\n      if (chapters[i]!.isVolume && !isNested) {\n        isNested = !isNested;\n      } else {\n        navPoints += `</navPoint>\\n`;\n      }\n    }\n    if (isNested) {\n      navPoints += `</navPoint>`;\n    }\n\n    // Add NCX file (table of contents)\n    const tocNcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n      <head>\n        <meta name=\"dtb:uid\" content=\"book-id\" />\n        <meta name=\"dtb:depth\" content=\"1\" />\n        <meta name=\"dtb:totalPageCount\" content=\"0\" />\n        <meta name=\"dtb:maxPageNumber\" content=\"0\" />\n      </head>\n      <docTitle>\n        <text>${escapeXml(bookTitle)}</text>\n      </docTitle>\n      <docAuthor>\n        <text>${escapeXml(author)}</text>\n      </docAuthor>\n      <navMap>\n        ${navPoints}\n      </navMap>\n    </ncx>`.trim();\n\n    await zipWriter.add('toc.ncx', new TextReader(tocNcx), zipWriteOptions);\n\n    // Create manifest and spine items\n    const manifest = chapters\n      .map(\n        (_, index) => `\n      <item id=\"chap${index + 1}\" href=\"OEBPS/chapter${index + 1}.xhtml\" media-type=\"application/xhtml+xml\"/>\n    `,\n      )\n      .join('\\n')\n      .trim();\n\n    const spine = chapters\n      .map(\n        (_, index) => `\n      <itemref idref=\"chap${index + 1}\"/>`,\n      )\n      .join('\\n')\n      .trim();\n\n    // Add CSS stylesheet\n    const css = `\n      body { line-height: 1.6; font-size: 1em; font-family: 'Arial', sans-serif; text-align: justify; }\n      p { text-indent: 2em; margin: 0; }\n    `;\n\n    await zipWriter.add('style.css', new TextReader(css), zipWriteOptions);\n\n    // Add chapter files\n    for (let i = 0; i < chapters.length; i++) {\n      const chapter = chapters[i]!;\n      const lang = detectLanguage(chapter.text);\n      const chapterContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"${lang}\" xml:lang=\"${lang}\">\n          <head>\n            <title>${chapter.title}</title>\n            <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\"/>\n          </head>\n          <body>${chapter.content}</body>\n        </html>`.trim();\n\n      await zipWriter.add(\n        `OEBPS/chapter${i + 1}.xhtml`,\n        new TextReader(chapterContent),\n        zipWriteOptions,\n      );\n    }\n\n    const tocManifest = `<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>`;\n    const styleManifest = `<item id=\"css\" href=\"style.css\" media-type=\"text/css\"/>`;\n\n    // Add content.opf file\n    const contentOpf = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"book-id\" version=\"2.0\">\n        <metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n          <dc:title>${escapeXml(bookTitle)}</dc:title>\n          <dc:language>${language}</dc:language>\n          <dc:creator>${escapeXml(author)}</dc:creator>\n          <dc:identifier id=\"book-id\">${identifier}</dc:identifier>\n        </metadata>\n        <manifest>\n          ${manifest}\n          ${tocManifest}\n          ${styleManifest}\n        </manifest>\n        <spine toc=\"ncx\">\n          ${spine}\n        </spine>\n      </package>`.trim();\n\n    await zipWriter.add('content.opf', new TextReader(contentOpf), zipWriteOptions);\n\n    return await zipWriter.close();\n  }\n\n  private detectEncoding(buffer: ArrayBuffer): string | undefined {\n    try {\n      new TextDecoder('utf-8', { fatal: true }).decode(buffer);\n      return 'utf-8';\n    } catch {\n      const uint8Array = new Uint8Array(buffer);\n      // Try tolerant UTF-8 detection - check if most of it is valid UTF-8\n      let validBytes = 0;\n      let checkedBytes = 0;\n      const sampleSize = Math.min(uint8Array.length, 10000);\n\n      for (let i = 0; i < sampleSize; i++) {\n        try {\n          new TextDecoder('utf-8', { fatal: true }).decode(uint8Array.slice(i, i + 100));\n          validBytes += 100;\n          checkedBytes += 100;\n          i += 99;\n        } catch {\n          checkedBytes++;\n        }\n      }\n\n      const validPercentage = (validBytes / checkedBytes) * 100;\n      console.log(`UTF-8 validity: ${validPercentage.toFixed(2)}%`);\n\n      // If more than 80% is valid UTF-8, consider it UTF-8 with some corruption\n      if (validPercentage > 80) {\n        console.log('Treating as UTF-8 despite some invalid sequences');\n        return 'utf-8';\n      }\n      // If UTF-8 decoding fails, try to detect other encodings\n    }\n\n    const headerBytes = new Uint8Array(buffer.slice(0, 4));\n\n    if (headerBytes[0] === 0xff && headerBytes[1] === 0xfe) {\n      return 'utf-16le';\n    }\n\n    if (headerBytes[0] === 0xfe && headerBytes[1] === 0xff) {\n      return 'utf-16be';\n    }\n\n    if (headerBytes[0] === 0xef && headerBytes[1] === 0xbb && headerBytes[2] === 0xbf) {\n      return 'utf-8';\n    }\n\n    // Analyze a sample of the content to guess between common East Asian encodings\n    // If the content has a high ratio of bytes in the 0x80-0xFF range, it's likely GBK/GB18030\n    const sample = new Uint8Array(buffer.slice(0, Math.min(1024, buffer.byteLength)));\n    let highByteCount = 0;\n\n    for (let i = 0; i < sample.length; i++) {\n      if (sample[i]! >= 0x80) {\n        highByteCount++;\n      }\n    }\n\n    const highByteRatio = highByteCount / sample.length;\n    if (highByteRatio > 0.3) {\n      return 'gbk';\n    }\n\n    if (highByteRatio > 0.1) {\n      let sjisPattern = false;\n      for (let i = 0; i < sample.length - 1; i++) {\n        const b1 = sample[i]!;\n        const b2 = sample[i + 1]!;\n        if (\n          ((b1 >= 0x81 && b1 <= 0x9f) || (b1 >= 0xe0 && b1 <= 0xfc)) &&\n          ((b2 >= 0x40 && b2 <= 0x7e) || (b2 >= 0x80 && b2 <= 0xfc))\n        ) {\n          sjisPattern = true;\n          break;\n        }\n      }\n\n      if (sjisPattern) {\n        return 'shift-jis';\n      }\n\n      return 'gb18030';\n    }\n\n    return 'utf-8';\n  }\n\n  private extractBookTitle(filename: string): string {\n    const match = filename.match(/([^]+)/);\n    return match ? match[1]! : filename.split('.')[0]!;\n  }\n}\n","export const BOOK_FILE_NOT_FOUND_ERROR = 'Book file not found';\n","import { FontStyle } from '@/styles/fonts';\nimport { getUserLang } from './misc';\n\nfunction parseUnicodeString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i += 2) {\n    const charCode = dataView.getUint16(offset + i, false);\n    if (charCode !== 0) {\n      chars.push(String.fromCharCode(charCode));\n    }\n  }\n  return chars.join('');\n}\n\nfunction parseMacintoshString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i++) {\n    const charCode = dataView.getUint8(offset + i);\n    chars.push(String.fromCharCode(charCode));\n  }\n  return chars.join('');\n}\n\nconst NO_STYLE_LANGUAGE_IDS = new Set([0x0404, 0x0804, 0x0c04, 0x1004, 19, 33]);\n\nfunction getLanguagePriority(platformID: number, languageID: number, userLanguage: string): number {\n  let priority = 0;\n\n  // Base priority by platform (Unicode/Microsoft preferred)\n  if (platformID === 0)\n    priority += 100; // Unicode\n  else if (platformID === 3)\n    priority += 90; // Microsoft\n  else if (platformID === 1) priority += 50; // Macintosh\n\n  // Language-specific priorities\n  const userLang = userLanguage.toLowerCase();\n\n  if (platformID === 0 || platformID === 3) {\n    if (userLang.startsWith('zh')) {\n      if (languageID === 0x0804)\n        priority += 50; // Simplified Chinese\n      else if (languageID === 0x0404)\n        priority += 45; // Traditional Chinese\n      else if (languageID === 0x0c04)\n        priority += 40; // Traditional Chinese\n      else if (languageID === 0x1004) priority += 35; // Simplified Chinese\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 0x0411) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 0x0412) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0x0409)\n        priority += 50; // English (US)\n      else if (languageID === 0x0809) priority += 45; // English (UK)\n    }\n\n    // Fallback: English\n    if (languageID === 0x0409) priority += 10; // English fallback\n  } else if (platformID === 1) {\n    // Macintosh platform language codes\n    if (userLang.startsWith('zh')) {\n      if (languageID === 33)\n        priority += 50; // Chinese (Simplified)\n      else if (languageID === 19) priority += 45; // Chinese (Traditional)\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 11) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 23) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0) priority += 50; // English\n    }\n\n    // Fallback: English\n    if (languageID === 0) priority += 10; // English fallback\n  }\n\n  return priority;\n}\n\nfunction parseOS2Weight(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table usWeightClass is at offset 4\n  return dataView.getUint16(os2TableOffset + 4, false);\n}\n\nfunction parseOS2Selection(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table fsSelection is at offset 62\n  return dataView.getUint16(os2TableOffset + 62, false);\n}\n\ninterface VariableFontAxis {\n  tag: string;\n  minValue: number;\n  defaultValue: number;\n  maxValue: number;\n  name?: string;\n}\n\nfunction parseVariableFontAxes(dataView: DataView, fvarTableOffset: number): VariableFontAxis[] {\n  try {\n    // fvar table structure:\n    // version (4 bytes) + axisCount (2 bytes) + axisSize (2 bytes) + instanceCount (2 bytes) + instanceSize (2 bytes)\n    const axisCount = dataView.getUint16(fvarTableOffset + 4, false);\n    const axisSize = dataView.getUint16(fvarTableOffset + 6, false);\n\n    const axes: VariableFontAxis[] = [];\n\n    // Each axis record starts at offset 16 from table start\n    let axisOffset = fvarTableOffset + 16;\n\n    for (let i = 0; i < axisCount; i++) {\n      // Axis record structure:\n      // axisTag (4 bytes) + minValue (4 bytes) + defaultValue (4 bytes) + maxValue (4 bytes) + flags (2 bytes) + axisNameID (2 bytes)\n\n      const tag = String.fromCharCode(\n        dataView.getUint8(axisOffset),\n        dataView.getUint8(axisOffset + 1),\n        dataView.getUint8(axisOffset + 2),\n        dataView.getUint8(axisOffset + 3),\n      );\n\n      // Fixed-point values (16.16 format)\n      const minValue = dataView.getInt32(axisOffset + 4, false) / 65536;\n      const defaultValue = dataView.getInt32(axisOffset + 8, false) / 65536;\n      const maxValue = dataView.getInt32(axisOffset + 12, false) / 65536;\n\n      axes.push({\n        tag,\n        minValue,\n        defaultValue,\n        maxValue,\n      });\n\n      axisOffset += axisSize;\n    }\n\n    return axes;\n  } catch (error) {\n    console.warn('Failed to parse fvar table:', error);\n    return [];\n  }\n}\n\nfunction weightClassToCSSWeight(weightClass: number): number {\n  // Map OpenType weight class to CSS weight\n  if (weightClass >= 1 && weightClass <= 100) return 100;\n  if (weightClass >= 101 && weightClass <= 200) return 200;\n  if (weightClass >= 201 && weightClass <= 300) return 300;\n  if (weightClass >= 301 && weightClass <= 400) return 400;\n  if (weightClass >= 401 && weightClass <= 500) return 500;\n  if (weightClass >= 501 && weightClass <= 600) return 600;\n  if (weightClass >= 601 && weightClass <= 700) return 700;\n  if (weightClass >= 701 && weightClass <= 800) return 800;\n  if (weightClass >= 801 && weightClass <= 900) return 900;\n  return 400; // Default to normal weight\n}\n\nfunction inferWeightFromStyleName(styleName: string): number {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check for specific weight keywords\n  if (lowerStyle.includes('thin') || lowerStyle.includes('hairline')) return 100;\n  if (lowerStyle.includes('extralight') || lowerStyle.includes('ultralight')) return 200;\n  if (\n    lowerStyle.includes('light') &&\n    !lowerStyle.includes('extralight') &&\n    !lowerStyle.includes('ultralight')\n  )\n    return 300;\n  if (lowerStyle.includes('medium')) return 500;\n  if (lowerStyle.includes('semibold') || lowerStyle.includes('demibold')) return 600;\n  if (lowerStyle.includes('extrabold') || lowerStyle.includes('ultrabold')) return 800;\n  if (lowerStyle.includes('black') || lowerStyle.includes('heavy')) return 900;\n  if (\n    lowerStyle.includes('bold') &&\n    !lowerStyle.includes('semibold') &&\n    !lowerStyle.includes('extrabold') &&\n    !lowerStyle.includes('ultrabold')\n  )\n    return 700;\n\n  return 400; // Default to normal weight\n}\n\nfunction inferStyleFromName(\n  styleName: string,\n  fsSelection: number,\n): 'normal' | 'italic' | 'oblique' {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check fsSelection flags first (bit 0 = italic, bit 9 = oblique)\n  if (fsSelection & 0x200) return 'oblique'; // Bit 9\n  if (fsSelection & 0x1) return 'italic'; // Bit 0\n\n  // Fallback to style name analysis\n  if (lowerStyle.includes('oblique')) return 'oblique';\n  if (lowerStyle.includes('italic') || lowerStyle.includes('slant')) return 'italic';\n\n  return 'normal';\n}\n\ntype FontNameType = {\n  name: string;\n  platformID: number;\n  languageID: number;\n  priority: number;\n};\n\nexport const parseFontInfo = (fontData: ArrayBuffer, filename: string) => {\n  const fallbackName = filename.replace(/\\.[^/.]+$/, '');\n  try {\n    const dataView = new DataView(fontData);\n    const signature = dataView.getUint32(0, false);\n    if (signature !== 0x00010000 && signature !== 0x74727565 && signature !== 0x4f54544f) {\n      throw new Error('Unsupported font format');\n    }\n    const numTables = dataView.getUint16(4, false);\n    let nameTableOffset = 0;\n    let os2TableOffset = 0;\n    let fvarTableOffset = 0;\n    for (let i = 0; i < numTables; i++) {\n      const tableOffset = 12 + i * 16;\n      const tag = String.fromCharCode(\n        dataView.getUint8(tableOffset),\n        dataView.getUint8(tableOffset + 1),\n        dataView.getUint8(tableOffset + 2),\n        dataView.getUint8(tableOffset + 3),\n      );\n\n      if (tag === 'name') {\n        nameTableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'OS/2') {\n        os2TableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'fvar') {\n        fvarTableOffset = dataView.getUint32(tableOffset + 8, false);\n      }\n    }\n\n    if (nameTableOffset === 0) {\n      throw new Error('Name table not found');\n    }\n\n    const count = dataView.getUint16(nameTableOffset + 2, false);\n    const stringOffset = dataView.getUint16(nameTableOffset + 4, false);\n\n    const userLanguage = getUserLang();\n    const fontFamilyNames: Array<FontNameType> = [];\n    const fontStyleNames: Array<FontNameType> = [];\n    const preferredFamilyNames: Array<FontNameType> = [];\n    const preferredStyleNames: Array<FontNameType> = [];\n    for (let i = 0; i < count; i++) {\n      const recordOffset = nameTableOffset + 6 + i * 12;\n      const platformID = dataView.getUint16(recordOffset, false);\n      const languageID = dataView.getUint16(recordOffset + 4, false);\n      const nameID = dataView.getUint16(recordOffset + 6, false);\n      const nameLength = dataView.getUint16(recordOffset + 8, false);\n      const nameOffsetInTable = dataView.getUint16(recordOffset + 10, false);\n\n      // nameID 1 = Font Family name, nameID 2 = Font Subfamily name (style)\n      // nameID 16 = Typographic Family name, nameID 17 = Typographic Subfamily name\n      if (nameID === 1 || nameID === 2 || nameID === 16 || nameID === 17) {\n        const stringStart = nameTableOffset + stringOffset + nameOffsetInTable;\n        let fontName = '';\n\n        if (platformID === 0 || platformID === 3) {\n          // Unicode/Microsoft platform\n          fontName = parseUnicodeString(dataView, stringStart, nameLength);\n        } else if (platformID === 1) {\n          // Macintosh platform\n          fontName = parseMacintoshString(dataView, stringStart, nameLength);\n        }\n\n        if (fontName && fontName.trim()) {\n          const priority = getLanguagePriority(platformID, languageID, userLanguage);\n          const nameEntry = {\n            name: fontName.trim(),\n            platformID,\n            languageID,\n            priority,\n          };\n\n          if (nameID === 1) {\n            fontFamilyNames.push(nameEntry);\n          } else if (nameID === 2) {\n            fontStyleNames.push(nameEntry);\n          } else if (nameID === 16) {\n            preferredFamilyNames.push(nameEntry);\n          } else if (nameID === 17) {\n            preferredStyleNames.push(nameEntry);\n          }\n        }\n      }\n    }\n    if (fontFamilyNames.length === 0) {\n      throw new Error('Font family name not found');\n    }\n    fontFamilyNames.sort((a, b) => b.priority - a.priority);\n    fontStyleNames.sort((a, b) => b.priority - a.priority);\n    preferredFamilyNames.sort((a, b) => b.priority - a.priority);\n    preferredStyleNames.sort((a, b) => b.priority - a.priority);\n\n    // Prefer typographic names if available\n    const familyName = (preferredFamilyNames[0] || fontFamilyNames[0])!.name;\n    const fontStyleName = preferredStyleNames[0] || fontStyleNames[0];\n    const styleName = fontStyleName?.name || '';\n\n    // Parse weight and style information\n    let fontWeight = 400;\n    let fontStyle: FontStyle = 'normal';\n    let fsSelection = 0;\n\n    if (os2TableOffset > 0) {\n      try {\n        const weightClass = parseOS2Weight(dataView, os2TableOffset);\n        fontWeight = weightClassToCSSWeight(weightClass);\n        fsSelection = parseOS2Selection(dataView, os2TableOffset);\n      } catch {\n        console.warn('Failed to parse OS/2 table, falling back to style name analysis');\n      }\n    }\n\n    let isVariable = false;\n    if (fvarTableOffset > 0) {\n      const axes = parseVariableFontAxes(dataView, fvarTableOffset);\n      if (axes && axes.length > 0) {\n        isVariable = true;\n      }\n    }\n\n    // If OS/2 table weight is default (400) or unavailable, try to infer from style name\n    if (fontWeight === 400 && styleName) {\n      const inferredWeight = inferWeightFromStyleName(styleName);\n      if (inferredWeight !== 400) {\n        fontWeight = inferredWeight;\n      }\n    }\n\n    fontStyle = inferStyleFromName(styleName, fsSelection);\n\n    return {\n      name:\n        fontStyleName && !NO_STYLE_LANGUAGE_IDS.has(fontStyleName.languageID)\n          ? `${familyName} ${styleName}`\n          : familyName,\n      family: familyName,\n      weight: fontWeight,\n      style: fontStyle,\n      variable: isVariable,\n    };\n  } catch (error) {\n    console.warn(`Failed to parse font: ${error}`);\n    return {\n      name: fallbackName,\n      family: fallbackName,\n      weight: 400,\n      style: 'normal' as FontStyle,\n      variable: false,\n    };\n  }\n};\n","function parseSvgLength(value: string) {\n  const n = parseFloat(value);\n  if (!isNaN(n)) return n;\n\n  return undefined;\n}\n\nasync function getSvgSize(\n  svgBlob: Blob,\n  defaultWidth: number = 700,\n  defaultHeight: number = 1050,\n): Promise<{ width: number; height: number }> {\n  const text = await svgBlob.text();\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(text, 'image/svg+xml');\n  const svg = doc.documentElement;\n\n  const widthAttr = svg.getAttribute('width');\n  const heightAttr = svg.getAttribute('height');\n\n  if (widthAttr && heightAttr) {\n    return {\n      width: parseSvgLength(widthAttr) || defaultWidth,\n      height: parseSvgLength(heightAttr) || defaultHeight,\n    };\n  }\n\n  const viewBox = svg.getAttribute('viewBox');\n  if (viewBox) {\n    const parts = viewBox.split(/\\s+/).map(Number);\n    if (parts.length === 4 && !parts.some(isNaN)) {\n      const [, , vbWidth, vbHeight] = parts;\n      return { width: vbWidth || defaultWidth, height: vbHeight || defaultHeight };\n    }\n  }\n\n  return { width: defaultWidth, height: defaultHeight };\n}\n\nexport async function svg2png(svgBlob: Blob, quality: number = 0.9): Promise<Blob> {\n  const svgText = await svgBlob.text();\n\n  const svgUrl = URL.createObjectURL(new Blob([svgText], { type: 'image/svg+xml' }));\n\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n\n  await new Promise<void>((resolve, reject) => {\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error('Failed to load SVG'));\n    img.src = svgUrl;\n  });\n\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n\n  const canvas = document.createElement('canvas');\n  const { width, height } = await getSvgSize(svgBlob);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0);\n\n  URL.revokeObjectURL(svgUrl);\n\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => resolve(blob!), 'image/png', quality);\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0,2,3,4,5,6,7]}
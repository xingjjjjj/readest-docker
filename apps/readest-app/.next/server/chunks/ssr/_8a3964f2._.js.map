{"version":3,"sources":["../../../../../../apps/readest-app/src/types/book.ts","../../../../../../apps/readest-app/src/libs/document.ts","../../../../../../apps/readest-app/src/utils/lang.ts","../../../../../../apps/readest-app/src/utils/book.ts","../../../../../../node_modules/.pnpm/%40tauri-apps%2Bplugin-http%402.5.6/node_modules/%40tauri-apps/plugin-http/dist-js/index.js","../../../../../../apps/readest-app/src/utils/serializer.ts"],"sourcesContent":["import { BookMetadata } from '@/libs/document';\nimport { TTSHighlightOptions } from '@/services/tts/types';\nimport { AnnotationToolType } from './annotator';\n\nexport type BookFormat =\n  | 'EPUB'\n  | 'PDF'\n  | 'MOBI'\n  | 'AZW'\n  | 'AZW3'\n  | 'CBZ'\n  | 'FB2'\n  | 'FBZ'\n  | 'TXT'\n  | 'MD';\nexport type BookNoteType = 'bookmark' | 'annotation' | 'excerpt';\nexport type HighlightStyle = 'highlight' | 'underline' | 'squiggly';\nexport type HighlightColor = 'red' | 'yellow' | 'green' | 'blue' | 'violet';\n\nexport const FIXED_LAYOUT_FORMATS: Set<BookFormat> = new Set(['PDF', 'CBZ']);\n\nexport interface Book {\n  // if Book is a remote book we just lazy load the book content via url\n  url?: string;\n  // if Book is a transient local book we can load the book content via filePath\n  filePath?: string;\n  // For local storage mode: relative path from storage root (e.g., \"fiction/book.epub\")\n  relativePath?: string;\n  // Absolute file path in the file system (for path reconciliation)\n  absolutePath?: string;\n  // Partial md5 hash of the book file, used as the unique identifier\n  hash: string;\n  // Metadata md5 hash, used to aggregate different versions of the same book\n  metaHash?: string;\n  format: BookFormat;\n  title: string; // editable title from metadata\n  sourceTitle?: string; // parsed when the book is imported and used to locate the file\n  author: string;\n  group?: string; // deprecated in favor of groupId and groupName\n  groupId?: string;\n  groupName?: string;\n  tags?: string[];\n  coverImageUrl?: string | null;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n\n  uploadedAt?: number | null;\n  downloadedAt?: number | null;\n  coverDownloadedAt?: number | null;\n  syncedAt?: number | null;\n\n  lastUpdated?: number; // deprecated in favor of updatedAt\n  progress?: [number, number]; // Add progress field: [current, total], 1-based page number\n  primaryLanguage?: string;\n\n  metadata?: BookMetadata;\n}\n\nexport interface BookGroupType {\n  id: string;\n  name: string;\n}\n\nexport interface PageInfo {\n  current: number;\n  next?: number;\n  total: number;\n}\n\n// Remaining time of the book in minutes\nexport interface TimeInfo {\n  section: number;\n  total: number;\n}\n\nexport interface BookNote {\n  bookHash?: string;\n  metaHash?: string;\n  id: string;\n  type: BookNoteType;\n  cfi: string;\n  text?: string;\n  style?: HighlightStyle;\n  color?: HighlightColor;\n  note: string;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n}\n\nexport interface BooknoteGroup {\n  id: number;\n  href: string;\n  label: string;\n  booknotes: BookNote[];\n}\n\nexport type WritingMode = 'auto' | 'horizontal-tb' | 'horizontal-rl' | 'vertical-rl';\n\nexport interface BookLayout {\n  marginTopPx: number;\n  marginBottomPx: number;\n  marginLeftPx: number;\n  marginRightPx: number;\n  marginPx?: number; // deprecated\n  compactMarginTopPx: number;\n  compactMarginBottomPx: number;\n  compactMarginLeftPx: number;\n  compactMarginRightPx: number;\n  compactMarginPx?: number; // deprecated\n  gapPercent: number;\n  scrolled: boolean;\n  disableClick: boolean;\n  fullscreenClickArea: boolean;\n  swapClickArea: boolean;\n  disableDoubleClick: boolean;\n  volumeKeysToFlip: boolean;\n  continuousScroll: boolean;\n  maxColumnCount: number;\n  maxInlineSize: number;\n  maxBlockSize: number;\n  animated: boolean;\n  isEink: boolean;\n  writingMode: WritingMode;\n  vertical: boolean;\n  rtl: boolean;\n  scrollingOverlap: number;\n  allowScript: boolean;\n}\n\nexport interface BookStyle {\n  zoomLevel: number;\n  paragraphMargin: number;\n  lineHeight: number;\n  wordSpacing: number;\n  letterSpacing: number;\n  textIndent: number;\n  fullJustification: boolean;\n  hyphenation: boolean;\n  invertImgColorInDark: boolean;\n  theme: string;\n  overrideFont: boolean;\n  overrideLayout: boolean;\n  overrideColor: boolean;\n  backgroundTextureId: string;\n  backgroundOpacity: number;\n  backgroundSize: string;\n  codeHighlighting: boolean;\n  codeLanguage: string;\n  userStylesheet: string;\n  userUIStylesheet: string;\n\n  // fixed-layout specific\n  zoomMode: 'fit-page' | 'fit-width' | 'original-size' | 'custom';\n  spreadMode: 'auto' | 'none';\n  keepCoverSpread: boolean;\n}\n\nexport interface BookFont {\n  serifFont: string;\n  sansSerifFont: string;\n  monospaceFont: string;\n  defaultFont: string;\n  defaultCJKFont: string;\n  defaultFontSize: number;\n  minimumFontSize: number;\n  fontWeight: number;\n}\n\nexport type ConvertChineseVariant =\n  | 'none'\n  | 's2t'\n  | 't2s'\n  | 's2tw'\n  | 's2hk'\n  | 's2twp'\n  | 'tw2s'\n  | 'hk2s'\n  | 'tw2sp';\n\nexport interface BookLanguage {\n  replaceQuotationMarks: boolean;\n  convertChineseVariant: ConvertChineseVariant;\n}\n\nexport interface ViewConfig {\n  sideBarTab: string;\n  uiLanguage: string;\n  sortedTOC: boolean;\n\n  doubleBorder: boolean;\n  borderColor: string;\n\n  showHeader: boolean;\n  showFooter: boolean;\n  showRemainingTime: boolean;\n  showRemainingPages: boolean;\n  showProgressInfo: boolean;\n  tapToToggleFooter: boolean;\n  showBarsOnScroll: boolean;\n  showMarginsOnScroll: boolean;\n  progressStyle: 'percentage' | 'fraction';\n  progressInfoMode: 'remaining' | 'progress' | 'all' | 'none';\n}\n\nexport interface TTSConfig {\n  ttsRate: number;\n  ttsVoice: string;\n  ttsLocation: string;\n  showTTSBar: boolean;\n  ttsHighlightOptions: TTSHighlightOptions;\n}\n\nexport interface TranslatorConfig {\n  translationEnabled: boolean;\n  translationProvider: string;\n  translateTargetLang: string;\n  showTranslateSource: boolean;\n  ttsReadAloudText: string;\n}\n\nexport interface NoteExportConfig {\n  includeTitle: boolean;\n  includeAuthor: boolean;\n  includeDate: boolean;\n  includeChapterTitles: boolean;\n  includeQuotes: boolean;\n  includeNotes: boolean;\n  includeTimestamp: boolean;\n  includeChapterSeparator: boolean;\n  noteSeparator: string;\n  useCustomTemplate: boolean;\n  customTemplate: string;\n}\n\nexport interface AnnotatorConfig {\n  enableAnnotationQuickActions: boolean;\n  annotationQuickAction: AnnotationToolType | null;\n  copyToNotebook: boolean;\n  noteExportConfig: NoteExportConfig;\n}\n\nexport interface ScreenConfig {\n  screenOrientation: 'auto' | 'portrait' | 'landscape';\n}\n\nexport type ProofreadScope = 'selection' | 'book' | 'library';\n\nexport interface ProofreadRule {\n  id: string;\n  scope: ProofreadScope;\n  pattern: string;\n  replacement: string;\n  cfi?: string;\n  sectionHref?: string;\n  enabled: boolean;\n  isRegex: boolean;\n  order: number; // Lower numbers apply first\n  wholeWord?: boolean; // Match whole words only (uses \\b word boundaries)\n  caseSensitive?: boolean; // Case-sensitive matching (default true)\n  onlyForTTS?: boolean; // Only replace text for TTS, not in the book display (only for book/library scope)\n}\n\nexport interface ProofreadRulesConfig {\n  proofreadRules?: ProofreadRule[];\n}\n\nexport interface ViewSettings\n  extends BookLayout,\n  BookStyle,\n  BookFont,\n  BookLanguage,\n  ViewConfig,\n  TTSConfig,\n  TranslatorConfig,\n  ScreenConfig,\n  ProofreadRulesConfig,\n  AnnotatorConfig { }\n\nexport interface BookProgress {\n  location: string;\n  sectionId: number;\n  sectionHref: string;\n  sectionLabel: string;\n  section: PageInfo;\n  pageinfo: PageInfo;\n  timeinfo: TimeInfo;\n  range: Range;\n}\n\nexport interface BookSearchConfig {\n  scope: 'book' | 'section';\n  matchCase: boolean;\n  matchWholeWords: boolean;\n  matchDiacritics: boolean;\n  index?: number;\n  query?: string;\n  acceptNode?: (node: Node) => number;\n\n  // pre-cached search results\n  results?: BookSearchResult[] | BookSearchMatch[] | null;\n}\n\nexport interface SearchExcerpt {\n  pre: string;\n  match: string;\n  post: string;\n}\n\nexport interface BookSearchMatch {\n  cfi: string;\n  excerpt: SearchExcerpt;\n}\n\nexport interface BookSearchResult {\n  index?: number;\n  label: string;\n  subitems: BookSearchMatch[];\n  progress?: number;\n}\n\nexport interface BookConfig {\n  bookHash?: string;\n  metaHash?: string;\n  progress?: [number, number]; // [current pagenum, total pagenum], 1-based page number\n  location?: string; // CFI of the current location\n  xpointer?: string; // XPointer of the current location (for Koreader interoperability)\n  booknotes?: BookNote[];\n  searchConfig?: Partial<BookSearchConfig>;\n  viewSettings?: Partial<ViewSettings>;\n\n  lastSyncedAtConfig?: number;\n  lastSyncedAtNotes?: number;\n\n  updatedAt: number;\n}\n\nexport interface BookDataRecord {\n  id: string;\n  book_hash: string;\n  meta_hash?: string;\n  user_id: string;\n  updated_at: number | null;\n  deleted_at: number | null;\n}\n\nexport interface BooksGroup {\n  id: string;\n  name: string;\n  displayName: string;\n  books: Book[];\n\n  updatedAt: number;\n}\nexport interface BookContent {\n  book: Book;\n  file: File;\n}\n","import { BookFormat } from '@/types/book';\nimport { Contributor, Identifier, LanguageMap } from '@/utils/book';\nimport * as epubcfi from 'foliate-js/epubcfi.js';\n\nexport const CFI = epubcfi;\n\nexport type DocumentFile = File;\n\nexport type Location = {\n  current: number;\n  next: number;\n  total: number;\n};\n\nexport interface TOCItem {\n  id: number;\n  label: string;\n  href: string;\n  cfi?: string;\n  location?: Location;\n  subitems?: TOCItem[];\n}\n\nexport interface SectionItem {\n  id: string;\n  cfi: string;\n  size: number;\n  linear: string;\n  location?: Location;\n  pageSpread?: 'left' | 'right' | 'center' | '';\n\n  createDocument: () => Promise<Document>;\n}\n\nexport type BookMetadata = {\n  // NOTE: the title and author fields should be formatted\n  title: string | LanguageMap;\n  author: string | Contributor;\n  language: string | string[];\n  editor?: string;\n  publisher?: string;\n  published?: string;\n  description?: string;\n  subject?: string | string[] | Contributor;\n  identifier?: string;\n  altIdentifier?: string | string[] | Identifier;\n\n  subtitle?: string;\n  series?: string;\n  seriesIndex?: number;\n  seriesTotal?: number;\n\n  coverImageFile?: string;\n  coverImageUrl?: string;\n  coverImageBlobUrl?: string;\n};\n\nexport interface BookDoc {\n  metadata: BookMetadata;\n  rendition?: {\n    layout?: 'pre-paginated' | 'reflowable';\n    spread?: 'auto' | 'none';\n    viewport?: { width: number; height: number };\n  };\n  dir: string;\n  toc?: Array<TOCItem>;\n  sections?: Array<SectionItem>;\n  transformTarget?: EventTarget;\n  splitTOCHref(href: string): Array<string | number>;\n  getCover(): Promise<Blob | null>;\n}\n\nexport const EXTS: Record<BookFormat, string> = {\n  EPUB: 'epub',\n  PDF: 'pdf',\n  MOBI: 'mobi',\n  AZW: 'azw',\n  AZW3: 'azw3',\n  CBZ: 'cbz',\n  FB2: 'fb2',\n  FBZ: 'fbz',\n  TXT: 'txt',\n  MD: 'md',\n};\n\nexport const MIMETYPES: Record<BookFormat, string[]> = {\n  EPUB: ['application/epub+zip'],\n  PDF: ['application/pdf'],\n  MOBI: ['application/x-mobipocket-ebook'],\n  AZW: ['application/vnd.amazon.ebook'],\n  AZW3: ['application/vnd.amazon.mobi8-ebook', 'application/x-mobi8-ebook'],\n  CBZ: ['application/vnd.comicbook+zip', 'application/zip', 'application/x-cbz'],\n  FB2: ['application/x-fictionbook+xml', 'text/xml', 'application/xml'],\n  FBZ: ['application/x-zip-compressed-fb2', 'application/zip'],\n  TXT: ['text/plain'],\n  MD: ['text/markdown', 'text/x-markdown'],\n};\n\nexport class DocumentLoader {\n  private file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  private async isZip(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 4).arrayBuffer());\n    return arr[0] === 0x50 && arr[1] === 0x4b && arr[2] === 0x03 && arr[3] === 0x04;\n  }\n\n  private async isPDF(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 5).arrayBuffer());\n    return (\n      arr[0] === 0x25 && arr[1] === 0x50 && arr[2] === 0x44 && arr[3] === 0x46 && arr[4] === 0x2d\n    );\n  }\n\n  private async makeZipLoader() {\n    const getComment = async (): Promise<string | null> => {\n      const EOCD_SIGNATURE = [0x50, 0x4b, 0x05, 0x06];\n      const maxEOCDSearch = 1024 * 64;\n\n      const sliceSize = Math.min(maxEOCDSearch, this.file.size);\n      const tail = await this.file.slice(this.file.size - sliceSize, this.file.size).arrayBuffer();\n      const bytes = new Uint8Array(tail);\n\n      for (let i = bytes.length - 22; i >= 0; i--) {\n        if (\n          bytes[i] === EOCD_SIGNATURE[0] &&\n          bytes[i + 1] === EOCD_SIGNATURE[1] &&\n          bytes[i + 2] === EOCD_SIGNATURE[2] &&\n          bytes[i + 3] === EOCD_SIGNATURE[3]\n        ) {\n          const commentLength = bytes[i + 20]! + (bytes[i + 21]! << 8);\n          const commentStart = i + 22;\n          const commentBytes = bytes.slice(commentStart, commentStart + commentLength);\n          return new TextDecoder().decode(commentBytes);\n        }\n      }\n\n      return null;\n    };\n\n    const { configure, ZipReader, BlobReader, TextWriter, BlobWriter } = await import(\n      '@zip.js/zip.js'\n    );\n    type Entry = import('@zip.js/zip.js').Entry;\n    configure({ useWebWorkers: false });\n    const reader = new ZipReader(new BlobReader(this.file));\n    const entries = await reader.getEntries();\n    const map = new Map(entries.map((entry) => [entry.filename, entry]));\n    const load =\n      (f: (entry: Entry, type?: string) => Promise<string | Blob> | null) =>\n      (name: string, ...args: [string?]) =>\n        map.has(name) ? f(map.get(name)!, ...args) : null;\n\n    const loadText = load((entry: Entry) =>\n      entry.getData ? entry.getData(new TextWriter()) : null,\n    );\n    const loadBlob = load((entry: Entry, type?: string) =>\n      entry.getData ? entry.getData(new BlobWriter(type!)) : null,\n    );\n    const getSize = (name: string) => map.get(name)?.uncompressedSize ?? 0;\n\n    return { entries, loadText, loadBlob, getSize, getComment, sha1: undefined };\n  }\n\n  private isCBZ(): boolean {\n    return (\n      this.file.type === 'application/vnd.comicbook+zip' || this.file.name.endsWith(`.${EXTS.CBZ}`)\n    );\n  }\n\n  private isFB2(): boolean {\n    return (\n      this.file.type === 'application/x-fictionbook+xml' || this.file.name.endsWith(`.${EXTS.FB2}`)\n    );\n  }\n\n  private isFBZ(): boolean {\n    return (\n      this.file.type === 'application/x-zip-compressed-fb2' ||\n      this.file.name.endsWith('.fb.zip') ||\n      this.file.name.endsWith('.fb2.zip') ||\n      this.file.name.endsWith(`.${EXTS.FBZ}`)\n    );\n  }\n\n  public async open(): Promise<{ book: BookDoc; format: BookFormat }> {\n    let book = null;\n    let format: BookFormat = 'EPUB';\n    if (!this.file.size) {\n      throw new Error('File is empty');\n    }\n    try {\n      if (await this.isZip()) {\n        const loader = await this.makeZipLoader();\n        const { entries } = loader;\n\n        if (this.isCBZ()) {\n          const { makeComicBook } = await import('foliate-js/comic-book.js');\n          book = await makeComicBook(loader, this.file);\n          format = 'CBZ';\n        } else if (this.isFBZ()) {\n          const entry = entries.find((entry) => entry.filename.endsWith(`.${EXTS.FB2}`));\n          const blob = await loader.loadBlob((entry ?? entries[0]!).filename);\n          const { makeFB2 } = await import('foliate-js/fb2.js');\n          book = await makeFB2(blob);\n          format = 'FBZ';\n        } else {\n          const { EPUB } = await import('foliate-js/epub.js');\n          book = await new EPUB(loader).init();\n          format = 'EPUB';\n        }\n      } else if (await this.isPDF()) {\n        const { makePDF } = await import('foliate-js/pdf.js');\n        book = await makePDF(this.file);\n        format = 'PDF';\n      } else if (await (await import('foliate-js/mobi.js')).isMOBI(this.file)) {\n        const fflate = await import('foliate-js/vendor/fflate.js');\n        const { MOBI } = await import('foliate-js/mobi.js');\n        book = await new MOBI({ unzlib: fflate.unzlibSync }).open(this.file);\n        const ext = this.file.name.split('.').pop()?.toLowerCase();\n        switch (ext) {\n          case 'azw':\n            format = 'AZW';\n            break;\n          case 'azw3':\n            format = 'AZW3';\n            break;\n          default:\n            format = 'MOBI';\n        }\n      } else if (this.isFB2()) {\n        const { makeFB2 } = await import('foliate-js/fb2.js');\n        book = await makeFB2(this.file);\n        format = 'FB2';\n      }\n    } catch (e: unknown) {\n      console.error('Failed to open document:', e);\n      if (e instanceof Error && e.message?.includes('not a valid zip')) {\n        throw new Error('Unsupported or corrupted book file');\n      }\n      throw e;\n    }\n    return { book, format } as { book: BookDoc; format: BookFormat };\n  }\n}\n\nexport const getDirection = (doc: Document) => {\n  const { defaultView } = doc;\n  const { writingMode, direction } = defaultView!.getComputedStyle(doc.body);\n  const vertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr';\n  const rtl = doc.body.dir === 'rtl' || direction === 'rtl' || doc.documentElement.dir === 'rtl';\n  return { vertical, rtl };\n};\n\nexport const getFileExtFromMimeType = (mimeType?: string): string => {\n  if (!mimeType) return '';\n\n  for (const format in MIMETYPES) {\n    const list = MIMETYPES[format as BookFormat];\n    if (list.includes(mimeType)) {\n      return EXTS[format as BookFormat];\n    }\n  }\n  return '';\n};\n\nexport const getMimeTypeFromFileExt = (ext: string): string => {\n  ext = ext.toLowerCase();\n  for (const format in EXTS) {\n    if (EXTS[format as BookFormat] === ext) {\n      const mimeTypes = MIMETYPES[format as BookFormat];\n      return mimeTypes[0] || 'application/octet-stream';\n    }\n  }\n  return 'application/octet-stream';\n};\n","import { LocaleWithTextInfo } from '@/types/misc';\nimport { franc } from 'franc-min';\nimport { iso6392 } from 'iso-639-2';\nimport { iso6393To1 } from 'iso-639-3';\n\nexport const isCJKStr = (str: string) => {\n  return /[\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}]/u.test(str ?? '');\n};\n\nexport const isCJKLang = (lang: string | null | undefined): boolean => {\n  if (!lang) return false;\n  const normalizedLang = normalizedLangCode(lang);\n  return ['zh', 'ja', 'ko', 'zho', 'jpn', 'kor'].includes(normalizedLang);\n};\n\nconst ZH_SCRIPTS_MAPPING: Record<string, string> = {\n  zh: 'zh-Hans',\n  'zh-cn': 'zh-Hans',\n  'zh-hk': 'zh-Hant',\n  'zh-tw': 'zh-Hant',\n  'zh-mo': 'zh-Hant',\n  'zh-hans': 'zh-Hans',\n  'zh-hant': 'zh-Hant',\n};\n\nexport const normalizeToFullLang = (langCode: string): string => {\n  try {\n    const locale = new Intl.Locale(langCode.toLowerCase());\n    const maximized = locale.maximize();\n\n    if (maximized.language === 'zh') {\n      return maximized.script === 'Hant' ? 'zh-Hant' : 'zh-Hans';\n    }\n\n    return maximized.region ? `${maximized.language}-${maximized.region}` : langCode;\n  } catch {\n    return ZH_SCRIPTS_MAPPING[langCode.toLowerCase()] || langCode;\n  }\n};\n\nexport const normalizeToShortLang = (langCode: string): string => {\n  const lang = langCode.toLowerCase();\n  if (lang.startsWith('zh')) {\n    return ZH_SCRIPTS_MAPPING[lang] || 'zh-Hans';\n  }\n  return lang.split('-')[0]!;\n};\n\nexport const normalizedLangCode = (lang: string | null | undefined): string => {\n  if (!lang) return '';\n  return lang.split('-')[0]!.toLowerCase();\n};\n\nexport const isSameLang = (lang1?: string | null, lang2?: string | null): boolean => {\n  if (!lang1 || !lang2) return false;\n  const normalizedLang1 = normalizedLangCode(lang1);\n  const normalizedLang2 = normalizedLangCode(lang2);\n  return normalizedLang1 === normalizedLang2;\n};\n\nexport const isValidLang = (lang?: string) => {\n  if (!lang) return false;\n  if (typeof lang !== 'string') return false;\n  if (['und', 'mul', 'mis', 'zxx'].includes(lang)) return false;\n  const code = normalizedLangCode(lang);\n  return iso6392.some((l) => l.iso6391 === code || l.iso6392B === code);\n};\n\nexport const code6392to6391 = (code: string): string => {\n  const lang = iso6392.find((l) => l.iso6392B === code);\n  return lang?.iso6391 || '';\n};\n\nconst commonIndivToMacro: Record<string, string> = {\n  cmn: 'zho',\n  arb: 'ara',\n  arz: 'ara',\n  ind: 'msa',\n  zsm: 'msa',\n  nob: 'nor',\n  nno: 'nor',\n  pes: 'fas',\n  quy: 'que',\n};\n\nexport const code6393to6391 = (code: string): string => {\n  const macro = commonIndivToMacro[code] || code;\n  return iso6393To1[macro] || '';\n};\n\nexport const getLanguageName = (code: string): string => {\n  const lang = normalizedLangCode(code);\n  const language = iso6392.find((l) => l.iso6391 === lang || l.iso6392B === lang);\n  return language ? language.name : lang;\n};\n\nexport const inferLangFromScript = (text: string, lang: string): string => {\n  if (!lang || lang === 'en') {\n    if (/[\\p{Script=Hangul}]/u.test(text)) {\n      return 'ko';\n    } else if (/[\\p{Script=Hiragana}\\p{Script=Katakana}]/u.test(text)) {\n      return 'ja';\n    } else if (/[\\p{Script=Han}]/u.test(text)) {\n      return 'zh';\n    }\n  }\n  return lang;\n};\n\nexport const detectLanguage = (content: string): string => {\n  try {\n    const iso6393Lang = franc(content.substring(0, 1000));\n    const iso6391Lang = code6393to6391(iso6393Lang) || 'en';\n    return iso6391Lang;\n  } catch {\n    console.warn('Language detection failed, defaulting to en.');\n    return 'en';\n  }\n};\n\nexport const getLanguageInfo = (lang: string) => {\n  if (!lang) return {};\n  try {\n    const canonical = Intl.getCanonicalLocales(lang)[0]!;\n    const locale = new Intl.Locale(canonical) as LocaleWithTextInfo;\n    const isCJK = ['zh', 'ja', 'kr'].includes(locale.language);\n    const direction = (locale.getTextInfo?.() ?? locale.textInfo)?.direction;\n    return { canonical, locale, isCJK, direction };\n  } catch (e) {\n    console.warn(e);\n    return {};\n  }\n};\n","import { BookMetadata, EXTS } from '@/libs/document';\nimport { Book, BookConfig, BookProgress, WritingMode } from '@/types/book';\nimport { SUPPORTED_LANGS } from '@/services/constants';\nimport { getUserLang } from './misc';\nimport { getDirFromLanguage } from './rtl';\nimport { code6392to6391, isValidLang, normalizedLangCode } from './lang';\nimport { md5 } from './md5';\n\nexport const getDir = (book: Book) => {\n  // In local storage mode, return the folder name (same as book name without extension)\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath.replace(/\\.[^.]+$/, '');\n};\nexport const getLibraryFilename = () => {\n  return 'library.json';\n};\nexport const getLibraryBackupFilename = () => {\n  return 'library_backup.json';\n};\nexport const getLocalBookFilename = (book: Book) => {\n  // In local storage mode, books are stored in their original relative paths\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath;\n};\nexport const getCoverFilename = (book: Book) => {\n  // In local storage mode, covers are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  const result = `${pathWithoutExt}/cover.png`;\n  console.log('[getCoverFilename] ✓ Using relativePath:', book.relativePath);\n  console.log('[getCoverFilename] ✓ Cover path result:', result);\n  return result;\n};\nexport const getConfigFilename = (book: Book) => {\n  // In local storage mode, configs are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  return `${pathWithoutExt}/config.json`;\n};\nexport const isBookFile = (filename: string) => {\n  return Object.values(EXTS).includes(filename.split('.').pop()!);\n};\n\nexport const INIT_BOOK_CONFIG: BookConfig = {\n  updatedAt: 0,\n};\n\nexport interface LanguageMap {\n  [key: string]: string;\n}\n\nexport interface Identifier {\n  scheme: string;\n  value: string;\n}\n\nexport interface Contributor {\n  name: LanguageMap;\n}\n\nconst formatLanguageMap = (x: string | LanguageMap, defaultLang = false): string => {\n  const userLang = getUserLang();\n  if (!x) return '';\n  if (typeof x === 'string') return x;\n  const keys = Object.keys(x);\n  return defaultLang ? x[keys[0]!]! : x[userLang] || x[keys[0]!]!;\n};\n\nexport const listFormater = (narrow = false, lang = '') => {\n  lang = lang ? lang : getUserLang();\n  if (narrow) {\n    return new Intl.ListFormat('en', { style: 'narrow', type: 'unit' });\n  } else {\n    return new Intl.ListFormat(lang, { style: 'long', type: 'conjunction' });\n  }\n};\n\nexport const getBookLangCode = (lang: string | string[] | undefined) => {\n  try {\n    const bookLang = typeof lang === 'string' ? lang : lang?.[0];\n    return bookLang ? bookLang.split('-')[0]! : '';\n  } catch {\n    return '';\n  }\n};\n\nexport const flattenContributors = (\n  contributors: string | string[] | Contributor | Contributor[],\n) => {\n  if (!contributors) return '';\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string' ? contributor : formatLanguageMap(contributor?.name),\n      )\n      .join(', ')\n    : typeof contributors === 'string'\n      ? contributors\n      : formatLanguageMap(contributors?.name);\n};\n\n// prettier-ignore\nconst LASTNAME_AUTHOR_SORT_LANGS = ['ar', 'bo', 'de', 'en', 'es', 'fr', 'hi', 'it', 'nl', 'pl', 'pt', 'ru', 'th', 'tr', 'uk'];\n\nconst formatAuthorName = (name: string, lastNameFirst: boolean) => {\n  if (!name) return '';\n  const parts = name.split(' ');\n  if (lastNameFirst && parts.length > 1) {\n    return `${parts[parts.length - 1]}, ${parts.slice(0, -1).join(' ')}`;\n  }\n  return name;\n};\n\nexport const formatAuthors = (\n  contributors: string | string[] | Contributor | Contributor[],\n  bookLang?: string | string[],\n  sortAs?: boolean,\n) => {\n  const langCode = getBookLangCode(bookLang) || 'en';\n  const lastNameFirst = !!sortAs && LASTNAME_AUTHOR_SORT_LANGS.includes(langCode);\n  return Array.isArray(contributors)\n    ? listFormater(langCode === 'zh', langCode).format(\n      contributors.map((contributor) =>\n        typeof contributor === 'string'\n          ? formatAuthorName(contributor, lastNameFirst)\n          : formatAuthorName(formatLanguageMap(contributor?.name), lastNameFirst),\n      ),\n    )\n    : typeof contributors === 'string'\n      ? formatAuthorName(contributors, lastNameFirst)\n      : formatAuthorName(formatLanguageMap(contributors?.name), lastNameFirst);\n};\n\nexport const formatTitle = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title);\n};\n\nexport const formatDescription = (description?: string | LanguageMap) => {\n  if (!description) return '';\n  const text = typeof description === 'string' ? description : formatLanguageMap(description);\n  return text\n    .replace(/<\\/?[^>]+(>|$)/g, '')\n    .replace(/&#\\d+;/g, '')\n    .trim();\n};\n\nexport const formatPublisher = (publisher: string | LanguageMap) => {\n  return typeof publisher === 'string' ? publisher : formatLanguageMap(publisher);\n};\n\nconst langCodeToLangName = (langCode: string) => {\n  return SUPPORTED_LANGS[langCode] || langCode.toUpperCase();\n};\n\nexport const formatLanguage = (lang: string | string[] | undefined): string => {\n  return Array.isArray(lang)\n    ? lang.map(langCodeToLangName).join(', ')\n    : langCodeToLangName(lang || '');\n};\n\n// Should return valid ISO-639-1 language code, fallback to 'en' if not valid\nexport const getPrimaryLanguage = (lang: string | string[] | undefined) => {\n  const primaryLang = Array.isArray(lang) ? lang[0] : lang;\n  if (isValidLang(primaryLang)) {\n    const normalizedLang = normalizedLangCode(primaryLang);\n    return code6392to6391(normalizedLang) || normalizedLang;\n  }\n  return 'en';\n};\n\nexport const formatDate = (date: string | number | Date | null | undefined, isUTC = false) => {\n  if (!date) return;\n  const userLang = getUserLang();\n  try {\n    return new Date(date).toLocaleDateString(userLang, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      timeZone: isUTC ? 'UTC' : undefined,\n    });\n  } catch {\n    return;\n  }\n};\n\nexport const formatBytes = (bytes?: number | null, locale = 'en-US') => {\n  if (!bytes) return '';\n  const units = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte'];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  const value = bytes / Math.pow(1024, i);\n  const formatter = new Intl.NumberFormat(locale, {\n    style: 'unit',\n    unit: units[i],\n    unitDisplay: 'short',\n    maximumFractionDigits: 2,\n  });\n  return formatter.format(value);\n};\n\nexport const getCurrentPage = (book: Book, progress: BookProgress) => {\n  const bookFormat = book.format;\n  const { section, pageinfo } = progress;\n  return bookFormat === 'PDF'\n    ? section\n      ? section.current + 1\n      : 0\n    : pageinfo\n      ? pageinfo.current + 1\n      : 0;\n};\n\nexport const getBookDirFromWritingMode = (writingMode: WritingMode) => {\n  switch (writingMode) {\n    case 'horizontal-tb':\n      return 'ltr';\n    case 'horizontal-rl':\n    case 'vertical-rl':\n      return 'rtl';\n    default:\n      return 'auto';\n  }\n};\n\nexport const getBookDirFromLanguage = (language: string | string[] | undefined) => {\n  const lang = getPrimaryLanguage(language) || '';\n  return getDirFromLanguage(lang);\n};\n\nconst getTitleForHash = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title, true);\n};\n\nconst getAuthorsList = (contributors: string | string[] | Contributor | Contributor[]) => {\n  if (!contributors) return [];\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string'\n          ? contributor\n          : formatLanguageMap(contributor?.name, true),\n      )\n      .filter(Boolean)\n    : [\n      typeof contributors === 'string'\n        ? contributors\n        : formatLanguageMap(contributors?.name, true),\n    ];\n};\n\nconst normalizeIdentifier = (identifier: string) => {\n  try {\n    if (identifier.includes('urn:')) {\n      // Slice after the last ':'\n      return identifier.match(/[^:]+$/)?.[0] || '';\n    } else if (identifier.includes(':')) {\n      // Slice after the first ':'\n      return identifier.match(/^[^:]+:(.+)$/)?.[1] || '';\n    }\n  } catch {\n    return identifier;\n  }\n  return identifier;\n};\n\nconst getPreferredIdentifier = (identifiers: string[] | Identifier[]) => {\n  for (const scheme of ['uuid', 'calibre', 'isbn']) {\n    const found = identifiers.find((identifier) =>\n      typeof identifier === 'string'\n        ? identifier.toLowerCase().includes(scheme)\n        : identifier.scheme.toLowerCase() === scheme,\n    );\n    if (found) {\n      return typeof found === 'string' ? normalizeIdentifier(found) : found.value;\n    }\n  }\n  return;\n};\n\nconst getIdentifiersList = (\n  identifiers: undefined | string | string[] | Identifier | Identifier[],\n) => {\n  if (!identifiers) return [];\n  if (Array.isArray(identifiers)) {\n    const preferred = getPreferredIdentifier(identifiers);\n    if (preferred) {\n      return [preferred];\n    }\n  }\n  return Array.isArray(identifiers)\n    ? identifiers\n      .map((identifier) =>\n        typeof identifier === 'string' ? normalizeIdentifier(identifier) : identifier.value,\n      )\n      .filter(Boolean)\n    : typeof identifiers === 'string'\n      ? [normalizeIdentifier(identifiers)]\n      : [identifiers.value];\n};\n\nexport const getMetadataHash = (metadata: BookMetadata) => {\n  try {\n    const title = getTitleForHash(metadata.title);\n    const authors = getAuthorsList(metadata.author).join(',');\n    const identifiers = getIdentifiersList(metadata.altIdentifier || metadata.identifier).join(',');\n    const hashSource = `${title}|${authors}|${identifiers}`;\n    const metaHash = md5(hashSource.normalize('NFC'));\n    return metaHash;\n  } catch (error) {\n    console.error('Error generating metadata hash:', error);\n  }\n  return;\n};\n","import { invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Make HTTP requests with the Rust backend.\n *\n * ## Security\n *\n * This API has a scope configuration that forces you to restrict the URLs that can be accessed using glob patterns.\n *\n * For instance, this scope configuration only allows making HTTP requests to all subdomains for `tauri.app` except for `https://private.tauri.app`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"http:default\",\n *       \"allow\": [{ \"url\": \"https://*.tauri.app\" }],\n *       \"deny\": [{ \"url\": \"https://private.tauri.app\" }]\n *     }\n *   ]\n * }\n * ```\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nconst ERROR_REQUEST_CANCELLED = 'Request cancelled';\n/**\n * Fetch a resource from the network. It returns a `Promise` that resolves to the\n * `Response` to that `Request`, whether it is successful or not.\n *\n * @example\n * ```typescript\n * const response = await fetch(\"http://my.json.host/data.json\");\n * console.log(response.status);  // e.g. 200\n * console.log(response.statusText); // e.g. \"OK\"\n * const jsonData = await response.json();\n * ```\n *\n * @since 2.0.0\n */\nasync function fetch(input, init) {\n    // Optimistically check for abort signal and avoid doing any work\n    const signal = init?.signal;\n    if (signal?.aborted) {\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    const maxRedirections = init?.maxRedirections;\n    const connectTimeout = init?.connectTimeout;\n    const proxy = init?.proxy;\n    const danger = init?.danger;\n    // Remove these fields before creating the request\n    if (init) {\n        delete init.maxRedirections;\n        delete init.connectTimeout;\n        delete init.proxy;\n        delete init.danger;\n    }\n    const headers = init?.headers\n        ? init.headers instanceof Headers\n            ? init.headers\n            : new Headers(init.headers)\n        : new Headers();\n    const req = new Request(input, init);\n    const buffer = await req.arrayBuffer();\n    const data = buffer.byteLength !== 0 ? Array.from(new Uint8Array(buffer)) : null;\n    // append new headers created by the browser `Request` implementation,\n    // if not already declared by the caller of this function\n    for (const [key, value] of req.headers) {\n        if (!headers.get(key)) {\n            headers.set(key, value);\n        }\n    }\n    const headersArray = headers instanceof Headers\n        ? Array.from(headers.entries())\n        : Array.isArray(headers)\n            ? headers\n            : Object.entries(headers);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const mappedHeaders = headersArray.map(([name, val]) => [\n        name,\n        // we need to ensure we have all header values as strings\n        // eslint-disable-next-line\n        typeof val === 'string' ? val : val.toString()\n    ]);\n    // Optimistically check for abort signal and avoid doing any work on the Rust side\n    if (signal?.aborted) {\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    const rid = await invoke('plugin:http|fetch', {\n        clientConfig: {\n            method: req.method,\n            url: req.url,\n            headers: mappedHeaders,\n            data,\n            maxRedirections,\n            connectTimeout,\n            proxy,\n            danger\n        }\n    });\n    const abort = () => invoke('plugin:http|fetch_cancel', { rid });\n    // Optimistically check for abort signal\n    // and avoid doing any work after doing intial work on the Rust side\n    if (signal?.aborted) {\n        // we don't care about the result of this proimse\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        abort();\n        throw new Error(ERROR_REQUEST_CANCELLED);\n    }\n    signal?.addEventListener('abort', () => void abort());\n    const { status, statusText, url, headers: responseHeaders, rid: responseRid } = await invoke('plugin:http|fetch_send', {\n        rid\n    });\n    const dropBody = () => {\n        return invoke('plugin:http|fetch_cancel_body', { rid: responseRid });\n    };\n    const readChunk = async (controller) => {\n        let data;\n        try {\n            data = await invoke('plugin:http|fetch_read_body', {\n                rid: responseRid\n            });\n        }\n        catch (e) {\n            // close the stream if an error occurs\n            // and drop the body on Rust side\n            controller.error(e);\n            void dropBody();\n            return;\n        }\n        const dataUint8 = new Uint8Array(data);\n        const lastByte = dataUint8[dataUint8.byteLength - 1];\n        const actualData = dataUint8.slice(0, dataUint8.byteLength - 1);\n        // close when the signal to close (last byte is 1) is sent from the IPC.\n        if (lastByte === 1) {\n            controller.close();\n            return;\n        }\n        controller.enqueue(actualData);\n    };\n    // no body for 101, 103, 204, 205 and 304\n    // see https://fetch.spec.whatwg.org/#null-body-status\n    const body = [101, 103, 204, 205, 304].includes(status)\n        ? null\n        : new ReadableStream({\n            start: (controller) => {\n                // listen for abort events to cancel reading\n                signal?.addEventListener('abort', () => {\n                    controller.error(ERROR_REQUEST_CANCELLED);\n                    void dropBody();\n                });\n            },\n            pull: (controller) => readChunk(controller)\n        });\n    const res = new Response(body, {\n        status,\n        statusText\n    });\n    // Set `Response` properties that are ignored by the\n    // constructor, like url and some headers\n    //\n    // Since url and headers are read only properties\n    // this is the only way to set them.\n    Object.defineProperty(res, 'url', { value: url });\n    Object.defineProperty(res, 'headers', {\n        value: new Headers(responseHeaders)\n    });\n    return res;\n}\n\nexport { fetch };\n","import { BookConfig, BookSearchConfig, ViewSettings } from '@/types/book';\n\nexport const serializeConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  config = JSON.parse(JSON.stringify(config));\n  const viewSettings = config.viewSettings as Partial<ViewSettings>;\n  const searchConfig = config.searchConfig as Partial<BookSearchConfig>;\n  config.viewSettings = Object.entries(viewSettings).reduce(\n    (acc: Partial<Record<keyof ViewSettings, unknown>>, [key, value]) => {\n      if (globalViewSettings[key as keyof ViewSettings] !== value) {\n        acc[key as keyof ViewSettings] = value;\n      }\n      return acc;\n    },\n    {} as Partial<Record<keyof ViewSettings, unknown>>,\n  ) as Partial<ViewSettings>;\n  config.searchConfig = Object.entries(searchConfig).reduce(\n    (acc: Partial<Record<keyof BookSearchConfig, unknown>>, [key, value]) => {\n      if (defaultSearchConfig[key as keyof BookSearchConfig] !== value) {\n        acc[key as keyof BookSearchConfig] = value;\n      }\n      return acc;\n    },\n    {} as Partial<BookSearchConfig>,\n  ) as Partial<BookSearchConfig>;\n\n  return JSON.stringify(config);\n};\n\nexport const deserializeConfig = (\n  str: string,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): BookConfig => {\n  const config = JSON.parse(str) as BookConfig;\n  const { viewSettings, searchConfig } = config;\n  config.viewSettings = { ...globalViewSettings, ...viewSettings };\n  config.searchConfig = { ...defaultSearchConfig, ...searchConfig };\n  config.updatedAt ??= Date.now();\n  return config;\n};\n\nexport const compressConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  return JSON.parse(serializeConfig(config, globalViewSettings, defaultSearchConfig));\n};\n"],"names":[],"mappings":"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","ignoreList":[4]}
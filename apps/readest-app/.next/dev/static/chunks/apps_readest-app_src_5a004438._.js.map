{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/file.ts"],"sourcesContent":["import { FileHandle, open, BaseDirectory, SeekMode } from '@tauri-apps/plugin-fs';\nimport { getOSPlatform } from './misc';\n\nclass DeferredBlob extends Blob {\n  #dataPromise: Promise<ArrayBuffer>;\n  #type: string;\n\n  constructor(dataPromise: Promise<ArrayBuffer>, type: string) {\n    super();\n    this.#dataPromise = dataPromise;\n    this.#type = type;\n  }\n\n  override async arrayBuffer() {\n    const data = await this.#dataPromise;\n    return data;\n  }\n\n  override async text() {\n    const data = await this.#dataPromise;\n    return new TextDecoder().decode(data);\n  }\n\n  override stream() {\n    return new ReadableStream({\n      start: async (controller) => {\n        const data = await this.#dataPromise;\n        const reader = new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(data));\n            controller.close();\n          },\n        }).getReader();\n        const pump = () =>\n          reader.read().then(({ done, value }): Promise<void> => {\n            if (done) {\n              controller.close();\n              return Promise.resolve();\n            }\n            controller.enqueue(value);\n            return pump();\n          });\n        return pump();\n      },\n    });\n  }\n\n  override get type() {\n    return this.#type;\n  }\n}\n\nexport interface ClosableFile extends File {\n  open(): Promise<this>;\n  close(): Promise<void>;\n}\n\nexport class NativeFile extends File implements ClosableFile {\n  #handle: FileHandle | null = null;\n  #fp: string;\n  #name: string;\n  #baseDir: BaseDirectory | null;\n  #lastModified: number = 0;\n  #size: number = -1;\n  #type: string = '';\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 1024;\n  static MAX_CACHE_ITEMS_SIZE = 50;\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map();\n  #pendingReads: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  constructor(fp: string, name?: string, baseDir: BaseDirectory | null = null, type = '') {\n    super([], name || fp, { type });\n    this.#fp = fp;\n    this.#baseDir = baseDir;\n    this.#name = name || fp;\n  }\n\n  async open() {\n    this.#handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    const stats = await this.#handle.stat();\n    this.#size = stats.size;\n    this.#lastModified = stats.mtime ? stats.mtime.getTime() : Date.now();\n    return this;\n  }\n\n  async close() {\n    if (this.#handle) {\n      await this.#handle.close();\n      this.#handle = null;\n    }\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async stat() {\n    return this.#handle?.stat();\n  }\n\n  async seek(offset: number, whence: SeekMode): Promise<number> {\n    if (!this.#handle) {\n      throw new Error('File handle is not open');\n    }\n    return this.#handle.seek(offset, whence);\n  }\n\n  // exclusive reading of the end: [start, end)\n  async readData(start: number, end: number): Promise<ArrayBuffer> {\n    start = Math.max(0, start);\n    end = Math.max(start, Math.min(this.size, end));\n    const size = end - start;\n\n    if (size > NativeFile.MAX_CACHE_CHUNK_SIZE) {\n      const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n      try {\n        await handle.seek(start, SeekMode.Start);\n        const buffer = new Uint8Array(size);\n        await handle.read(buffer);\n        return buffer.buffer;\n      } finally {\n        await handle.close();\n      }\n    }\n\n    const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n      const buffer = this.#cache.get(chunkStart)!;\n      return start >= chunkStart && end <= chunkStart + buffer.byteLength;\n    });\n\n    if (cachedChunkStart !== undefined) {\n      this.#updateAccessOrder(cachedChunkStart);\n      const buffer = this.#cache.get(cachedChunkStart)!;\n      const offset = start - cachedChunkStart;\n      return buffer.slice(offset, offset + size);\n    }\n\n    const readKey = `${start}-${end}`;\n    const pendingRead = this.#pendingReads.get(readKey);\n\n    if (pendingRead) {\n      return pendingRead;\n    }\n\n    const readPromise = this.#readAndCacheChunkSafe(start, size);\n    this.#pendingReads.set(readKey, readPromise);\n\n    try {\n      return await readPromise;\n    } finally {\n      this.#pendingReads.delete(readKey);\n    }\n  }\n\n  async #readAndCacheChunkSafe(start: number, size: number): Promise<ArrayBuffer> {\n    const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    try {\n      const chunkStart = Math.max(0, start - 1024);\n      const chunkEnd = Math.min(this.size, start + NativeFile.MAX_CACHE_CHUNK_SIZE);\n      const chunkSize = chunkEnd - chunkStart;\n\n      await handle.seek(chunkStart, SeekMode.Start);\n      const buffer = new Uint8Array(chunkSize);\n      await handle.read(buffer);\n\n      // Only one thread reaches here per unique range\n      this.#cache.set(chunkStart, buffer.buffer);\n      this.#updateAccessOrder(chunkStart);\n      this.#ensureCacheSize();\n\n      const offset = start - chunkStart;\n      return buffer.buffer.slice(offset, offset + size);\n    } finally {\n      await handle.close();\n    }\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > NativeFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.readData(start, end);\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override stream(): ReadableStream<Uint8Array<ArrayBuffer>> {\n    const CHUNK_SIZE = 1024 * 1024;\n    let offset = 0;\n\n    return new ReadableStream<Uint8Array<ArrayBuffer>>({\n      pull: async (controller) => {\n        if (!this.#handle) {\n          controller.error(new Error('File handle is not open'));\n          return;\n        }\n\n        if (offset >= this.size) {\n          controller.close();\n          return;\n        }\n\n        const end = Math.min(offset + CHUNK_SIZE, this.size);\n        const buffer = new Uint8Array(end - offset);\n\n        await this.#handle.seek(offset, SeekMode.Start);\n        const bytesRead = await this.#handle.read(buffer);\n\n        if (bytesRead === null || bytesRead === 0) {\n          controller.close();\n          return;\n        }\n\n        controller.enqueue(buffer.subarray(0, bytesRead));\n        offset += bytesRead;\n      },\n\n      cancel: async () => {\n        await this.#handle?.close();\n      },\n    });\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n\nexport class RemoteFile extends File implements ClosableFile {\n  url: string;\n  #name: string;\n  #lastModified: number;\n  #size: number = -1;\n  #type: string = '';\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map(); // LRU cache\n  #pendingFetches: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 128;\n  static MAX_CACHE_ITEMS_SIZE: number = 128;\n\n  constructor(url: string, name?: string, type = '', lastModified = Date.now()) {\n    const basename = url.split('/').pop() || 'remote-file';\n    super([], name || basename, { type, lastModified });\n    this.url = url;\n    this.#name = name || basename;\n    this.#type = type;\n    this.#lastModified = lastModified;\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async _open_with_head() {\n    const response = await fetch(this.url, { method: 'HEAD' });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-length'));\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async _open_with_range() {\n    const response = await fetch(this.url, { headers: { Range: `bytes=${0}-${1023}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-range')?.split('/')[1]);\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async open() {\n    // FIXME: currently HEAD request in asset protocol is not supported on Android\n    if (getOSPlatform() === 'android') {\n      return this._open_with_range();\n    } else {\n      return this._open_with_head();\n    }\n  }\n\n  async close(): Promise<void> {\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  async fetchRangePart(start: number, end: number) {\n    start = Math.max(0, start);\n    end = Math.min(this.size - 1, end);\n    // console.log(`Fetching range: ${start}-${end}, size: ${end - start + 1}`);\n    const response = await fetch(this.url, { headers: { Range: `bytes=${start}-${end}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch range: ${response.status}`);\n    }\n    return response.arrayBuffer();\n  }\n\n  // inclusive reading of the end: [start, end]\n  async fetchRange(start: number, end: number): Promise<ArrayBuffer> {\n    const rangeSize = end - start + 1;\n    const MAX_RANGE_LEN = 1024 * 1000;\n\n    if (rangeSize > MAX_RANGE_LEN) {\n      const buffers: ArrayBuffer[] = [];\n      for (let currentStart = start; currentStart <= end; currentStart += MAX_RANGE_LEN) {\n        const currentEnd = Math.min(currentStart + MAX_RANGE_LEN - 1, end);\n        buffers.push(await this.fetchRangePart(currentStart, currentEnd));\n      }\n      const totalSize = buffers.reduce((sum, buffer) => sum + buffer.byteLength, 0);\n      const combinedBuffer = new Uint8Array(totalSize);\n      let offset = 0;\n      for (const buffer of buffers) {\n        combinedBuffer.set(new Uint8Array(buffer), offset);\n        offset += buffer.byteLength;\n      }\n      return combinedBuffer.buffer;\n    } else if (rangeSize > RemoteFile.MAX_CACHE_CHUNK_SIZE) {\n      return this.fetchRangePart(start, end);\n    } else {\n      const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n        const buffer = this.#cache.get(chunkStart)!;\n        const bufferSize = buffer.byteLength;\n        return start >= chunkStart && end <= chunkStart + bufferSize;\n      });\n      if (cachedChunkStart !== undefined) {\n        this.#updateAccessOrder(cachedChunkStart);\n        const buffer = this.#cache.get(cachedChunkStart)!;\n        const offset = start - cachedChunkStart;\n        return buffer.slice(offset, offset + rangeSize);\n      }\n\n      const fetchKey = `${start}-${end}`;\n      const pendingFetch = this.#pendingFetches.get(fetchKey);\n\n      if (pendingFetch) {\n        return pendingFetch;\n      }\n\n      const fetchPromise = this.#fetchAndCacheChunkSafe(start, end, rangeSize);\n      this.#pendingFetches.set(fetchKey, fetchPromise);\n      try {\n        return await fetchPromise;\n      } finally {\n        this.#pendingFetches.delete(fetchKey);\n      }\n    }\n  }\n\n  async #fetchAndCacheChunkSafe(\n    start: number,\n    end: number,\n    rangeSize: number,\n  ): Promise<ArrayBuffer> {\n    const chunkStart = Math.max(0, start - 1024);\n    const chunkEnd = Math.max(end, start + RemoteFile.MAX_CACHE_CHUNK_SIZE - 1024 - 1);\n    const buffer = await this.fetchRangePart(chunkStart, chunkEnd);\n\n    // Only one thread reaches here per unique range\n    this.#cache.set(chunkStart, buffer);\n    this.#updateAccessOrder(chunkStart);\n    this.#ensureCacheSize();\n\n    const offset = start - chunkStart;\n    return buffer.slice(offset, offset + rangeSize);\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > RemoteFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.fetchRange(start, end - 1);\n\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/indexedDBCache.ts"],"sourcesContent":["/**\n * IndexedDB 缓存管理器\n * 用于缓存书籍内容和封面图片，支持离线访问\n */\n\nconst DB_NAME = 'readest-cache';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'files';\n\nexport interface CacheEntry {\n    key: string; // 文件路径或 URL\n    data: ArrayBuffer;\n    etag?: string;\n    mimeType: string;\n    timestamp: number;\n    expiresAt?: number; // 过期时间戳\n}\n\nclass IndexedDBCache {\n    private db: IDBDatabase | null = null;\n    private initPromise: Promise<void> | null = null;\n\n    async init(): Promise<void> {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n\n        this.initPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onerror = () => {\n                console.error('[IndexedDBCache] Failed to open database:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                console.log('[IndexedDBCache] ✓ Database opened successfully');\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(STORE_NAME)) {\n                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });\n                    store.createIndex('expiresAt', 'expiresAt', { unique: false });\n                    console.log('[IndexedDBCache] ✓ Object store created');\n                }\n            };\n        });\n\n        return this.initPromise;\n    }\n\n    /**\n     * 获取缓存的文件\n     */\n    async get(key: string): Promise<CacheEntry | null> {\n        await this.init();\n        if (!this.db) return null;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entry = request.result as CacheEntry | undefined;\n\n                // 检查是否过期\n                if (entry && entry.expiresAt && Date.now() > entry.expiresAt) {\n                    console.log('[IndexedDBCache] Cache expired for:', key);\n                    // 异步删除过期项\n                    this.delete(key).catch(e => console.error('Failed to delete expired cache:', e));\n                    resolve(null);\n                } else {\n                    if (entry) {\n                        console.log('[IndexedDBCache] ✓ Cache hit for:', key);\n                    }\n                    resolve(entry || null);\n                }\n            };\n        });\n    }\n\n    /**\n     * 存储文件到缓存\n     */\n    async set(\n        key: string,\n        data: ArrayBuffer,\n        mimeType: string,\n        options?: {\n            etag?: string;\n            ttl?: number; // 生存时间（毫秒）\n        },\n    ): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        const entry: CacheEntry = {\n            key,\n            data,\n            mimeType,\n            etag: options?.etag,\n            timestamp: Date.now(),\n            expiresAt: options?.ttl ? Date.now() + options.ttl : undefined,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(entry);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache] ✓ Cache saved for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * 删除缓存\n     */\n    async delete(key: string): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache] ✓ Cache deleted for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * 清除所有缓存\n     */\n    async clear(): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache] ✓ All caches cleared');\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * 清除过期缓存\n     */\n    async clearExpired(): Promise<number> {\n        await this.init();\n        if (!this.db) return 0;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const index = store.index('expiresAt');\n            const range = IDBKeyRange.upperBound(Date.now());\n            const request = index.openCursor(range);\n\n            let deletedCount = 0;\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = (event) => {\n                const cursor = (event.target as IDBRequest).result;\n                if (cursor) {\n                    console.log('[IndexedDBCache] Deleting expired cache:', cursor.key);\n                    store.delete(cursor.primaryKey);\n                    deletedCount++;\n                    cursor.continue();\n                } else {\n                    console.log('[IndexedDBCache] ✓ Cleared', deletedCount, 'expired caches');\n                    resolve(deletedCount);\n                }\n            };\n        });\n    }\n\n    /**\n     * 获取缓存统计信息\n     */\n    async getStats(): Promise<{\n        totalEntries: number;\n        totalSize: number; // 字节\n        oldestEntry?: { key: string; timestamp: number };\n        newestEntry?: { key: string; timestamp: number };\n    }> {\n        await this.init();\n        if (!this.db) {\n            return { totalEntries: 0, totalSize: 0 };\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.getAll();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entries = request.result as CacheEntry[];\n                let totalSize = 0;\n                let oldestEntry: { key: string; timestamp: number } | undefined;\n                let newestEntry: { key: string; timestamp: number } | undefined;\n\n                entries.forEach((entry) => {\n                    totalSize += entry.data.byteLength;\n                    if (!oldestEntry || entry.timestamp < oldestEntry.timestamp) {\n                        oldestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                    if (!newestEntry || entry.timestamp > newestEntry.timestamp) {\n                        newestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                });\n\n                console.log('[IndexedDBCache] Stats:', {\n                    entries: entries.length,\n                    size: (totalSize / 1024 / 1024).toFixed(2) + ' MB',\n                });\n\n                resolve({\n                    totalEntries: entries.length,\n                    totalSize,\n                    oldestEntry,\n                    newestEntry,\n                });\n            };\n        });\n    }\n}\n\nexport const indexedDBCache = new IndexedDBCache();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/cachedFetch.ts"],"sourcesContent":["/**\n * 缓存感知的文件获取管理器\n * 支持多层缓存策略：HTTP 缓存 → IndexedDB → 网络请求\n */\n\nimport { indexedDBCache } from './indexedDBCache';\n\nexport type FetchOptions = {\n    /** 缓存策略 */\n    cacheStrategy?: 'network-first' | 'cache-first' | 'stale-while-revalidate';\n    /** 缓存过期时间（毫秒），0 表示不过期 */\n    cacheTTL?: number;\n    /** 是否跳过缓存 */\n    bypassCache?: boolean;\n    /** 自定义 HTTP 头 */\n    headers?: Record<string, string>;\n    /** 进度回调 */\n    onProgress?: (progress: number) => void;\n};\n\nconst DEFAULT_OPTIONS: FetchOptions = {\n    cacheStrategy: 'cache-first',\n    cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 天\n};\n\n/**\n * 生成缓存键\n */\nfunction generateCacheKey(url: string): string {\n    return `file_${url}`;\n}\n\n/**\n * 缓存感知的 fetch 实现\n */\nexport async function cachedFetch(\n    url: string,\n    options: FetchOptions = {},\n): Promise<{ data: ArrayBuffer; headers: Headers; fromCache: boolean }> {\n    const finalOptions = { ...DEFAULT_OPTIONS, ...options };\n    const cacheKey = generateCacheKey(url);\n\n    console.log(`[cachedFetch] Fetching: ${url}, strategy: ${finalOptions.cacheStrategy}`);\n\n    try {\n        // 策略 1: cache-first - 优先使用缓存\n        if (\n            finalOptions.cacheStrategy === 'cache-first' &&\n            !finalOptions.bypassCache\n        ) {\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                console.log(`[cachedFetch] ✓ Using cached data for: ${url}`);\n                // 创建虚拟响应头\n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    ...(cached.etag && { 'ETag': cached.etag }),\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        // 发起网络请求\n        const fetchHeaders = new Headers(finalOptions.headers || {});\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: fetchHeaders,\n            signal: AbortSignal.timeout(30000), // 30秒超时\n        });\n\n        // 处理 304 Not Modified\n        if (response.status === 304) {\n            console.log(`[cachedFetch] 304 Not Modified for: ${url}`);\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    'ETag': response.headers.get('ETag') || cached.etag || '',\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // 流式下载并记录进度\n        const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);\n        const reader = response.body?.getReader();\n        const chunks: Uint8Array[] = [];\n        let receivedLength = 0;\n\n        if (reader) {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                chunks.push(value);\n                receivedLength += value.length;\n\n                // 触发进度回调\n                if (contentLength > 0 && finalOptions.onProgress) {\n                    const progress = Math.round((receivedLength / contentLength) * 100);\n                    finalOptions.onProgress(progress);\n                }\n            }\n        } else {\n            // Fallback 如果没有 ReadableStream 支持\n            chunks.push(new Uint8Array(await response.arrayBuffer()));\n        }\n\n        // 合并分块数据\n        const data = new ArrayBuffer(receivedLength);\n        const dataView = new Uint8Array(data);\n        let offset = 0;\n        for (const chunk of chunks) {\n            dataView.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        // 获取响应头信息\n        const mimeType = response.headers.get('Content-Type') || 'application/octet-stream';\n        const etag = response.headers.get('ETag');\n\n        // 缓存数据（异步，不阻塞返回）\n        if (!finalOptions.bypassCache && response.status === 200) {\n            indexedDBCache\n                .set(cacheKey, data, mimeType, {\n                    etag: etag || undefined,\n                    ttl: finalOptions.cacheTTL,\n                })\n                .catch((error) => {\n                    console.warn(`[cachedFetch] Failed to cache ${url}:`, error);\n                });\n        }\n\n        console.log(`[cachedFetch] ✓ Fetched ${(data.byteLength / 1024 / 1024).toFixed(2)} MB from network`);\n\n        return { data, headers: response.headers, fromCache: false };\n    } catch (error) {\n        // 网络错误时尝试使用缓存（即使使用 network-first 策略）\n        console.warn(`[cachedFetch] Network error for ${url}:`, error);\n        const cached = await indexedDBCache.get(cacheKey);\n        if (cached) {\n            console.log(`[cachedFetch] ℹ Using stale cache due to network error: ${url}`);\n            const headers = new Headers({\n                'Content-Type': cached.mimeType,\n                'Content-Length': cached.data.byteLength.toString(),\n                'Warning': '199 - \"Stale cache used due to network error\"',\n            });\n            return { data: cached.data, headers, fromCache: true };\n        }\n\n        throw error;\n    }\n}\n\n/**\n * 获取文件并自动转换为 Blob URL\n */\nexport async function cachedFetchAsUrl(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data, headers } = await cachedFetch(url, options);\n    const mimeType = headers.get('Content-Type') || 'application/octet-stream';\n    const blob = new Blob([data], { type: mimeType });\n    return URL.createObjectURL(blob);\n}\n\n/**\n * 获取文件并自动转换为 Base64\n */\nexport async function cachedFetchAsBase64(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data } = await cachedFetch(url, options);\n    const bytes = new Uint8Array(data);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]!);\n    }\n    return btoa(binary);\n}\n\n/**\n * 清除缓存\n */\nexport async function clearFileCache(url?: string): Promise<void> {\n    if (url) {\n        const cacheKey = generateCacheKey(url);\n        await indexedDBCache.delete(cacheKey);\n        console.log(`[cachedFetch] Cleared cache for: ${url}`);\n    } else {\n        await indexedDBCache.clear();\n        console.log('[cachedFetch] Cleared all file caches');\n    }\n}\n\n/**\n * 清除过期缓存\n */\nexport async function clearExpiredFileCache(): Promise<number> {\n    return await indexedDBCache.clearExpired();\n}\n\n/**\n * 获取缓存统计\n */\nexport async function getFileCacheStats() {\n    return await indexedDBCache.getStats();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 813, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/txt.ts"],"sourcesContent":["import { partialMD5 } from './md5';\nimport { getBaseFilename } from './path';\nimport { detectLanguage } from './lang';\n\ninterface Metadata {\n  bookTitle: string;\n  author: string;\n  language: string;\n  identifier: string;\n}\n\ninterface Chapter {\n  title: string;\n  content: string;\n  text: string;\n  isVolume: boolean;\n}\n\ninterface Txt2EpubOptions {\n  file: File;\n  author?: string;\n  language?: string;\n}\n\ninterface ExtractChapterOptions {\n  linesBetweenSegments: number;\n  fallbackParagraphsPerChapter: number;\n}\n\ninterface ConversionResult {\n  file: File;\n  bookTitle: string;\n  chapterCount: number;\n  language: string;\n}\n\nconst zipWriteOptions = {\n  lastAccessDate: new Date(0),\n  lastModDate: new Date(0),\n};\n\nconst escapeXml = (str: string) => {\n  if (!str) return '';\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n};\n\nexport class TxtToEpubConverter {\n  public async convert(options: Txt2EpubOptions): Promise<ConversionResult> {\n    const { file: txtFile, author: providedAuthor, language: providedLanguage } = options;\n\n    const fileContent = await txtFile.arrayBuffer();\n    const detectedEncoding = this.detectEncoding(fileContent) || 'utf-8';\n    console.log(`Detected encoding: ${detectedEncoding}`);\n    const decoder = new TextDecoder(detectedEncoding);\n    const txtContent = decoder.decode(fileContent).trim();\n\n    const bookTitle = this.extractBookTitle(getBaseFilename(txtFile.name));\n    const fileName = `${bookTitle}.epub`;\n\n    const fileHeader = txtContent.slice(0, 1024);\n    const authorMatch =\n      fileHeader.match(/[【\\[]?作者[】\\]]?[:：\\s]\\s*(.+)\\r?\\n/) ||\n      fileHeader.match(/[【\\[]?\\s*(.+)\\s+著\\s*[】\\]]?\\r?\\n/);\n    let matchedAuthor = authorMatch ? authorMatch[1]!.trim() : providedAuthor || '';\n    try {\n      matchedAuthor = matchedAuthor.replace(/^[\\p{P}\\p{S}]+|[\\p{P}\\p{S}]+$/gu, '');\n    } catch {}\n    const author = matchedAuthor || providedAuthor || '';\n    const language = providedLanguage || detectLanguage(fileHeader);\n    console.log(`Detected language: ${language}`);\n    const identifier = await partialMD5(txtFile);\n    const metadata = { bookTitle, author, language, identifier };\n\n    let chapters: Chapter[] = [];\n    for (let i = 8; i >= 6; i--) {\n      chapters = this.extractChapters(txtContent, metadata, {\n        linesBetweenSegments: i,\n        fallbackParagraphsPerChapter: 100,\n      });\n\n      if (chapters.length === 0) {\n        throw new Error('No chapters detected.');\n      } else if (chapters.length > 1) {\n        break;\n      }\n    }\n\n    const blob = await this.createEpub(chapters, metadata);\n    return {\n      file: new File([blob], fileName),\n      bookTitle,\n      chapterCount: chapters.length,\n      language,\n    };\n  }\n\n  private extractChapters(\n    txtContent: string,\n    metadata: Metadata,\n    option: ExtractChapterOptions,\n  ): Chapter[] {\n    const { language } = metadata;\n    const { linesBetweenSegments, fallbackParagraphsPerChapter } = option;\n    const segmentRegex = new RegExp(`(?:\\\\r?\\\\n){${linesBetweenSegments},}|-{8,}\\r?\\n`);\n    const chapterRegexps: RegExp[] = [];\n    if (language === 'zh') {\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`第[零〇一二三四五六七八九十0-9][零〇一二三四五六七八九十百千万0-9]*(?:[章卷节回讲篇封本册部话])(?:[：:、 　\\(\\)0-9]*[^\\n-]{0,24})(?!\\S)`,\n              String.raw`(?:楔子|前言|简介|引言|序言|序章|总论|概论|后记)(?:[：: 　][^\\n-]{0,24})?(?!\\S)`,\n              String.raw`chapter[\\s.]*[0-9]+(?:[：:. 　]+[^\\n-]{0,50})?(?!\\S)`,\n            ].join('|') +\n            ')',\n          'gui',\n        ),\n      );\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[一二三四五六七八九十][零〇一二三四五六七八九十百千万]?[：:、 　][^\\n-]{0,24}(?=\\n|$)`,\n              String.raw`[0-9]+[^\\n]{0,16}(?=\\n|$)`,\n            ].join('|') +\n            ')',\n          'gu',\n        ),\n      );\n    } else {\n      const chapterKeywords = ['Chapter', 'Part', 'Section', 'Book', 'Volume', 'Act'];\n\n      const prefaceKeywords = [\n        'Prologue',\n        'Epilogue',\n        'Introduction',\n        'Foreword',\n        'Preface',\n        'Afterword',\n      ];\n\n      const numberPattern = String.raw`(\\d+|(?:[IVXLCDM]{2,}|V|X|L|C|D|M)\\b)`;\n      const dotNumberPattern = String.raw`\\.\\d{1,4}`;\n      const titlePattern = String.raw`[^\\n]{0,50}`;\n\n      const normalChapterPattern = chapterKeywords\n        .map(\n          (k) =>\n            String.raw`${k}\\s*(?:${numberPattern}|${dotNumberPattern})(?:[:.\\-–—]?\\s*${titlePattern})?`,\n        )\n        .join('|');\n\n      const prefacePattern = prefaceKeywords\n        .map((k) => String.raw`${k}(?:[:.\\-–—]?\\s*${titlePattern})?`)\n        .join('|');\n\n      const combinedPattern = String.raw`(?:^|\\n|\\s)(?:${normalChapterPattern}|${prefacePattern})(?=\\s|$)`;\n\n      chapterRegexps.push(new RegExp(combinedPattern, 'gi'));\n    }\n\n    const formatSegment = (segment: string): string => {\n      segment = escapeXml(segment);\n      return segment\n        .replace(/-{8,}|_{8,}/g, '\\n')\n        .split(/\\n+/)\n        .map((line) => line.trim())\n        .filter((line) => line)\n        .join('</p><p>');\n    };\n\n    const joinAroundUndefined = (arr: (string | undefined)[]) =>\n      arr.reduce<string[]>((acc, curr, i, src) => {\n        if (\n          curr === undefined &&\n          i > 0 &&\n          i < src.length - 1 &&\n          src[i - 1] !== undefined &&\n          src[i + 1] !== undefined\n        ) {\n          acc[acc.length - 1] += src[i + 1]!;\n          return acc;\n        }\n        if (curr !== undefined && (i === 0 || src[i - 1] !== undefined)) {\n          acc.push(curr);\n        }\n        return acc;\n      }, []);\n\n    const isGoodMatches = (matches: string[], maxLength: number = 100000): boolean => {\n      const meaningfulParts = matches.filter((part) => part && part.trim().length > 0);\n      if (meaningfulParts.length <= 1) return false;\n\n      const hasLongParts = meaningfulParts.some((part) => part.length > maxLength);\n      return !hasLongParts;\n    };\n\n    const chapters: Chapter[] = [];\n    const segments = txtContent.split(segmentRegex);\n    for (const segment of segments) {\n      const trimmedSegment = segment.replace(/<!--.*?-->/g, '').trim();\n      if (!trimmedSegment) continue;\n\n      const segmentChapters: Chapter[] = [];\n      let matches: string[] = [];\n      for (const chapterRegex of chapterRegexps) {\n        const tryMatches = trimmedSegment.split(chapterRegex);\n        if (isGoodMatches(tryMatches)) {\n          matches = joinAroundUndefined(tryMatches);\n          break;\n        }\n      }\n\n      if (matches.length === 0 && fallbackParagraphsPerChapter > 0) {\n        const paragraphs = trimmedSegment.split(/\\n+/);\n        const totalParagraphs = paragraphs.length;\n        for (let i = 0; i < totalParagraphs; i += fallbackParagraphsPerChapter) {\n          const chunks = paragraphs.slice(i, i + fallbackParagraphsPerChapter);\n          const formattedSegment = formatSegment(chunks.join('\\n'));\n          const title = `${chapters.length + 1}`;\n          const content = `<h2>${title}</h2><p>${formattedSegment}</p>`;\n          chapters.push({ title, content, text: chunks.join('\\n'), isVolume: false });\n        }\n        continue;\n      }\n\n      for (let j = 1; j < matches.length; j += 2) {\n        const title = matches[j]?.trim() || '';\n        const content = matches[j + 1]?.trim() || '';\n\n        let isVolume = false;\n        if (language === 'zh') {\n          isVolume = /第[零〇一二三四五六七八九十百千万0-9]+(卷|本|册|部)/.test(title);\n        } else {\n          isVolume = /\\b(Part|Volume|Book)\\b/i.test(title);\n        }\n\n        const headTitle = isVolume ? `<h1>${title}</h1>` : `<h2>${title}</h2>`;\n        const formattedSegment = formatSegment(content);\n        segmentChapters.push({\n          title: escapeXml(title),\n          content: `${headTitle}<p>${formattedSegment}</p>`,\n          text: content,\n          isVolume: isVolume,\n        });\n      }\n\n      if (matches[0] && matches[0].trim()) {\n        const initialContent = matches[0].trim();\n        const firstLine = initialContent.split('\\n')[0]!.trim();\n        const segmentTitle =\n          (firstLine.length > 16 ? initialContent.split(/[\\n\\s\\p{P}]/u)[0]!.trim() : firstLine) ||\n          initialContent.slice(0, 16);\n        const formattedSegment = formatSegment(initialContent);\n        segmentChapters.unshift({\n          title: escapeXml(segmentTitle),\n          content: `<h3></h3><p>${formattedSegment}</p>`,\n          text: initialContent,\n          isVolume: false,\n        });\n      }\n      chapters.push(...segmentChapters);\n    }\n\n    return chapters;\n  }\n\n  private async createEpub(chapters: Chapter[], metadata: Metadata): Promise<Blob> {\n    const { BlobWriter, TextReader, ZipWriter } = await import('@zip.js/zip.js');\n    const { bookTitle, author, language, identifier } = metadata;\n\n    const zipWriter = new ZipWriter(new BlobWriter('application/epub+zip'), {\n      extendedTimestamp: false,\n    });\n    await zipWriter.add('mimetype', new TextReader('application/epub+zip'), zipWriteOptions);\n\n    // Add META-INF/container.xml\n    const containerXml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <container xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\" version=\"1.0\">\n      <rootfiles>\n        <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n      </rootfiles>\n    </container>`.trim();\n\n    await zipWriter.add('META-INF/container.xml', new TextReader(containerXml), zipWriteOptions);\n\n    // Create navigation points for TOC\n    let isNested = false;\n    let navPoints = ``;\n    for (let i = 0; i < chapters.length; i++) {\n      const id = `chapter${i + 1}`;\n      const playOrder = i + 1;\n      if (chapters[i]!.isVolume && isNested) {\n        navPoints += `</navPoint>\\n`;\n        isNested = !isNested;\n      }\n      navPoints +=\n        `<navPoint id=\"navPoint-${id}\" playOrder=\"${playOrder}\">\\n` +\n        `<navLabel><text>${chapters[i]!.title}</text></navLabel>\\n` +\n        `<content src=\"./OEBPS/${id}.xhtml\" />\\n`;\n      if (chapters[i]!.isVolume && !isNested) {\n        isNested = !isNested;\n      } else {\n        navPoints += `</navPoint>\\n`;\n      }\n    }\n    if (isNested) {\n      navPoints += `</navPoint>`;\n    }\n\n    // Add NCX file (table of contents)\n    const tocNcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n      <head>\n        <meta name=\"dtb:uid\" content=\"book-id\" />\n        <meta name=\"dtb:depth\" content=\"1\" />\n        <meta name=\"dtb:totalPageCount\" content=\"0\" />\n        <meta name=\"dtb:maxPageNumber\" content=\"0\" />\n      </head>\n      <docTitle>\n        <text>${escapeXml(bookTitle)}</text>\n      </docTitle>\n      <docAuthor>\n        <text>${escapeXml(author)}</text>\n      </docAuthor>\n      <navMap>\n        ${navPoints}\n      </navMap>\n    </ncx>`.trim();\n\n    await zipWriter.add('toc.ncx', new TextReader(tocNcx), zipWriteOptions);\n\n    // Create manifest and spine items\n    const manifest = chapters\n      .map(\n        (_, index) => `\n      <item id=\"chap${index + 1}\" href=\"OEBPS/chapter${index + 1}.xhtml\" media-type=\"application/xhtml+xml\"/>\n    `,\n      )\n      .join('\\n')\n      .trim();\n\n    const spine = chapters\n      .map(\n        (_, index) => `\n      <itemref idref=\"chap${index + 1}\"/>`,\n      )\n      .join('\\n')\n      .trim();\n\n    // Add CSS stylesheet\n    const css = `\n      body { line-height: 1.6; font-size: 1em; font-family: 'Arial', sans-serif; text-align: justify; }\n      p { text-indent: 2em; margin: 0; }\n    `;\n\n    await zipWriter.add('style.css', new TextReader(css), zipWriteOptions);\n\n    // Add chapter files\n    for (let i = 0; i < chapters.length; i++) {\n      const chapter = chapters[i]!;\n      const lang = detectLanguage(chapter.text);\n      const chapterContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"${lang}\" xml:lang=\"${lang}\">\n          <head>\n            <title>${chapter.title}</title>\n            <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\"/>\n          </head>\n          <body>${chapter.content}</body>\n        </html>`.trim();\n\n      await zipWriter.add(\n        `OEBPS/chapter${i + 1}.xhtml`,\n        new TextReader(chapterContent),\n        zipWriteOptions,\n      );\n    }\n\n    const tocManifest = `<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>`;\n    const styleManifest = `<item id=\"css\" href=\"style.css\" media-type=\"text/css\"/>`;\n\n    // Add content.opf file\n    const contentOpf = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"book-id\" version=\"2.0\">\n        <metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n          <dc:title>${escapeXml(bookTitle)}</dc:title>\n          <dc:language>${language}</dc:language>\n          <dc:creator>${escapeXml(author)}</dc:creator>\n          <dc:identifier id=\"book-id\">${identifier}</dc:identifier>\n        </metadata>\n        <manifest>\n          ${manifest}\n          ${tocManifest}\n          ${styleManifest}\n        </manifest>\n        <spine toc=\"ncx\">\n          ${spine}\n        </spine>\n      </package>`.trim();\n\n    await zipWriter.add('content.opf', new TextReader(contentOpf), zipWriteOptions);\n\n    return await zipWriter.close();\n  }\n\n  private detectEncoding(buffer: ArrayBuffer): string | undefined {\n    try {\n      new TextDecoder('utf-8', { fatal: true }).decode(buffer);\n      return 'utf-8';\n    } catch {\n      const uint8Array = new Uint8Array(buffer);\n      // Try tolerant UTF-8 detection - check if most of it is valid UTF-8\n      let validBytes = 0;\n      let checkedBytes = 0;\n      const sampleSize = Math.min(uint8Array.length, 10000);\n\n      for (let i = 0; i < sampleSize; i++) {\n        try {\n          new TextDecoder('utf-8', { fatal: true }).decode(uint8Array.slice(i, i + 100));\n          validBytes += 100;\n          checkedBytes += 100;\n          i += 99;\n        } catch {\n          checkedBytes++;\n        }\n      }\n\n      const validPercentage = (validBytes / checkedBytes) * 100;\n      console.log(`UTF-8 validity: ${validPercentage.toFixed(2)}%`);\n\n      // If more than 80% is valid UTF-8, consider it UTF-8 with some corruption\n      if (validPercentage > 80) {\n        console.log('Treating as UTF-8 despite some invalid sequences');\n        return 'utf-8';\n      }\n      // If UTF-8 decoding fails, try to detect other encodings\n    }\n\n    const headerBytes = new Uint8Array(buffer.slice(0, 4));\n\n    if (headerBytes[0] === 0xff && headerBytes[1] === 0xfe) {\n      return 'utf-16le';\n    }\n\n    if (headerBytes[0] === 0xfe && headerBytes[1] === 0xff) {\n      return 'utf-16be';\n    }\n\n    if (headerBytes[0] === 0xef && headerBytes[1] === 0xbb && headerBytes[2] === 0xbf) {\n      return 'utf-8';\n    }\n\n    // Analyze a sample of the content to guess between common East Asian encodings\n    // If the content has a high ratio of bytes in the 0x80-0xFF range, it's likely GBK/GB18030\n    const sample = new Uint8Array(buffer.slice(0, Math.min(1024, buffer.byteLength)));\n    let highByteCount = 0;\n\n    for (let i = 0; i < sample.length; i++) {\n      if (sample[i]! >= 0x80) {\n        highByteCount++;\n      }\n    }\n\n    const highByteRatio = highByteCount / sample.length;\n    if (highByteRatio > 0.3) {\n      return 'gbk';\n    }\n\n    if (highByteRatio > 0.1) {\n      let sjisPattern = false;\n      for (let i = 0; i < sample.length - 1; i++) {\n        const b1 = sample[i]!;\n        const b2 = sample[i + 1]!;\n        if (\n          ((b1 >= 0x81 && b1 <= 0x9f) || (b1 >= 0xe0 && b1 <= 0xfc)) &&\n          ((b2 >= 0x40 && b2 <= 0x7e) || (b2 >= 0x80 && b2 <= 0xfc))\n        ) {\n          sjisPattern = true;\n          break;\n        }\n      }\n\n      if (sjisPattern) {\n        return 'shift-jis';\n      }\n\n      return 'gb18030';\n    }\n\n    return 'utf-8';\n  }\n\n  private extractBookTitle(filename: string): string {\n    const match = filename.match(/《([^》]+)》/);\n    return match ? match[1]! : filename.split('.')[0]!;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1194, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/errors.ts"],"sourcesContent":["export const BOOK_FILE_NOT_FOUND_ERROR = 'Book file not found';\n"],"names":[],"mappings":";;;;AAAO,MAAM,4BAA4B"}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/font.ts"],"sourcesContent":["import { FontStyle } from '@/styles/fonts';\nimport { getUserLang } from './misc';\n\nfunction parseUnicodeString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i += 2) {\n    const charCode = dataView.getUint16(offset + i, false);\n    if (charCode !== 0) {\n      chars.push(String.fromCharCode(charCode));\n    }\n  }\n  return chars.join('');\n}\n\nfunction parseMacintoshString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i++) {\n    const charCode = dataView.getUint8(offset + i);\n    chars.push(String.fromCharCode(charCode));\n  }\n  return chars.join('');\n}\n\nconst NO_STYLE_LANGUAGE_IDS = new Set([0x0404, 0x0804, 0x0c04, 0x1004, 19, 33]);\n\nfunction getLanguagePriority(platformID: number, languageID: number, userLanguage: string): number {\n  let priority = 0;\n\n  // Base priority by platform (Unicode/Microsoft preferred)\n  if (platformID === 0)\n    priority += 100; // Unicode\n  else if (platformID === 3)\n    priority += 90; // Microsoft\n  else if (platformID === 1) priority += 50; // Macintosh\n\n  // Language-specific priorities\n  const userLang = userLanguage.toLowerCase();\n\n  if (platformID === 0 || platformID === 3) {\n    if (userLang.startsWith('zh')) {\n      if (languageID === 0x0804)\n        priority += 50; // Simplified Chinese\n      else if (languageID === 0x0404)\n        priority += 45; // Traditional Chinese\n      else if (languageID === 0x0c04)\n        priority += 40; // Traditional Chinese\n      else if (languageID === 0x1004) priority += 35; // Simplified Chinese\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 0x0411) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 0x0412) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0x0409)\n        priority += 50; // English (US)\n      else if (languageID === 0x0809) priority += 45; // English (UK)\n    }\n\n    // Fallback: English\n    if (languageID === 0x0409) priority += 10; // English fallback\n  } else if (platformID === 1) {\n    // Macintosh platform language codes\n    if (userLang.startsWith('zh')) {\n      if (languageID === 33)\n        priority += 50; // Chinese (Simplified)\n      else if (languageID === 19) priority += 45; // Chinese (Traditional)\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 11) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 23) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0) priority += 50; // English\n    }\n\n    // Fallback: English\n    if (languageID === 0) priority += 10; // English fallback\n  }\n\n  return priority;\n}\n\nfunction parseOS2Weight(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table usWeightClass is at offset 4\n  return dataView.getUint16(os2TableOffset + 4, false);\n}\n\nfunction parseOS2Selection(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table fsSelection is at offset 62\n  return dataView.getUint16(os2TableOffset + 62, false);\n}\n\ninterface VariableFontAxis {\n  tag: string;\n  minValue: number;\n  defaultValue: number;\n  maxValue: number;\n  name?: string;\n}\n\nfunction parseVariableFontAxes(dataView: DataView, fvarTableOffset: number): VariableFontAxis[] {\n  try {\n    // fvar table structure:\n    // version (4 bytes) + axisCount (2 bytes) + axisSize (2 bytes) + instanceCount (2 bytes) + instanceSize (2 bytes)\n    const axisCount = dataView.getUint16(fvarTableOffset + 4, false);\n    const axisSize = dataView.getUint16(fvarTableOffset + 6, false);\n\n    const axes: VariableFontAxis[] = [];\n\n    // Each axis record starts at offset 16 from table start\n    let axisOffset = fvarTableOffset + 16;\n\n    for (let i = 0; i < axisCount; i++) {\n      // Axis record structure:\n      // axisTag (4 bytes) + minValue (4 bytes) + defaultValue (4 bytes) + maxValue (4 bytes) + flags (2 bytes) + axisNameID (2 bytes)\n\n      const tag = String.fromCharCode(\n        dataView.getUint8(axisOffset),\n        dataView.getUint8(axisOffset + 1),\n        dataView.getUint8(axisOffset + 2),\n        dataView.getUint8(axisOffset + 3),\n      );\n\n      // Fixed-point values (16.16 format)\n      const minValue = dataView.getInt32(axisOffset + 4, false) / 65536;\n      const defaultValue = dataView.getInt32(axisOffset + 8, false) / 65536;\n      const maxValue = dataView.getInt32(axisOffset + 12, false) / 65536;\n\n      axes.push({\n        tag,\n        minValue,\n        defaultValue,\n        maxValue,\n      });\n\n      axisOffset += axisSize;\n    }\n\n    return axes;\n  } catch (error) {\n    console.warn('Failed to parse fvar table:', error);\n    return [];\n  }\n}\n\nfunction weightClassToCSSWeight(weightClass: number): number {\n  // Map OpenType weight class to CSS weight\n  if (weightClass >= 1 && weightClass <= 100) return 100;\n  if (weightClass >= 101 && weightClass <= 200) return 200;\n  if (weightClass >= 201 && weightClass <= 300) return 300;\n  if (weightClass >= 301 && weightClass <= 400) return 400;\n  if (weightClass >= 401 && weightClass <= 500) return 500;\n  if (weightClass >= 501 && weightClass <= 600) return 600;\n  if (weightClass >= 601 && weightClass <= 700) return 700;\n  if (weightClass >= 701 && weightClass <= 800) return 800;\n  if (weightClass >= 801 && weightClass <= 900) return 900;\n  return 400; // Default to normal weight\n}\n\nfunction inferWeightFromStyleName(styleName: string): number {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check for specific weight keywords\n  if (lowerStyle.includes('thin') || lowerStyle.includes('hairline')) return 100;\n  if (lowerStyle.includes('extralight') || lowerStyle.includes('ultralight')) return 200;\n  if (\n    lowerStyle.includes('light') &&\n    !lowerStyle.includes('extralight') &&\n    !lowerStyle.includes('ultralight')\n  )\n    return 300;\n  if (lowerStyle.includes('medium')) return 500;\n  if (lowerStyle.includes('semibold') || lowerStyle.includes('demibold')) return 600;\n  if (lowerStyle.includes('extrabold') || lowerStyle.includes('ultrabold')) return 800;\n  if (lowerStyle.includes('black') || lowerStyle.includes('heavy')) return 900;\n  if (\n    lowerStyle.includes('bold') &&\n    !lowerStyle.includes('semibold') &&\n    !lowerStyle.includes('extrabold') &&\n    !lowerStyle.includes('ultrabold')\n  )\n    return 700;\n\n  return 400; // Default to normal weight\n}\n\nfunction inferStyleFromName(\n  styleName: string,\n  fsSelection: number,\n): 'normal' | 'italic' | 'oblique' {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check fsSelection flags first (bit 0 = italic, bit 9 = oblique)\n  if (fsSelection & 0x200) return 'oblique'; // Bit 9\n  if (fsSelection & 0x1) return 'italic'; // Bit 0\n\n  // Fallback to style name analysis\n  if (lowerStyle.includes('oblique')) return 'oblique';\n  if (lowerStyle.includes('italic') || lowerStyle.includes('slant')) return 'italic';\n\n  return 'normal';\n}\n\ntype FontNameType = {\n  name: string;\n  platformID: number;\n  languageID: number;\n  priority: number;\n};\n\nexport const parseFontInfo = (fontData: ArrayBuffer, filename: string) => {\n  const fallbackName = filename.replace(/\\.[^/.]+$/, '');\n  try {\n    const dataView = new DataView(fontData);\n    const signature = dataView.getUint32(0, false);\n    if (signature !== 0x00010000 && signature !== 0x74727565 && signature !== 0x4f54544f) {\n      throw new Error('Unsupported font format');\n    }\n    const numTables = dataView.getUint16(4, false);\n    let nameTableOffset = 0;\n    let os2TableOffset = 0;\n    let fvarTableOffset = 0;\n    for (let i = 0; i < numTables; i++) {\n      const tableOffset = 12 + i * 16;\n      const tag = String.fromCharCode(\n        dataView.getUint8(tableOffset),\n        dataView.getUint8(tableOffset + 1),\n        dataView.getUint8(tableOffset + 2),\n        dataView.getUint8(tableOffset + 3),\n      );\n\n      if (tag === 'name') {\n        nameTableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'OS/2') {\n        os2TableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'fvar') {\n        fvarTableOffset = dataView.getUint32(tableOffset + 8, false);\n      }\n    }\n\n    if (nameTableOffset === 0) {\n      throw new Error('Name table not found');\n    }\n\n    const count = dataView.getUint16(nameTableOffset + 2, false);\n    const stringOffset = dataView.getUint16(nameTableOffset + 4, false);\n\n    const userLanguage = getUserLang();\n    const fontFamilyNames: Array<FontNameType> = [];\n    const fontStyleNames: Array<FontNameType> = [];\n    const preferredFamilyNames: Array<FontNameType> = [];\n    const preferredStyleNames: Array<FontNameType> = [];\n    for (let i = 0; i < count; i++) {\n      const recordOffset = nameTableOffset + 6 + i * 12;\n      const platformID = dataView.getUint16(recordOffset, false);\n      const languageID = dataView.getUint16(recordOffset + 4, false);\n      const nameID = dataView.getUint16(recordOffset + 6, false);\n      const nameLength = dataView.getUint16(recordOffset + 8, false);\n      const nameOffsetInTable = dataView.getUint16(recordOffset + 10, false);\n\n      // nameID 1 = Font Family name, nameID 2 = Font Subfamily name (style)\n      // nameID 16 = Typographic Family name, nameID 17 = Typographic Subfamily name\n      if (nameID === 1 || nameID === 2 || nameID === 16 || nameID === 17) {\n        const stringStart = nameTableOffset + stringOffset + nameOffsetInTable;\n        let fontName = '';\n\n        if (platformID === 0 || platformID === 3) {\n          // Unicode/Microsoft platform\n          fontName = parseUnicodeString(dataView, stringStart, nameLength);\n        } else if (platformID === 1) {\n          // Macintosh platform\n          fontName = parseMacintoshString(dataView, stringStart, nameLength);\n        }\n\n        if (fontName && fontName.trim()) {\n          const priority = getLanguagePriority(platformID, languageID, userLanguage);\n          const nameEntry = {\n            name: fontName.trim(),\n            platformID,\n            languageID,\n            priority,\n          };\n\n          if (nameID === 1) {\n            fontFamilyNames.push(nameEntry);\n          } else if (nameID === 2) {\n            fontStyleNames.push(nameEntry);\n          } else if (nameID === 16) {\n            preferredFamilyNames.push(nameEntry);\n          } else if (nameID === 17) {\n            preferredStyleNames.push(nameEntry);\n          }\n        }\n      }\n    }\n    if (fontFamilyNames.length === 0) {\n      throw new Error('Font family name not found');\n    }\n    fontFamilyNames.sort((a, b) => b.priority - a.priority);\n    fontStyleNames.sort((a, b) => b.priority - a.priority);\n    preferredFamilyNames.sort((a, b) => b.priority - a.priority);\n    preferredStyleNames.sort((a, b) => b.priority - a.priority);\n\n    // Prefer typographic names if available\n    const familyName = (preferredFamilyNames[0] || fontFamilyNames[0])!.name;\n    const fontStyleName = preferredStyleNames[0] || fontStyleNames[0];\n    const styleName = fontStyleName?.name || '';\n\n    // Parse weight and style information\n    let fontWeight = 400;\n    let fontStyle: FontStyle = 'normal';\n    let fsSelection = 0;\n\n    if (os2TableOffset > 0) {\n      try {\n        const weightClass = parseOS2Weight(dataView, os2TableOffset);\n        fontWeight = weightClassToCSSWeight(weightClass);\n        fsSelection = parseOS2Selection(dataView, os2TableOffset);\n      } catch {\n        console.warn('Failed to parse OS/2 table, falling back to style name analysis');\n      }\n    }\n\n    let isVariable = false;\n    if (fvarTableOffset > 0) {\n      const axes = parseVariableFontAxes(dataView, fvarTableOffset);\n      if (axes && axes.length > 0) {\n        isVariable = true;\n      }\n    }\n\n    // If OS/2 table weight is default (400) or unavailable, try to infer from style name\n    if (fontWeight === 400 && styleName) {\n      const inferredWeight = inferWeightFromStyleName(styleName);\n      if (inferredWeight !== 400) {\n        fontWeight = inferredWeight;\n      }\n    }\n\n    fontStyle = inferStyleFromName(styleName, fsSelection);\n\n    return {\n      name:\n        fontStyleName && !NO_STYLE_LANGUAGE_IDS.has(fontStyleName.languageID)\n          ? `${familyName} ${styleName}`\n          : familyName,\n      family: familyName,\n      weight: fontWeight,\n      style: fontStyle,\n      variable: isVariable,\n    };\n  } catch (error) {\n    console.warn(`Failed to parse font: ${error}`);\n    return {\n      name: fallbackName,\n      family: fallbackName,\n      weight: 400,\n      style: 'normal' as FontStyle,\n      variable: false,\n    };\n  }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1490, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/svg.ts"],"sourcesContent":["function parseSvgLength(value: string) {\n  const n = parseFloat(value);\n  if (!isNaN(n)) return n;\n\n  return undefined;\n}\n\nasync function getSvgSize(\n  svgBlob: Blob,\n  defaultWidth: number = 700,\n  defaultHeight: number = 1050,\n): Promise<{ width: number; height: number }> {\n  const text = await svgBlob.text();\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(text, 'image/svg+xml');\n  const svg = doc.documentElement;\n\n  const widthAttr = svg.getAttribute('width');\n  const heightAttr = svg.getAttribute('height');\n\n  if (widthAttr && heightAttr) {\n    return {\n      width: parseSvgLength(widthAttr) || defaultWidth,\n      height: parseSvgLength(heightAttr) || defaultHeight,\n    };\n  }\n\n  const viewBox = svg.getAttribute('viewBox');\n  if (viewBox) {\n    const parts = viewBox.split(/\\s+/).map(Number);\n    if (parts.length === 4 && !parts.some(isNaN)) {\n      const [, , vbWidth, vbHeight] = parts;\n      return { width: vbWidth || defaultWidth, height: vbHeight || defaultHeight };\n    }\n  }\n\n  return { width: defaultWidth, height: defaultHeight };\n}\n\nexport async function svg2png(svgBlob: Blob, quality: number = 0.9): Promise<Blob> {\n  const svgText = await svgBlob.text();\n\n  const svgUrl = URL.createObjectURL(new Blob([svgText], { type: 'image/svg+xml' }));\n\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n\n  await new Promise<void>((resolve, reject) => {\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error('Failed to load SVG'));\n    img.src = svgUrl;\n  });\n\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n\n  const canvas = document.createElement('canvas');\n  const { width, height } = await getSvgSize(svgBlob);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0);\n\n  URL.revokeObjectURL(svgUrl);\n\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => resolve(blob!), 'image/png', quality);\n  });\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,eAAe,KAAa;IACnC,MAAM,IAAI,WAAW;IACrB,IAAI,CAAC,MAAM,IAAI,OAAO;IAEtB,OAAO;AACT;AAEA,eAAe,WACb,OAAa,EACb,eAAuB,GAAG,EAC1B,gBAAwB,IAAI;IAE5B,MAAM,OAAO,MAAM,QAAQ,IAAI;IAC/B,MAAM,SAAS,IAAI;IACnB,MAAM,MAAM,OAAO,eAAe,CAAC,MAAM;IACzC,MAAM,MAAM,IAAI,eAAe;IAE/B,MAAM,YAAY,IAAI,YAAY,CAAC;IACnC,MAAM,aAAa,IAAI,YAAY,CAAC;IAEpC,IAAI,aAAa,YAAY;QAC3B,OAAO;YACL,OAAO,eAAe,cAAc;YACpC,QAAQ,eAAe,eAAe;QACxC;IACF;IAEA,MAAM,UAAU,IAAI,YAAY,CAAC;IACjC,IAAI,SAAS;QACX,MAAM,QAAQ,QAAQ,KAAK,CAAC,OAAO,GAAG,CAAC;QACvC,IAAI,MAAM,MAAM,KAAK,KAAK,CAAC,MAAM,IAAI,CAAC,QAAQ;YAC5C,MAAM,KAAK,SAAS,SAAS,GAAG;YAChC,OAAO;gBAAE,OAAO,WAAW;gBAAc,QAAQ,YAAY;YAAc;QAC7E;IACF;IAEA,OAAO;QAAE,OAAO;QAAc,QAAQ;IAAc;AACtD;AAEO,eAAe,QAAQ,OAAa,EAAE,UAAkB,GAAG;IAChE,MAAM,UAAU,MAAM,QAAQ,IAAI;IAElC,MAAM,SAAS,IAAI,eAAe,CAAC,IAAI,KAAK;QAAC;KAAQ,EAAE;QAAE,MAAM;IAAgB;IAE/E,MAAM,MAAM,IAAI;IAChB,IAAI,WAAW,GAAG;IAElB,MAAM,IAAI,QAAc,CAAC,SAAS;QAChC,IAAI,MAAM,GAAG,IAAM;QACnB,IAAI,OAAO,GAAG,IAAM,OAAO,IAAI,MAAM;QACrC,IAAI,GAAG,GAAG;IACZ;IAEA,MAAM,IAAI,QAAQ,CAAC,UAAY,sBAAsB;IACrD,MAAM,IAAI,QAAQ,CAAC,UAAY,sBAAsB;IAErD,MAAM,SAAS,SAAS,aAAa,CAAC;IACtC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,WAAW;IAC3C,OAAO,KAAK,GAAG;IACf,OAAO,MAAM,GAAG;IAEhB,MAAM,MAAM,OAAO,UAAU,CAAC;IAC9B,IAAI,SAAS,CAAC,KAAK,GAAG;IAEtB,IAAI,eAAe,CAAC;IAEpB,OAAO,IAAI,QAAQ,CAAC;QAClB,OAAO,MAAM,CAAC,CAAC,OAAS,QAAQ,OAAQ,aAAa;IACvD;AACF"}},
    {"offset": {"line": 1562, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/appService.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { SystemSettings } from '@/types/settings';\nimport {\n  AppPlatform,\n  AppService,\n  DistChannel,\n  FileItem,\n  OsPlatform,\n  ResolvedPath,\n  SelectDirectoryMode,\n} from '@/types/system';\nimport { FileSystem, BaseDir, DeleteAction } from '@/types/system';\nimport {\n  Book,\n  BookConfig,\n  BookContent,\n  BookFormat,\n  FIXED_LAYOUT_FORMATS,\n  ViewSettings,\n} from '@/types/book';\nimport {\n  getDir,\n  getLocalBookFilename,\n  getCoverFilename,\n  getConfigFilename,\n  getLibraryFilename,\n  INIT_BOOK_CONFIG,\n  formatTitle,\n  formatAuthors,\n  getPrimaryLanguage,\n  getLibraryBackupFilename,\n} from '@/utils/book';\nimport { md5, partialMD5, md5Fingerprint } from '@/utils/md5';\nimport { getBaseFilename, getFilename } from '@/utils/path';\nimport { BookDoc, DocumentLoader, EXTS } from '@/libs/document';\nimport {\n  DEFAULT_BOOK_LAYOUT,\n  DEFAULT_BOOK_STYLE,\n  DEFAULT_BOOK_FONT,\n  DEFAULT_BOOK_LANGUAGE,\n  DEFAULT_VIEW_CONFIG,\n  DEFAULT_READSETTINGS,\n  SYSTEM_SETTINGS_VERSION,\n  DEFAULT_BOOK_SEARCH_CONFIG,\n  DEFAULT_TTS_CONFIG,\n  DEFAULT_MOBILE_VIEW_SETTINGS,\n  DEFAULT_SYSTEM_SETTINGS,\n  DEFAULT_CJK_VIEW_SETTINGS,\n  DEFAULT_MOBILE_READSETTINGS,\n  DEFAULT_SCREEN_CONFIG,\n  DEFAULT_TRANSLATOR_CONFIG,\n  DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS,\n  SETTINGS_FILENAME,\n  DEFAULT_MOBILE_SYSTEM_SETTINGS,\n  DEFAULT_ANNOTATOR_CONFIG,\n  DEFAULT_EINK_VIEW_SETTINGS,\n} from './constants';\nimport { cachedFetchAsUrl } from '@/utils/cachedFetch';\nimport { fetch as tauriFetch } from '@tauri-apps/plugin-http';\nimport {\n  getOSPlatform,\n  getTargetLang,\n  isCJKEnv,\n  isContentURI,\n  isValidURL,\n  makeSafeFilename,\n} from '@/utils/misc';\nimport { deserializeConfig, serializeConfig } from '@/utils/serializer';\nimport { ClosableFile } from '@/utils/file';\nimport { TxtToEpubConverter } from '@/utils/txt';\nimport { BOOK_FILE_NOT_FOUND_ERROR } from './errors';\nimport { CustomTextureInfo } from '@/styles/textures';\nimport { CustomFont, CustomFontInfo } from '@/styles/fonts';\nimport { parseFontInfo } from '@/utils/font';\nimport { svg2png } from '@/utils/svg';\n\nexport abstract class BaseAppService implements AppService {\n  osPlatform: OsPlatform = getOSPlatform();\n  appPlatform: AppPlatform = 'tauri';\n  localBooksDir = '';\n  isMobile = false;\n  isMacOSApp = false;\n  isLinuxApp = false;\n  isAppDataSandbox = false;\n  isAndroidApp = false;\n  isIOSApp = false;\n  isMobileApp = false;\n  isPortableApp = false;\n  isDesktopApp = false;\n  isEink = false;\n  hasTrafficLight = false;\n  hasWindow = false;\n  hasWindowBar = false;\n  hasContextMenu = false;\n  hasRoundedWindow = false;\n  hasSafeAreaInset = false;\n  hasHaptics = false;\n  hasUpdater = false;\n  hasOrientationLock = false;\n  hasScreenBrightness = false;\n  hasIAP = false;\n  canCustomizeRootDir = false;\n  canReadExternalDir = false;\n  distChannel = 'readest' as DistChannel;\n\n  protected CURRENT_MIGRATION_VERSION = 20260121;\n\n  protected abstract fs: FileSystem;\n  protected abstract resolvePath(fp: string, base: BaseDir): ResolvedPath;\n\n  abstract init(): Promise<void>;\n  abstract setCustomRootDir(customRootDir: string): Promise<void>;\n  abstract selectDirectory(mode: SelectDirectoryMode): Promise<string>;\n  abstract selectFiles(name: string, extensions: string[]): Promise<string[]>;\n  abstract saveFile(\n    filename: string,\n    content: string | ArrayBuffer,\n    filepath: string,\n    mimeType?: string,\n  ): Promise<boolean>;\n\n  protected async runMigrations(lastMigrationVersion: number): Promise<void> {\n    if (lastMigrationVersion < 20251124) {\n      try {\n        await this.migrate20251124();\n      } catch (error) {\n        console.error('Error migrating to version 20251124:', error);\n      }\n    }\n\n    if (lastMigrationVersion < 20260121) {\n      try {\n        await this.migrate20260121();\n      } catch (error) {\n        console.error('Error migrating to version 20260121:', error);\n      }\n    }\n  }\n\n  async prepareBooksDir() {\n    this.localBooksDir = await this.fs.getPrefix('Books');\n    // Initialize configuration files in .readest directory\n    await this.ensureConfigFilesExist();\n  }\n\n  /**\n   * Ensure settings.json and library.json exist in .readest directory\n   * If they don't exist, create them with default values\n   */\n  private async ensureConfigFilesExist(): Promise<void> {\n    try {\n      // Check and create settings.json if needed\n      const settingsExists = await this.fs.exists(SETTINGS_FILENAME, 'Settings');\n      if (!settingsExists) {\n        console.log('[Init] settings.json not found, creating with defaults...');\n        const defaultSettings = {\n          ...DEFAULT_SYSTEM_SETTINGS,\n          ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n          version: SYSTEM_SETTINGS_VERSION,\n          localBooksDir: await this.fs.getPrefix('Books'),\n          globalReadSettings: {\n            ...DEFAULT_READSETTINGS,\n            ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n          },\n          globalViewSettings: this.getDefaultViewSettings(),\n        } as SystemSettings;\n        await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', defaultSettings);\n        console.log('[Init] ✓ settings.json created successfully');\n      }\n\n      // Check and create library.json if needed\n      const libraryFilename = getLibraryFilename();\n      const libraryExists = await this.fs.exists(libraryFilename, 'Books');\n      if (!libraryExists) {\n        console.log('[Init] library.json not found, creating with defaults...');\n        await this.safeSaveJSON(libraryFilename, 'Books', []);\n        console.log('[Init] ✓ library.json created successfully');\n      }\n\n      console.log('[Init] ✓ All configuration files are ready');\n    } catch (error) {\n      console.error('[Init] Error ensuring config files exist:', error);\n      // Don't throw, continue with defaults\n    }\n  }\n\n  async openFile(path: string, base: BaseDir): Promise<File> {\n    return await this.fs.openFile(path, base);\n  }\n\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir): Promise<void> {\n    return await this.fs.copyFile(srcPath, dstPath, base);\n  }\n\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    return await this.fs.readFile(path, base, mode);\n  }\n\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    return await this.fs.writeFile(path, base, content);\n  }\n\n  async createDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.createDir(path, base, recursive);\n  }\n\n  async deleteFile(path: string, base: BaseDir): Promise<void> {\n    return await this.fs.removeFile(path, base);\n  }\n\n  async deleteDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.removeDir(path, base, recursive);\n  }\n\n  async resolveFilePath(path: string, base: BaseDir): Promise<string> {\n    const prefix = await this.fs.getPrefix(base);\n    return path ? `${prefix}/${path}` : prefix;\n  }\n\n  async readDirectory(path: string, base: BaseDir): Promise<FileItem[]> {\n    return await this.fs.readDir(path, base);\n  }\n\n  async exists(path: string, base: BaseDir): Promise<boolean> {\n    return await this.fs.exists(path, base);\n  }\n\n  async getImageURL(path: string): Promise<string> {\n    return await this.fs.getImageURL(path);\n  }\n\n  getCoverImageUrl = (book: Book): string => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n    const resolvedPath = this.fs.resolvePath(coverPath, 'Books');\n    return this.fs.getURL(resolvedPath.fp) || `${this.localBooksDir}/${coverPath}`;\n  };\n\n  getCoverImageBlobUrl = async (book: Book): Promise<string> => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n\n    // 在 web 平台使用缓存的 Blob URL\n    if (this.appPlatform === 'web') {\n      try {\n        const coverUrl = this.fs.getURL(this.fs.resolvePath(coverPath, 'Books').fp) ||\n          `${this.localBooksDir}/${coverPath}`;\n\n        // 使用缓存获取 Blob URL，缓存 30 天\n        return await cachedFetchAsUrl(coverUrl, {\n          cacheStrategy: 'cache-first',\n          cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 天\n        }).catch(() => {\n          // 如果缓存失败，回退到原始方式\n          return `${this.localBooksDir}/${coverPath}`;\n        });\n      } catch {\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    } else {\n      try {\n        return await this.fs.getBlobURL(coverPath, 'Books');\n      } catch {\n        // Fallback to old path if the new path doesn't exist\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    }\n  };\n\n  async getCachedImageUrl(pathOrUrl: string): Promise<string> {\n    const cachedKey = `img_${md5(pathOrUrl)}`;\n    const cachePrefix = await this.fs.getPrefix('Cache');\n    const cachedPath = `${cachePrefix}/${cachedKey}`;\n    if (await this.fs.exists(cachedPath, 'None')) {\n      return await this.fs.getImageURL(cachedPath);\n    } else {\n      const file = await this.fs.openFile(pathOrUrl, 'None');\n      await this.fs.writeFile(cachedKey, 'Cache', await file.arrayBuffer());\n      return await this.fs.getImageURL(cachedPath);\n    }\n  }\n\n  getDefaultViewSettings(): ViewSettings {\n    return {\n      ...DEFAULT_BOOK_LAYOUT,\n      ...DEFAULT_BOOK_STYLE,\n      ...DEFAULT_BOOK_FONT,\n      ...DEFAULT_BOOK_LANGUAGE,\n      ...(this.isMobile ? DEFAULT_MOBILE_VIEW_SETTINGS : {}),\n      ...(this.isEink ? DEFAULT_EINK_VIEW_SETTINGS : {}),\n      ...(isCJKEnv() ? DEFAULT_CJK_VIEW_SETTINGS : {}),\n      ...DEFAULT_VIEW_CONFIG,\n      ...DEFAULT_TTS_CONFIG,\n      ...DEFAULT_SCREEN_CONFIG,\n      ...DEFAULT_ANNOTATOR_CONFIG,\n      ...{ ...DEFAULT_TRANSLATOR_CONFIG, translateTargetLang: getTargetLang() },\n    };\n  }\n\n  async loadSettings(): Promise<SystemSettings> {\n    const defaultSettings: SystemSettings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      version: SYSTEM_SETTINGS_VERSION,\n      localBooksDir: await this.fs.getPrefix('Books'),\n      koreaderSyncDeviceId: uuidv4(),\n      globalReadSettings: {\n        ...DEFAULT_READSETTINGS,\n        ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      },\n      globalViewSettings: this.getDefaultViewSettings(),\n    } as SystemSettings;\n\n    let settings = await this.safeLoadJSON<SystemSettings>(\n      SETTINGS_FILENAME,\n      'Settings',\n      defaultSettings,\n    );\n\n    const version = settings.version ?? 0;\n    if (this.isAppDataSandbox || version < SYSTEM_SETTINGS_VERSION) {\n      settings.version = SYSTEM_SETTINGS_VERSION;\n    }\n    settings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      ...settings,\n    };\n    settings.globalReadSettings = {\n      ...DEFAULT_READSETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      ...settings.globalReadSettings,\n    };\n    settings.globalViewSettings = {\n      ...this.getDefaultViewSettings(),\n      ...settings.globalViewSettings,\n    };\n\n    settings.localBooksDir = await this.fs.getPrefix('Books');\n\n    if (!settings.kosync.deviceId) {\n      settings.kosync.deviceId = uuidv4();\n      await this.saveSettings(settings);\n    }\n\n    this.localBooksDir = settings.localBooksDir;\n    return settings;\n  }\n\n  async saveSettings(settings: SystemSettings): Promise<void> {\n    await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', settings);\n  }\n\n  async importFont(file?: string | File): Promise<CustomFontInfo | null> {\n    let fontPath: string;\n    let fontFile: File;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      fontPath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, fontPath, 'Fonts');\n      fontFile = await this.fs.openFile(fontPath, 'Fonts');\n    } else if (file) {\n      fontPath = getFilename(file.name);\n      await this.fs.writeFile(fontPath, 'Fonts', file);\n      fontFile = file;\n    } else {\n      return null;\n    }\n\n    return {\n      path: fontPath,\n      ...parseFontInfo(await fontFile.arrayBuffer(), fontPath),\n    };\n  }\n\n  async deleteFont(font: CustomFont): Promise<void> {\n    await this.fs.removeFile(font.path, 'Fonts');\n  }\n\n  async importImage(file?: string | File): Promise<CustomTextureInfo | null> {\n    let imagePath: string;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      imagePath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, imagePath, 'Images');\n    } else if (file) {\n      imagePath = getFilename(file.name);\n      await this.fs.writeFile(imagePath, 'Images', file);\n    } else {\n      return null;\n    }\n\n    return {\n      name: imagePath.replace(/\\.[^/.]+$/, ''),\n      path: imagePath,\n    };\n  }\n\n  async deleteImage(texture: CustomTextureInfo): Promise<void> {\n    await this.fs.removeFile(texture.path, 'Images');\n  }\n\n  async importBook(\n    // file might be:\n    // 1.1 absolute path for local file on Desktop\n    // 1.2 /private/var inbox file path on iOS\n    // 2. remote url\n    // 3. content provider uri\n    // 4. File object from browsers\n    file: string | File,\n    books: Book[],\n    saveBook: boolean = true,\n    saveCover: boolean = true,\n    overwrite: boolean = false,\n    transient: boolean = false,\n    options?: {\n      /** Desired relative path (e.g. \"技术/书名.epub\"), only used in local mode */\n      targetRelativePath?: string;\n      /** Desired group name, used to derive path when targetRelativePath is not provided */\n      targetGroupName?: string;\n    },\n  ): Promise<Book | null> {\n    const startTime = Date.now();\n    let filename = '';\n\n    try {\n      let loadedBook: BookDoc;\n      let format: BookFormat;\n      let fileobj: File;\n\n      if (transient && typeof file !== 'string') {\n        throw new Error('Transient import is only supported for file paths');\n      }\n\n      try {\n        if (typeof file === 'string') {\n          fileobj = await this.fs.openFile(file, 'None');\n          filename = fileobj.name || getFilename(file);\n        } else {\n          fileobj = file;\n          filename = file.name;\n        }\n\n        // 记录文件大小\n        const fileSizeMB = fileobj.size / (1024 * 1024);\n        console.log(`[importBook] Processing: ${filename}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // 检查文件大小\n        if (fileobj.size === 0) {\n          throw new Error('Invalid or empty book file');\n        }\n\n        // 警告大文件\n        if (fileobj.size > 100 * 1024 * 1024) {\n          console.warn(`[importBook] ⚠️ Large file: ${fileSizeMB.toFixed(2)} MB, processing may take longer`);\n        }\n\n        if (/\\.txt$/i.test(filename)) {\n          const txt2epub = new TxtToEpubConverter();\n          ({ file: fileobj } = await txt2epub.convert({ file: fileobj }));\n        }\n\n        console.log(`[importBook] Opening document: ${filename}`);\n        ({ book: loadedBook, format } = await new DocumentLoader(fileobj).open());\n\n        if (!loadedBook) {\n          throw new Error('Unsupported or corrupted book file');\n        }\n        const metadataTitle = formatTitle(loadedBook.metadata.title);\n        if (!metadataTitle || !metadataTitle.trim() || metadataTitle === filename) {\n          loadedBook.metadata.title = getBaseFilename(filename);\n        }\n\n        console.log(`[importBook] ✓ Document opened successfully: ${filename}`);\n      } catch (error) {\n        const errorMsg = (error as Error).message || String(error);\n        console.error(`[importBook] ✗ Failed to open book: ${filename}`, errorMsg);\n        throw new Error(`Failed to open the book: ${errorMsg}`);\n      }\n\n      console.log(`[importBook] Computing hash for: ${filename}`);\n      const hash = await partialMD5(fileobj);\n      const existingBook = books.filter((b) => b.hash === hash)[0];\n      const now = Date.now();\n      if (existingBook) {\n        if (!transient) {\n          existingBook.deletedAt = null;\n        }\n        existingBook.createdAt = now;\n        existingBook.updatedAt = now;\n      }\n\n      const primaryLanguage = getPrimaryLanguage(loadedBook.metadata.language);\n      const book: Book = {\n        hash,\n        format,\n        title: formatTitle(loadedBook.metadata.title),\n        sourceTitle: formatTitle(loadedBook.metadata.title),\n        primaryLanguage,\n        author: formatAuthors(loadedBook.metadata.author, primaryLanguage),\n        createdAt: existingBook ? existingBook.createdAt : now,\n        uploadedAt: existingBook ? existingBook.uploadedAt : (transient ? null : now),\n        deletedAt: transient ? now : null,\n        downloadedAt: now,\n        updatedAt: now,\n      };\n      // update book metadata when reimporting the same book\n      if (existingBook) {\n        existingBook.format = book.format;\n        existingBook.title = existingBook.title.trim() ? existingBook.title.trim() : book.title;\n        existingBook.sourceTitle = existingBook.sourceTitle ?? book.sourceTitle;\n        existingBook.author = existingBook.author ?? book.author;\n        existingBook.primaryLanguage = existingBook.primaryLanguage ?? book.primaryLanguage;\n        existingBook.downloadedAt = Date.now();\n      }\n\n      // Decide whether to use new flat local storage path\n      // Check runtime window.__STORAGE_MODE__ first (set by Providers), then fallback to compile-time env var\n      const isLocalStorageMode =\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') ||\n        process.env['NEXT_PUBLIC_STORAGE_MODE'] === 'local';\n      const shouldUseLocalFlatStorage = this.appPlatform === 'web' && isLocalStorageMode;\n\n      console.log('[ImportBook] appPlatform:', this.appPlatform, 'STORAGE_MODE (runtime):', (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__), 'STORAGE_MODE (env):', process.env['NEXT_PUBLIC_STORAGE_MODE'], 'shouldUseLocalFlatStorage:', shouldUseLocalFlatStorage);\n\n      const fileExt = EXTS[format] || format.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title);\n      const targetGroupName = options?.targetGroupName?.trim();\n\n      // Compute target relative path for local mode\n      if (shouldUseLocalFlatStorage) {\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n\n        if (!derivedRelativePath) {\n          throw new Error('targetRelativePath is required for local storage mode. Please provide a valid relative path.');\n        }\n\n        book.relativePath = derivedRelativePath;\n        console.log('[ImportBook] 5. Setting book.relativePath to:', derivedRelativePath);\n        console.log('[ImportBook] 6. Book hash:', book.hash);\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n        if (targetGroupName && !book.groupName) {\n          book.groupName = targetGroupName;\n          if (existingBook && !existingBook.groupName) {\n            existingBook.groupName = targetGroupName;\n          }\n        }\n      } else if (this.appPlatform === 'web') {\n        // For web platform in remote mode, still require relativePath for consistency\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n        book.relativePath = derivedRelativePath;\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n      }\n\n      // Ensure destination directories exist (new flat structure or legacy hash-based)\n      await this.ensureLocalBookDirs(book);\n\n      const bookFilename = getLocalBookFilename(book);\n      if (saveBook && !transient && (!(await this.fs.exists(bookFilename, 'Books')) || overwrite)) {\n        if (/\\.txt$/i.test(filename)) {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        } else if (typeof file === 'string' && isContentURI(file)) {\n          await this.fs.copyFile(file, bookFilename, 'Books');\n        } else if (typeof file === 'string' && !isValidURL(file)) {\n          try {\n            // try to copy the file directly first in case of large files to avoid memory issues\n            // on desktop when reading recursively from selected directory the direct copy will fail\n            // due to permission issues, then fallback to read and write files\n            await this.fs.copyFile(file, bookFilename, 'Books');\n          } catch {\n            await this.fs.writeFile(bookFilename, 'Books', await fileobj.arrayBuffer());\n          }\n        } else {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        }\n      }\n      if (saveCover && (!(await this.fs.exists(getCoverFilename(book), 'Books')) || overwrite)) {\n        console.log('[ImportBook] 7. Preparing to save cover');\n        let cover = await loadedBook.getCover();\n        if (cover?.type === 'image/svg+xml') {\n          try {\n            console.log('[ImportBook] Converting SVG cover to PNG...');\n            cover = await svg2png(cover);\n          } catch { }\n        }\n        if (cover) {\n          const coverFilename = getCoverFilename(book);\n          console.log('[ImportBook] 8. Saving cover with filename:', coverFilename);\n          console.log('[ImportBook] 9. Cover size:', cover.size, 'bytes');\n          await this.fs.writeFile(coverFilename, 'Books', await cover.arrayBuffer());\n          console.log('[ImportBook] 10. Cover saved successfully');\n        }\n      }\n      // Never overwrite the config file only when it's not existed\n      if (!existingBook) {\n        await this.saveBookConfig(book, INIT_BOOK_CONFIG);\n        books.splice(0, 0, book);\n      }\n\n      // update file links with url or path or content uri\n      if (typeof file === 'string') {\n        if (isValidURL(file)) {\n          book.url = file;\n          if (existingBook) existingBook.url = file;\n        }\n        if (transient) {\n          book.filePath = file;\n          if (existingBook) existingBook.filePath = file;\n        }\n      }\n      book.coverImageUrl = await this.generateCoverImageUrl(book);\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n\n      const elapsed = Date.now() - startTime;\n      console.log(`[importBook] ✓ Import completed in ${elapsed}ms: ${filename}`);\n\n      return existingBook || book;\n    } catch (error) {\n      const elapsed = Date.now() - startTime;\n      const errorMsg = (error as Error).message || String(error);\n      const errorStack = (error as Error).stack;\n\n      console.error(`[importBook] ✗ Import failed after ${elapsed}ms`);\n      console.error(`[importBook] File: ${filename || (typeof file === 'string' ? file : 'unknown')}`);\n      console.error(`[importBook] Error: ${errorMsg}`);\n      if (errorStack) {\n        console.error(`[importBook] Stack trace:`, errorStack);\n      }\n\n      // 如果是内存错误，提供更明确的提示\n      if (errorMsg.includes('memory') || errorMsg.includes('ENOMEM')) {\n        throw new Error(`内存不足：文件可能过大。请尝试导入较小的文件或关闭其他程序。原始错误：${errorMsg}`);\n      }\n\n      // 如果是文件大小限制错误，直接抛出\n      if (errorMsg.includes('too large') || errorMsg.includes('Maximum size')) {\n        throw error;\n      }\n\n      throw error;\n    }\n  }\n\n  async importBookFromPath(\n    filePath: string,\n    relativePath: string,\n    books: Book[],\n  ): Promise<Book | null> {\n    try {\n      // Extract directory structure for grouping\n      const directory = relativePath.split('/').slice(0, -1).join('/');\n      const groupName = directory || '';\n\n      // Import the book as transient (don't copy, just reference)\n      const book = await this.importBook(\n        filePath,\n        books,\n        false, // saveBook = false\n        true,  // saveCover = true\n        false, // overwrite = false\n        true,  // transient = true\n        {\n          targetRelativePath: relativePath,\n          targetGroupName: groupName,\n        },\n      );\n\n      return book;\n    } catch (error) {\n      console.error('Error importing book from path:', filePath, error);\n      return null;\n    }\n  }\n\n  /**\n   * 重新分类书籍 - 在本地存储模式下移动文件\n   * 在前端修改书籍分组时，需要同步文件系统中的文件位置\n   */\n  async reclassifyBook(book: Book, newGroupName: string, oldGroupName?: string): Promise<void> {\n    // 仅在本地存储模式下执行文件移动\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reclassify] 非本地存储模式，跳过文件移动');\n      return;\n    }\n\n    // 如果没有 relativePath，说明是旧的 hash-based 存储，不执行文件移动\n    if (!book.relativePath) {\n      console.log('[Reclassify] 书籍未使用新存储结构，跳过文件移动:', book.title);\n      return;\n    }\n\n    try {\n      // 获取当前设置，读取分组目录配置\n      const settings = await this.loadSettings();\n      const groupDirectories = settings.groupDirectories || {};\n\n      // 当前的 relativePath 就是旧路径\n      const oldRelativePath = book.relativePath;\n\n      // 提取文件名（不包含分组路径）\n      let filename: string;\n      if (oldGroupName && oldRelativePath.startsWith(`${oldGroupName}/`)) {\n        // 如果旧路径包含分组，提取文件名\n        filename = oldRelativePath.substring(oldGroupName.length + 1);\n      } else {\n        // 否则，relativePath 本身就是文件名（或已经是正确的相对路径）\n        // 提取最后的文件名部分\n        const parts = oldRelativePath.split('/');\n        filename = parts[parts.length - 1] || '';\n      }\n\n      // 计算新路径：\n      // 1. 如果新分组在 groupDirectories 中有配置，使用配置的目录\n      // 2. 否则使用分组名称作为目录\n      let targetDirectory: string;\n      if (newGroupName && groupDirectories[newGroupName]) {\n        targetDirectory = groupDirectories[newGroupName];\n      } else if (newGroupName) {\n        targetDirectory = newGroupName;\n      } else {\n        targetDirectory = '';\n      }\n\n      const newRelativePath = targetDirectory\n        ? `${targetDirectory}/${filename}`\n        : filename;\n\n      // 如果新旧路径相同，无需移动\n      if (oldRelativePath === newRelativePath) {\n        console.log('[Reclassify] 书籍分组未改变，无需移动文件');\n        return;\n      }\n\n      console.log('[Reclassify] 准备移动书籍文件');\n      console.log('  旧路径:', oldRelativePath);\n      console.log('  新路径:', newRelativePath);\n      console.log('  文件名:', filename);\n      console.log('  新分组:', newGroupName);\n      console.log('  目标目录:', targetDirectory);\n\n      // 调用 API 移动文件\n      const response = await fetch('/api/storage/reclassify', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          oldPath: oldRelativePath,\n          newPath: newRelativePath,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reclassify] 文件移动失败:', error);\n        throw new Error(`Failed to move book files: ${error}`);\n      }\n\n      const result = await response.json();\n\n      // 更新 book 的路径信息\n      book.relativePath = newRelativePath;\n      book.groupName = newGroupName || undefined;\n      // 如果 API 返回了绝对路径，也更新它\n      if (result.absolutePath) {\n        book.absolutePath = result.absolutePath;\n      }\n\n      console.log('[Reclassify] 文件移动成功:', result);\n    } catch (error) {\n      console.error('[Reclassify] 重新分类书籍时出错:', error);\n      throw error;\n    }\n  }\n\n  async deleteBook(book: Book, deleteAction: DeleteAction): Promise<void> {\n    console.log('Deleting book with action:', deleteAction, book.title);\n    if (deleteAction === 'local' || deleteAction === 'both') {\n      const localDeleteFps =\n        deleteAction === 'local'\n          ? [getLocalBookFilename(book)]\n          : [getLocalBookFilename(book), getCoverFilename(book)];\n      for (const fp of localDeleteFps) {\n        console.log('Deleting local file:', fp);\n        await this.fs.removeFile(fp, 'Books');\n      }\n      if (deleteAction === 'local') {\n        book.downloadedAt = null;\n      } else {\n        book.deletedAt = Date.now();\n        book.downloadedAt = null;\n        book.coverDownloadedAt = null;\n      }\n    }\n    // Cloud storage delete functionality removed - using local server storage only\n    if ((deleteAction === 'cloud' || deleteAction === 'both') && book.uploadedAt) {\n      console.log('Cloud delete operation skipped - cloud storage removed');\n      book.uploadedAt = null;\n    }\n  }\n\n  // Cloud storage methods removed - using local server storage only\n\n  async exportBook(book: Book): Promise<boolean> {\n    const { file } = await this.loadBookContent(book);\n    const content = await file.arrayBuffer();\n    const filename = `${makeSafeFilename(book.title)}.${book.format.toLowerCase()}`;\n    const filepath = await this.resolveFilePath(getLocalBookFilename(book), 'Books');\n    const fileType = file.type || 'application/octet-stream';\n    return await this.saveFile(filename, content, filepath, fileType);\n  }\n\n  async isBookAvailable(book: Book): Promise<boolean> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      return true;\n    }\n    if (book.filePath) {\n      return await this.fs.exists(book.filePath, 'None');\n    }\n    if (book.url) {\n      return isValidURL(book.url);\n    }\n    return false;\n  }\n\n  async getBookFileSize(book: Book): Promise<number | null> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      const file = await this.fs.openFile(fp, 'Books');\n      const size = file.size;\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n      return size;\n    }\n    return null;\n  }\n\n  async loadBookContent(book: Book): Promise<BookContent> {\n    let file: File;\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      file = await this.fs.openFile(fp, 'Books');\n    } else if (book.filePath) {\n      file = await this.fs.openFile(book.filePath, 'None');\n    } else if (book.url) {\n      file = await this.fs.openFile(book.url, 'None');\n    } else {\n      // 0.9.64 has a bug that book.title might be modified but the filename is not updated\n      const bookDir = getDir(book);\n      const files = await this.fs.readDir(getDir(book), 'Books');\n      if (files.length > 0) {\n        const bookFile = files.find((f) => f.path.endsWith(`.${EXTS[book.format]}`));\n        if (bookFile) {\n          file = await this.fs.openFile(`${bookDir}/${bookFile.path}`, 'Books');\n        } else {\n          throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n        }\n      } else {\n        throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n      }\n    }\n    return { book, file };\n  }\n\n  async loadBookConfig(book: Book, settings: SystemSettings): Promise<BookConfig> {\n    const globalViewSettings = {\n      ...settings.globalViewSettings,\n      ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n    };\n    try {\n      let str = '{}';\n      if (await this.fs.exists(getConfigFilename(book), 'Books')) {\n        str = (await this.fs.readFile(getConfigFilename(book), 'Books', 'text')) as string;\n      }\n      return deserializeConfig(str, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } catch {\n      return deserializeConfig('{}', globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    }\n  }\n\n  async fetchBookDetails(book: Book) {\n    const fp = getLocalBookFilename(book);\n    if (!(await this.fs.exists(fp, 'Books')) && book.uploadedAt) {\n      // Cloud download functionality removed - books should already be stored locally\n      console.warn('Book file not found locally and cloud download is disabled:', book.title);\n      throw new Error('Book file not found locally');\n    }\n    const { file } = await this.loadBookContent(book);\n    const bookDoc = (await new DocumentLoader(file).open()).book;\n    const f = file as ClosableFile;\n    if (f && f.close) {\n      await f.close();\n    }\n    return bookDoc.metadata;\n  }\n\n  async saveBookConfig(book: Book, config: BookConfig, settings?: SystemSettings) {\n    let serializedConfig: string;\n    if (settings) {\n      const globalViewSettings = {\n        ...settings.globalViewSettings,\n        ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n      };\n      serializedConfig = serializeConfig(config, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } else {\n      serializedConfig = JSON.stringify(config);\n    }\n    await this.fs.writeFile(getConfigFilename(book), 'Books', serializedConfig);\n  }\n\n  async generateCoverImageUrl(book: Book): Promise<string> {\n    return this.appPlatform === 'web'\n      ? await this.getCoverImageBlobUrl(book)\n      : this.getCoverImageUrl(book);\n  }\n\n  async loadLibraryBooks(): Promise<Book[]> {\n    console.log('Loading library books...');\n    const libraryFilename = getLibraryFilename();\n\n    if (!(await this.fs.exists('', 'Books'))) {\n      await this.fs.createDir('', 'Books', true);\n    }\n\n    const books = await this.safeLoadJSON<Book[]>(libraryFilename, 'Books', []);\n\n    await Promise.all(\n      books.map(async (book) => {\n        book.coverImageUrl = await this.generateCoverImageUrl(book);\n        book.updatedAt ??= book.lastUpdated || Date.now();\n        return book;\n      }),\n    );\n\n    return books;\n  }\n\n  async saveLibraryBooks(books: Book[]): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const libraryBooks = books.map(({ coverImageUrl, ...rest }) => rest);\n    await this.safeSaveJSON(getLibraryFilename(), 'Books', libraryBooks);\n  }\n\n  /**\n   * 校准书籍路径\n   * 扫描文件系统与 library.json 进行对比，找出路径不一致的书籍\n   */\n  async reconcileBookPaths(books: Book[]): Promise<any> {\n    // 仅在本地存储模式下执行\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reconcile] 非本地存储模式，跳过路径校准');\n      return { success: false, error: 'Not in local storage mode' };\n    }\n\n    try {\n      console.log('[Reconcile] 开始校准书籍路径，共', books.length, '本书');\n\n      // 准备需要发送的书籍数据（只发送必要字段）\n      const libraryData = books\n        .filter(book => !book.deletedAt)\n        .map(book => ({\n          hash: book.hash,\n          relativePath: book.relativePath,\n          absolutePath: book.absolutePath,\n          title: book.title,\n          groupName: book.groupName,\n        }));\n\n      const response = await fetch('/api/storage/reconcile', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ library: libraryData }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reconcile] 路径校准失败:', error);\n        throw new Error(`Failed to reconcile paths: ${error}`);\n      }\n\n      const result = await response.json();\n      console.log('[Reconcile] 路径校准完成:', result.summary);\n      return result;\n    } catch (error) {\n      console.error('[Reconcile] 路径校准出错:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 应用路径校准结果\n   * 根据校准结果更新 library.json 中的书籍信息\n   */\n  async applyReconciliation(books: Book[], reconcileResults: any[]): Promise<Book[]> {\n    const updatedBooks = [...books];\n\n    for (const result of reconcileResults) {\n      if (result.status === 'moved') {\n        // 找到对应的书籍并更新路径信息\n        const bookIndex = updatedBooks.findIndex(b => b.hash === result.hash);\n        if (bookIndex !== -1) {\n          const book = updatedBooks[bookIndex];\n          if (book) {\n            book.relativePath = result.newRelativePath;\n            book.absolutePath = result.absolutePath;\n            if (result.suggestedGroupName !== undefined) {\n              book.groupName = result.suggestedGroupName;\n              // 更新 groupId\n              book.groupId = result.suggestedGroupName\n                ? md5Fingerprint(result.suggestedGroupName)\n                : '';\n            }\n            book.updatedAt = Date.now();\n            console.log('[Reconcile] 更新书籍:', book.title, '新路径:', book.relativePath);\n          }\n        }\n      }\n    }\n\n    await this.saveLibraryBooks(updatedBooks);\n    return updatedBooks;\n  }\n\n  private imageToArrayBuffer(imageUrl?: string, imageFile?: string): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      if (!imageUrl && !imageFile) {\n        reject(new Error('No image URL or file provided'));\n        return;\n      }\n      if (this.appPlatform === 'web' && imageUrl && imageUrl.startsWith('blob:')) {\n        fetch(imageUrl)\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageFile) {\n        this.fs\n          .openFile(imageFile, 'None')\n          .then((file) => file.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageUrl) {\n        tauriFetch(imageUrl, { method: 'GET' })\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else {\n        reject(new Error('Unsupported platform or missing image data'));\n      }\n    });\n  }\n\n  async updateCoverImage(book: Book, imageUrl?: string, imageFile?: string): Promise<void> {\n    if (imageUrl === '_blank') {\n      await this.fs.removeFile(getCoverFilename(book), 'Books');\n    } else if (imageUrl || imageFile) {\n      const arrayBuffer = await this.imageToArrayBuffer(imageUrl, imageFile);\n      await this.fs.writeFile(getCoverFilename(book), 'Books', arrayBuffer);\n    }\n  }\n\n  private async loadJSONFile(\n    path: string,\n    base: BaseDir,\n  ): Promise<{ success: boolean; data?: unknown; error?: unknown }> {\n    try {\n      const txt = await this.fs.readFile(path, base, 'text');\n      if (!txt || typeof txt !== 'string' || txt.trim().length === 0) {\n        return { success: false, error: 'File is empty or invalid' };\n      }\n      try {\n        const data = JSON.parse(txt as string);\n        return { success: true, data };\n      } catch (parseError) {\n        return { success: false, error: `JSON parse error: ${parseError}` };\n      }\n    } catch (error) {\n      return { success: false, error };\n    }\n  }\n\n  /**\n   * Safely loads a JSON file with automatic backup fallback.\n   * If the main file is corrupted, attempts to load from backup.\n   * @param filename - The name of the file to load (without .bak extension)\n   * @param base - The base directory\n   * @param defaultValue - Default value to return if both files fail\n   */\n  private async safeLoadJSON<T>(filename: string, base: BaseDir, defaultValue: T): Promise<T> {\n    const backupFilename = `${filename}.bak`;\n\n    // Try loading main file\n    const mainResult = await this.loadJSONFile(filename, base);\n    if (mainResult.success) {\n      return mainResult.data as T;\n    }\n\n    console.warn(`Failed to load ${filename}, attempting backup...`, mainResult.error);\n\n    // Try loading backup file\n    const backupResult = await this.loadJSONFile(backupFilename, base);\n    if (backupResult.success) {\n      console.warn(`Loaded from backup: ${backupFilename}`);\n      // Restore the main file from backup\n      try {\n        const backupData = JSON.stringify(backupResult.data, null, 2);\n        await this.fs.writeFile(filename, base, backupData);\n        console.log(`Restored ${filename} from backup`);\n      } catch (error) {\n        console.error(`Failed to restore ${filename} from backup:`, error);\n      }\n      return backupResult.data as T;\n    }\n\n    console.error(`Both ${filename} and ${backupFilename} failed to load`);\n    return defaultValue;\n  }\n\n  /**\n   * Safely saves a JSON file with atomic write using backup strategy.\n   * Strategy: write to backup first, then to main file.\n   * This ensures at least one valid copy exists at all times.\n   * @param filename - The name of the file to save (without .bak extension)\n   * @param base - The base directory\n   * @param data - The data to save\n   */\n  private async safeSaveJSON(filename: string, base: BaseDir, data: unknown): Promise<void> {\n    const backupFilename = `${filename}.bak`;\n    const jsonData = JSON.stringify(data, null, 2);\n\n    // Strategy: Always write to backup first, then to main file\n    // This ensures we always have at least one valid copy\n    try {\n      // Step 1: Write to backup file\n      await this.fs.writeFile(backupFilename, base, jsonData);\n\n      // Step 2: Write to main file\n      await this.fs.writeFile(filename, base, jsonData);\n    } catch (error) {\n      console.error(`Failed to save ${filename}:`, error);\n      throw new Error(`Failed to save ${filename}: ${error}`);\n    }\n  }\n\n  /** Ensure necessary directories exist for a book (both legacy hash-based and new flat local paths). */\n  private async ensureLocalBookDirs(book: Book): Promise<void> {\n    if (book.relativePath) {\n      const segments = book.relativePath.split('/');\n      const fileDir = segments.slice(0, -1).join('/');\n      const metadataDir = book.relativePath.replace(/\\.[^.]+$/, '');\n\n      if (fileDir) {\n        await this.fs.createDir(fileDir, 'Books', true);\n      }\n      await this.fs.createDir(metadataDir, 'Books', true);\n      return;\n    }\n\n    // Legacy hash-based storage\n    if (!(await this.fs.exists(getDir(book), 'Books'))) {\n      await this.fs.createDir(getDir(book), 'Books');\n    }\n  }\n\n  private async migrate20251124(): Promise<void> {\n    console.log('Running migration for version 20251124 to rename the backup library file...');\n    const oldBackupFilename = getLibraryBackupFilename();\n    const newBackupFilename = `${getLibraryFilename()}.bak`;\n    if (await this.fs.exists(oldBackupFilename, 'Books')) {\n      try {\n        const content = await this.fs.readFile(oldBackupFilename, 'Books', 'text');\n        await this.fs.writeFile(newBackupFilename, 'Books', content);\n        await this.fs.removeFile(oldBackupFilename, 'Books');\n        console.log('Migration to rename backup library file completed successfully.');\n      } catch (error) {\n        console.error('Error during migration to rename backup library file:', error);\n      }\n    }\n  }\n\n  /**\n   * Migration 20260121: move legacy hash-based local books to flat relativePath layout in local mode.\n   * - Applies only when appPlatform === 'web' and STORAGE_MODE is local\n   * - For any book without relativePath, derive a flat path and move files + metadata\n   */\n  private async migrate20260121(): Promise<void> {\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    const isLocalMode = (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') === 'local';\n    if (this.appPlatform !== 'web' || !isLocalMode) {\n      console.log('[Migration 20260121] Skip (not web/local mode)');\n      return;\n    }\n\n    console.log('[Migration 20260121] Start migrating legacy hash-based books to flat layout');\n\n    const books = await this.loadLibraryBooks();\n    let migrated = 0;\n\n    for (const book of books) {\n      if (book.relativePath) continue;\n\n      const ext = EXTS[book.format] || book.format?.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title || book.hash);\n      const newRelativePath = `${book.groupName ? `${book.groupName}/` : ''}${safeBaseName}.${ext}`;\n\n      // Legacy paths\n      const legacyBookPath = `${book.hash}/${safeBaseName}.${ext}`;\n      const legacyCoverPath = `${book.hash}/cover.png`;\n      const legacyConfigPath = `${book.hash}/config.json`;\n\n      // New paths\n      const newBookPath = newRelativePath;\n      const newCoverPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/cover.png';\n      const newConfigPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/config.json';\n\n      try {\n        // Move book file if present\n        if (await this.fs.exists(legacyBookPath, 'Books')) {\n          await this.ensureLocalBookDirs({ ...book, relativePath: newRelativePath } as Book);\n          const file = await this.fs.openFile(legacyBookPath, 'Books');\n          await this.fs.writeFile(newBookPath, 'Books', file);\n          await this.fs.removeFile(legacyBookPath, 'Books');\n        }\n\n        // Move cover\n        if (await this.fs.exists(legacyCoverPath, 'Books')) {\n          const coverFile = await this.fs.openFile(legacyCoverPath, 'Books');\n          await this.fs.writeFile(newCoverPath, 'Books', coverFile);\n          await this.fs.removeFile(legacyCoverPath, 'Books');\n        }\n\n        // Move config\n        if (await this.fs.exists(legacyConfigPath, 'Books')) {\n          const configContent = await this.fs.readFile(legacyConfigPath, 'Books', 'text');\n          await this.fs.writeFile(newConfigPath, 'Books', configContent);\n          await this.fs.removeFile(legacyConfigPath, 'Books');\n        }\n\n        // Update in-memory book\n        book.relativePath = newRelativePath;\n        migrated++;\n      } catch (error) {\n        console.error('[Migration 20260121] Failed to migrate book:', book.title, error);\n      }\n    }\n\n    if (migrated > 0) {\n      await this.saveLibraryBooks(books);\n      console.log(`[Migration 20260121] Migrated ${migrated} book(s) to flat layout`);\n    } else {\n      console.log('[Migration 20260121] No legacy books to migrate');\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2623, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/apiFileSystem.ts"],"sourcesContent":["import { FileSystem, BaseDir, ResolvedPath, FileItem } from '@/types/system';\nimport { isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { LOCAL_BOOKS_SUBDIR, LOCAL_FONTS_SUBDIR, LOCAL_IMAGES_SUBDIR, DATA_SUBDIR } from './constants';\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n    // Check if we're in local storage mode\n    const isLocalMode = (typeof process !== 'undefined' && process.env?.['NEXT_PUBLIC_STORAGE_MODE'] === 'local') ||\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local');\n\n    if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        console.log('[ResolvePath] Env Check - NEXT_PUBLIC_STORAGE_MODE:', process.env?.['NEXT_PUBLIC_STORAGE_MODE'], 'isLocalMode:', isLocalMode, 'base:', base, 'path:', path);\n    }\n\n    switch (base) {\n        case 'Data':\n            return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n        case 'Settings':\n            // Settings files now stored in .readest directory\n            return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n        case 'Books':\n            // Always use flat storage structure (no Readest/Books/ prefix)\n            // Library metadata files now go to .readest directory\n            if (path === 'library.json' || path === 'library.json.bak' || path === 'library_backup.json') {\n                console.log('[ResolvePath] Books/Library detected, routing to .readest');\n                return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n            }\n            // All book files and metadata use flat structure (no Readest/Books/ prefix)\n            console.log('[ResolvePath] ✓ Books base, flat path (no prefix):', path);\n            console.log('[ResolvePath] ✓ Returning fp:', path);\n            return { baseDir: 0, basePrefix, fp: path, base };\n        case 'Fonts':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n        case 'Images':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n        case 'None':\n            return { baseDir: 0, basePrefix, fp: path, base };\n        default:\n            return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n    }\n};\n\nexport const apiFileSystem: FileSystem = {\n    resolvePath,\n    async getPrefix(base: BaseDir) {\n        const { basePrefix, fp } = this.resolvePath('', base);\n        const basePath = await basePrefix();\n        const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n        return prefix.replace(/\\/+$/, '');\n    },\n    getURL(path: string) {\n        if (isValidURL(path)) {\n            return path;\n        }\n        return `/api/storage/file?filePath=${encodeURIComponent(path)}`;\n    },\n    async getBlobURL(path: string, base: BaseDir) {\n        try {\n            const content = await this.readFile(path, base, 'binary');\n            return URL.createObjectURL(new Blob([content]));\n        } catch {\n            return path;\n        }\n    },\n    async getImageURL(path: string) {\n        return this.getURL(path);\n    },\n    async openFile(path: string, base: BaseDir, filename?: string) {\n        if (isValidURL(path)) {\n            return await new RemoteFile(path, filename).open();\n        }\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        return new File([await res.arrayBuffer()], filename || path);\n    },\n    async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n        const file = await this.openFile(srcPath, base);\n        await this.writeFile(dstPath, base, file);\n    },\n    async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error(`File not found: ${fp}`);\n        return mode === 'text' ? await res.text() : await res.arrayBuffer();\n    },\n    async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n        const { fp } = this.resolvePath(path, base);\n        console.log('[APIFileSystem.writeFile] 11. Input path:', path);\n        console.log('[APIFileSystem.writeFile] 12. Base:', base);\n        console.log('[APIFileSystem.writeFile] 13. Resolved fp:', fp);\n        let buffer: Buffer;\n        if (content instanceof File) {\n            buffer = Buffer.from(await content.arrayBuffer());\n        } else if (typeof content === 'string') {\n            buffer = Buffer.from(content);\n        } else {\n            buffer = Buffer.from(content);\n        }\n        console.log('[APIFileSystem.writeFile] 14. Calling PUT /api/storage/file with filePath:', fp);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`, {\n            method: 'PUT',\n            body: buffer,\n        });\n        if (!res.ok) throw new Error('Failed to write file');\n    },\n    async removeFile(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/delete?fileKey=${encodeURIComponent(fp)}`, {\n            method: 'DELETE',\n        });\n        if (!res.ok) throw new Error('Failed to delete file');\n    },\n    async createDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async removeDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async readDir(path: string, base: BaseDir): Promise<FileItem[]> {\n        return [];\n    },\n    async exists(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        return res.ok;\n    },\n    async stats(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        const buffer = await res.arrayBuffer();\n        return {\n            isFile: true,\n            isDirectory: false,\n            size: buffer.byteLength,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n        };\n    },\n};\n"],"names":[],"mappings":";;;;AASgC;AAsFX;AA9FrB;AACA;AACA;;;;AAEA,MAAM,aAAa,UAAY;AAE/B,MAAM,cAAc,CAAC,MAAc;IAC/B,uCAAuC;IACvC,MAAM,cAAc,AAAC,OAAO,sUAAO,KAAK,eAAe,8CAA8C,WAChG,+CAAkB,eAAe,AAAC,OAAe,gBAAgB,KAAK;IAE3E;;IAIA,OAAQ;QACJ,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,iKAAW,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QACxE,KAAK;YACD,kDAAkD;YAClD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,CAAC,SAAS,EAAE,MAAM;gBAAE;YAAK;QAClE,KAAK;YACD,+DAA+D;YAC/D,sDAAsD;YACtD,IAAI,SAAS,kBAAkB,SAAS,sBAAsB,SAAS,uBAAuB;gBAC1F,QAAQ,GAAG,CAAC;gBACZ,OAAO;oBAAE,SAAS;oBAAG;oBAAY,IAAI,CAAC,SAAS,EAAE,MAAM;oBAAE;gBAAK;YAClE;YACA,4EAA4E;YAC5E,QAAQ,GAAG,CAAC,sDAAsD;YAClE,QAAQ,GAAG,CAAC,iCAAiC;YAC7C,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI;gBAAM;YAAK;QACpD,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,wKAAkB,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QAC/E,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,yKAAmB,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QAChF,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI;gBAAM;YAAK;QACpD;YACI,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,KAAK,CAAC,EAAE,MAAM;gBAAE;YAAK;IACrE;AACJ;AAEO,MAAM,gBAA4B;IACrC;IACA,MAAM,WAAU,IAAa;QACzB,MAAM,EAAE,UAAU,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI;QAChD,MAAM,WAAW,MAAM;QACvB,MAAM,SAAS,KAAM,WAAW,GAAG,SAAS,CAAC,EAAE,IAAI,GAAG,KAAM;QAC5D,OAAO,OAAO,OAAO,CAAC,QAAQ;IAClC;IACA,QAAO,IAAY;QACf,IAAI,IAAA,wJAAU,EAAC,OAAO;YAClB,OAAO;QACX;QACA,OAAO,CAAC,2BAA2B,EAAE,mBAAmB,OAAO;IACnE;IACA,MAAM,YAAW,IAAY,EAAE,IAAa;QACxC,IAAI;YACA,MAAM,UAAU,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,MAAM;YAChD,OAAO,IAAI,eAAe,CAAC,IAAI,KAAK;gBAAC;aAAQ;QACjD,EAAE,OAAM;YACJ,OAAO;QACX;IACJ;IACA,MAAM,aAAY,IAAY;QAC1B,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB;IACA,MAAM,UAAS,IAAY,EAAE,IAAa,EAAE,QAAiB;QACzD,IAAI,IAAA,wJAAU,EAAC,OAAO;YAClB,OAAO,MAAM,IAAI,wJAAU,CAAC,MAAM,UAAU,IAAI;QACpD;QACA,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;QAC7B,OAAO,IAAI,KAAK;YAAC,MAAM,IAAI,WAAW;SAAG,EAAE,YAAY;IAC3D;IACA,MAAM,UAAS,OAAe,EAAE,OAAe,EAAE,IAAa;QAC1D,MAAM,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS;QAC1C,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,MAAM;IACxC;IACA,MAAM,UAAS,IAAY,EAAE,IAAa,EAAE,IAAuB;QAC/D,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI;QACpD,OAAO,SAAS,SAAS,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,WAAW;IACrE;IACA,MAAM,WAAU,IAAY,EAAE,IAAa,EAAE,OAAoC;QAC7E,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,QAAQ,GAAG,CAAC,6CAA6C;QACzD,QAAQ,GAAG,CAAC,uCAAuC;QACnD,QAAQ,GAAG,CAAC,8CAA8C;QAC1D,IAAI;QACJ,IAAI,mBAAmB,MAAM;YACzB,SAAS,mUAAM,CAAC,IAAI,CAAC,MAAM,QAAQ,WAAW;QAClD,OAAO,IAAI,OAAO,YAAY,UAAU;YACpC,SAAS,mUAAM,CAAC,IAAI,CAAC;QACzB,OAAO;YACH,SAAS,mUAAM,CAAC,IAAI,CAAC;QACzB;QACA,QAAQ,GAAG,CAAC,8EAA8E;QAC1F,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK,EAAE;YAC5E,QAAQ;YACR,MAAM;QACV;QACA,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;IACjC;IACA,MAAM,YAAW,IAAY,EAAE,IAAa;QACxC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,4BAA4B,EAAE,mBAAmB,KAAK,EAAE;YAC7E,QAAQ;QACZ;QACA,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;IACjC;IACA,MAAM,WAAU,IAAY,EAAE,IAAa;IACvC,kCAAkC;IACtC;IACA,MAAM,WAAU,IAAY,EAAE,IAAa;IACvC,kCAAkC;IACtC;IACA,MAAM,SAAQ,IAAY,EAAE,IAAa;QACrC,OAAO,EAAE;IACb;IACA,MAAM,QAAO,IAAY,EAAE,IAAa;QACpC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,OAAO,IAAI,EAAE;IACjB;IACA,MAAM,OAAM,IAAY,EAAE,IAAa;QACnC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;QAC7B,MAAM,SAAS,MAAM,IAAI,WAAW;QACpC,OAAO;YACH,QAAQ;YACR,aAAa;YACb,MAAM,OAAO,UAAU;YACvB,OAAO;YACP,OAAO;YACP,WAAW;QACf;IACJ;AACJ"}},
    {"offset": {"line": 2819, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/webAppService.ts"],"sourcesContent":["import { FileSystem, BaseDir, AppPlatform, ResolvedPath, FileItem } from '@/types/system';\nimport { getOSPlatform, isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { isPWA } from './environment';\nimport { BaseAppService } from './appService';\nimport {\n  DATA_SUBDIR,\n  LOCAL_BOOKS_SUBDIR,\n  LOCAL_FONTS_SUBDIR,\n  LOCAL_IMAGES_SUBDIR,\n} from './constants';\nimport { apiFileSystem } from './apiFileSystem';\n\n// Check storage mode at runtime to support window.__STORAGE_MODE__ set by Providers\nconst getIsLocalStorageMode = (): boolean => {\n  // First check window.__STORAGE_MODE__ (runtime set by Providers)\n  if (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') {\n    return true;\n  }\n  // Fallback to compile-time environment variable\n  return (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n};\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n  switch (base) {\n    case 'Data':\n      return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n    case 'Books':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_BOOKS_SUBDIR}/${path}`, base };\n    case 'Fonts':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n    case 'Images':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n    case 'None':\n      return { baseDir: 0, basePrefix, fp: path, base };\n    default:\n      return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n  }\n};\n\nconst dbName = 'AppFileSystem';\nconst dbVersion = 1;\n\nasync function openIndexedDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(dbName, dbVersion);\n\n    request.onupgradeneeded = () => {\n      const db = request.result;\n      if (!db.objectStoreNames.contains('files')) {\n        db.createObjectStore('files', { keyPath: 'path' });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst indexedDBFileSystem: FileSystem = {\n  resolvePath,\n  async getPrefix(base: BaseDir) {\n    const { basePrefix, fp } = this.resolvePath('', base);\n    const basePath = await basePrefix();\n    const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n    return prefix.replace(/\\/+$/, '');\n  },\n  getURL(path: string) {\n    if (isValidURL(path)) {\n      return path;\n    } else {\n      return URL.createObjectURL(new Blob([path]));\n    }\n  },\n  async getBlobURL(path: string, base: BaseDir) {\n    try {\n      const content = await this.readFile(path, base, 'binary');\n      return URL.createObjectURL(new Blob([content]));\n    } catch {\n      return path;\n    }\n  },\n  async getImageURL(path: string) {\n    return await this.getBlobURL(path, 'None');\n  },\n  async openFile(path: string, base: BaseDir, filename?: string) {\n    if (isValidURL(path)) {\n      return await new RemoteFile(path, filename).open();\n    } else {\n      const content = await this.readFile(path, base, 'binary');\n      return new File([content], filename || path);\n    }\n  },\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n    const { fp } = this.resolvePath(dstPath, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const getRequest = store.get(srcPath);\n\n      getRequest.onsuccess = () => {\n        const data = getRequest.result;\n        if (data) {\n          store.put({ path: fp, content: data.content });\n          resolve();\n        } else {\n          reject(new Error(`File not found: ${srcPath}`));\n        }\n      };\n\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  },\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<string | ArrayBuffer>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = async () => {\n        if (request.result) {\n          const content = request.result.content;\n          if (mode === 'text') resolve(content);\n          else {\n            if (content instanceof Blob) {\n              const arrayBuffer = await content.arrayBuffer();\n              resolve(arrayBuffer);\n            } else if (content instanceof ArrayBuffer) {\n              resolve(content);\n            } else if (typeof content === 'string') {\n              resolve(new TextEncoder().encode(content).buffer as ArrayBuffer);\n            } else {\n              reject(new Error('Unsupported content type in IndexedDB'));\n            }\n          }\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    if (content instanceof File) {\n      content = await content.arrayBuffer();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.put({ path: fp, content });\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async removeFile(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.delete(fp);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async createDir(path: string, base: BaseDir) {\n    return await this.writeFile(path, base, '');\n  },\n  async removeDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string }[];\n        files.forEach((file) => {\n          if (file.path.startsWith(fp)) {\n            store.delete(file.path);\n          }\n        });\n      };\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async readDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<FileItem[]>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string; content: string | ArrayBuffer | Blob }[];\n        resolve(\n          files\n            .filter((file) => file.path.startsWith(fp))\n            .map((file) => ({\n              path: file.path.slice(fp.length + 1),\n              size:\n                file.content instanceof Blob\n                  ? file.content.size\n                  : typeof file.content === 'string'\n                    ? file.content.length\n                    : file.content instanceof ArrayBuffer\n                      ? file.content.byteLength\n                      : 0,\n            })),\n        );\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async exists(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<boolean>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => resolve(!!request.result);\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async stats(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (result) {\n          const content = result.content;\n          const size =\n            content instanceof Blob\n              ? content.size\n              : typeof content === 'string'\n                ? content.length\n                : content instanceof ArrayBuffer\n                  ? content.byteLength\n                  : 0;\n          resolve({\n            isFile: true,\n            isDirectory: false,\n            size,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n          });\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n};\n\nexport class WebAppService extends BaseAppService {\n  // Use getter to check storage mode dynamically at runtime\n  get fs(): FileSystem {\n    return getIsLocalStorageMode() ? apiFileSystem : indexedDBFileSystem;\n  }\n  override isMobile = ['android', 'ios'].includes(getOSPlatform());\n  override appPlatform = 'web' as AppPlatform;\n  override hasSafeAreaInset = isPWA();\n\n  override async init() {\n    await this.loadSettings();\n    await this.prepareBooksDir();\n    await this.runMigrations();\n  }\n\n  override async runMigrations() {\n    try {\n      const settings = await this.loadSettings();\n      const lastMigrationVersion = settings.migrationVersion || 0;\n\n      await super.runMigrations(lastMigrationVersion);\n\n      if (lastMigrationVersion < this.CURRENT_MIGRATION_VERSION) {\n        await this.saveSettings({\n          ...settings,\n          migrationVersion: this.CURRENT_MIGRATION_VERSION,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to run migrations:', error);\n    }\n  }\n\n  override resolvePath(fp: string, base: BaseDir): ResolvedPath {\n    return this.fs.resolvePath(fp, base);\n  }\n\n  async setCustomRootDir() {\n    // No-op in web environment\n  }\n\n  async selectDirectory(): Promise<string> {\n    throw new Error('selectDirectory is not supported in browser');\n  }\n\n  async selectFiles(): Promise<string[]> {\n    throw new Error('selectFiles is not supported in browser');\n  }\n\n  async saveFile(filename: string, content: string | ArrayBuffer, mimeType?: string): Promise<boolean> {\n    try {\n      const blob = new Blob([content], { type: mimeType || 'application/octet-stream' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      return true;\n    } catch (error) {\n      console.error('Failed to save file:', error);\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}}]
}
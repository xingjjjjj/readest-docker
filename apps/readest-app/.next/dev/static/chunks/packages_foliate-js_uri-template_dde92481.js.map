{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/uri-template.js"],"sourcesContent":["// URI Template: https://datatracker.ietf.org/doc/html/rfc6570\n\nconst regex = /{([+#./;?&])?([^}]+?)}/g\nconst varspecRegex = /(.+?)(\\*|:[1-9]\\d{0,3})?$/\n\nconst table = {\n    undefined: { first: '', sep: ',' },\n    '+': { first: '', sep: ',', allowReserved: true },\n    '.': { first: '.', sep: '.' },\n    '/': { first: '/', sep: '/' },\n    ';': { first: ';', sep: ';', named: true, ifemp: '' },\n    '?': { first: '?', sep: '&', named: true, ifemp: '=' },\n    '&': { first: '&', sep: '&', named: true, ifemp: '=' },\n    '#': { first: '&', sep: '&', allowReserved: true },\n}\n\n// 2.4.1 Prefix Values, \"Note that this numbering is in characters, not octets\"\nconst prefix = (maxLength, str) => {\n    let result = ''\n    for (const char of str) {\n        const newResult = char\n        if (newResult.length > maxLength) return result\n        else result = newResult\n    }\n    return result\n}\n\nexport const replace = (str, map) => str.replace(regex, (_, operator, variableList) => {\n    const { first, sep, named, ifemp, allowReserved } = table[operator]\n    // TODO: this isn't spec compliant\n    const encode = allowReserved ? encodeURI : encodeURIComponent\n    const values = variableList.split(',').map(varspec => {\n        const match = varspec.match(varspecRegex)\n        if (!match) return\n        const [, name, modifier] = match\n        let value = map.get(name)\n        if (modifier?.startsWith(':')) {\n            const maxLength = parseInt(modifier.slice(1))\n            value = prefix(maxLength, value)\n        }\n        return [name, value ? encode(value) : null]\n    })\n    if (!values.filter(([, value]) => value).length) return ''\n    return first + values\n        .map(([name, value]) => value\n            ? (named ? name + (value ? '=' + value : ifemp) : value) : '')\n        .filter(x => x).join(sep)\n})\n\nexport const getVariables = str => new Set(Array.from(str.matchAll(regex),\n    ([,, variableList]) => variableList.split(',')\n        .map(varspec => varspec.match(varspecRegex)?.[1])).flat())\n"],"names":[],"mappings":"AAAA,8DAA8D;;;;;;;AAE9D,MAAM,QAAQ;AACd,MAAM,eAAe;AAErB,MAAM,QAAQ;IACV,WAAW;QAAE,OAAO;QAAI,KAAK;IAAI;IACjC,KAAK;QAAE,OAAO;QAAI,KAAK;QAAK,eAAe;IAAK;IAChD,KAAK;QAAE,OAAO;QAAK,KAAK;IAAI;IAC5B,KAAK;QAAE,OAAO;QAAK,KAAK;IAAI;IAC5B,KAAK;QAAE,OAAO;QAAK,KAAK;QAAK,OAAO;QAAM,OAAO;IAAG;IACpD,KAAK;QAAE,OAAO;QAAK,KAAK;QAAK,OAAO;QAAM,OAAO;IAAI;IACrD,KAAK;QAAE,OAAO;QAAK,KAAK;QAAK,OAAO;QAAM,OAAO;IAAI;IACrD,KAAK;QAAE,OAAO;QAAK,KAAK;QAAK,eAAe;IAAK;AACrD;AAEA,+EAA+E;AAC/E,MAAM,SAAS,CAAC,WAAW;IACvB,IAAI,SAAS;IACb,KAAK,MAAM,QAAQ,IAAK;QACpB,MAAM,YAAY;QAClB,IAAI,UAAU,MAAM,GAAG,WAAW,OAAO;aACpC,SAAS;IAClB;IACA,OAAO;AACX;AAEO,MAAM,UAAU,CAAC,KAAK,MAAQ,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,UAAU;QAClE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE,GAAG,KAAK,CAAC,SAAS;QACnE,kCAAkC;QAClC,MAAM,SAAS,gBAAgB,YAAY;QAC3C,MAAM,SAAS,aAAa,KAAK,CAAC,KAAK,GAAG,CAAC,CAAA;YACvC,MAAM,QAAQ,QAAQ,KAAK,CAAC;YAC5B,IAAI,CAAC,OAAO;YACZ,MAAM,GAAG,MAAM,SAAS,GAAG;YAC3B,IAAI,QAAQ,IAAI,GAAG,CAAC;YACpB,IAAI,UAAU,WAAW,MAAM;gBAC3B,MAAM,YAAY,SAAS,SAAS,KAAK,CAAC;gBAC1C,QAAQ,OAAO,WAAW;YAC9B;YACA,OAAO;gBAAC;gBAAM,QAAQ,OAAO,SAAS;aAAK;QAC/C;QACA,IAAI,CAAC,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,GAAK,OAAO,MAAM,EAAE,OAAO;QACxD,OAAO,QAAQ,OACV,GAAG,CAAC,CAAC,CAAC,MAAM,MAAM,GAAK,QACjB,QAAQ,OAAO,CAAC,QAAQ,MAAM,QAAQ,KAAK,IAAI,QAAS,IAC9D,MAAM,CAAC,CAAA,IAAK,GAAG,IAAI,CAAC;IAC7B;AAEO,MAAM,eAAe,CAAA,MAAO,IAAI,IAAI,MAAM,IAAI,CAAC,IAAI,QAAQ,CAAC,QAC/D,CAAC,KAAI,aAAa,GAAK,aAAa,KAAK,CAAC,KACrC,GAAG,CAAC,CAAA,UAAW,QAAQ,KAAK,CAAC,eAAe,CAAC,EAAE,GAAG,IAAI"}}]
}
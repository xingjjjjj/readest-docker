{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/tts.js"],"sourcesContent":["const NS = {\n    XML: 'http://www.w3.org/XML/1998/namespace',\n    SSML: 'http://www.w3.org/2001/10/synthesis',\n}\n\nconst blockTags = new Set([\n    'article', 'aside', 'audio', 'blockquote', 'caption',\n    'details', 'dialog', 'div', 'dl', 'dt', 'dd',\n    'figure', 'footer', 'form', 'figcaption',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'li',\n    'main', 'math', 'nav', 'ol', 'p', 'pre', 'section', 'tr',\n])\n\nconst getLang = el => {\n    const x = el.lang || el?.getAttributeNS?.(NS.XML, 'lang')\n    return x ? x : el.parentElement ? getLang(el.parentElement) : null\n}\n\nconst getAlphabet = el => {\n    const x = el?.getAttributeNS?.(NS.XML, 'lang')\n    return x ? x : el.parentElement ? getAlphabet(el.parentElement) : null\n}\n\nconst getSegmenter = (lang = 'en', granularity = 'word') => {\n    const segmenter = new Intl.Segmenter(lang, { granularity })\n    const granularityIsWord = granularity === 'word'\n    return function* (strs, makeRange) {\n        const str = strs.join('').replace(/\\r\\n/g, '  ').replace(/\\r/g, ' ').replace(/\\n/g, ' ')\n        let name = 0\n        let strIndex = -1\n        let sum = 0\n        const rawSegments = Array.from(segmenter.segment(str))\n        const mergedSegments = []\n        for (let i = 0; i < rawSegments.length; i++) {\n            const current = rawSegments[i]\n            const next = rawSegments[i + 1]\n            const segment = current.segment.trim()\n            const nextSegment = next?.segment?.trim()\n            const endsWithAbbr = /(?:^|\\s)([A-Z][a-z]{1,5})\\.$/.test(segment)\n            const nextStartsWithCapital = /^[A-Z]/.test(nextSegment || '')\n            if (endsWithAbbr && nextStartsWithCapital) {\n                const mergedSegment = {\n                    index: current.index,\n                    segment: current.segment + (next?.segment || ''),\n                    isWordLike: true,\n                }\n                mergedSegments.push(mergedSegment)\n                i++\n            } else {\n                mergedSegments.push(current)\n            }\n        }\n        for (const { index, segment, isWordLike } of mergedSegments) {\n            if (granularityIsWord && !isWordLike) continue\n            while (sum <= index) sum += strs[++strIndex].length\n            const startIndex = strIndex\n            const startOffset = index - (sum - strs[strIndex].length)\n            const end = index + segment.length - 1\n            if (end < str.length) while (sum <= end) sum += strs[++strIndex].length\n            const endIndex = strIndex\n            const endOffset = end - (sum - strs[strIndex].length) + 1\n            yield [(name++).toString(),\n                makeRange(startIndex, startOffset, endIndex, endOffset)]\n        }\n    }\n}\n\nconst fragmentToSSML = (fragment, nodeFilter, inherited) => {\n    const ssml = document.implementation.createDocument(NS.SSML, 'speak')\n    const { lang } = inherited\n    if (lang) ssml.documentElement.setAttributeNS(NS.XML, 'lang', lang)\n\n    const convert = (node, parent, inheritedAlphabet) => {\n        if (!node) return\n        if (node.nodeType === 3) return ssml.createTextNode(node.textContent)\n        if (node.nodeType === 4) return ssml.createCDATASection(node.textContent)\n        if (node.nodeType !== 1 && node.nodeType !== 11) return\n        if (nodeFilter && nodeFilter(node) === NodeFilter.FILTER_REJECT) return\n\n        let el\n        const nodeName = node.nodeName.toLowerCase()\n        if (nodeName === 'foliate-mark') {\n            el = ssml.createElementNS(NS.SSML, 'mark')\n            el.setAttribute('name', node.dataset.name)\n        }\n        else if (nodeName === 'br')\n            el = ssml.createElementNS(NS.SSML, 'break')\n        else if (nodeName === 'em' || nodeName === 'strong')\n            el = ssml.createElementNS(NS.SSML, 'emphasis')\n\n        const lang = node.lang || node.getAttributeNS?.(NS.XML, 'lang')\n        if (lang) {\n            if (!el) el = ssml.createElementNS(NS.SSML, 'lang')\n            el.setAttributeNS(NS.XML, 'lang', lang)\n        }\n\n        const alphabet = node.getAttributeNS?.(NS.SSML, 'alphabet') || inheritedAlphabet\n        if (!el) {\n            const ph = node.getAttributeNS?.(NS.SSML, 'ph')\n            if (ph) {\n                el = ssml.createElementNS(NS.SSML, 'phoneme')\n                if (alphabet) el.setAttribute('alphabet', alphabet)\n                el.setAttribute('ph', ph)\n            }\n        }\n\n        if (!el) el = parent\n\n        let child = node.firstChild\n        while (child) {\n            const childEl = convert(child, el, alphabet)\n            if (childEl && el !== childEl) el.append(childEl)\n            child = child.nextSibling\n        }\n        return el\n    }\n    convert(fragment, ssml.documentElement, inherited.alphabet)\n    return ssml\n}\n\nconst getFragmentWithMarks = (range, textWalker, nodeFilter, granularity) => {\n    const lang = getLang(range.commonAncestorContainer)\n    const alphabet = getAlphabet(range.commonAncestorContainer)\n\n    const segmenter = getSegmenter(lang, granularity)\n    const fragment = range.cloneContents()\n\n    // we need ranges on both the original document (for highlighting)\n    // and the document fragment (for inserting marks)\n    // so unfortunately need to do it twice, as you can't copy the ranges\n    const entries = [...textWalker(range, segmenter, nodeFilter)]\n    const fragmentEntries = [...textWalker(fragment, segmenter, nodeFilter)]\n\n    for (const [name, range] of fragmentEntries) {\n        const mark = document.createElement('foliate-mark')\n        mark.dataset.name = name\n        range.insertNode(mark)\n    }\n    const ssml = fragmentToSSML(fragment, nodeFilter, { lang, alphabet })\n    return { entries, ssml }\n}\n\nconst rangeIsEmpty = range => !range.toString().trim()\n\nfunction* getBlocks(doc) {\n    let last\n    const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT)\n    for (let node = walker.nextNode(); node; node = walker.nextNode()) {\n        const name = node.tagName.toLowerCase()\n        if (blockTags.has(name)) {\n            if (last) {\n                last.setEndBefore(node)\n                if (!rangeIsEmpty(last)) yield last\n            }\n            last = doc.createRange()\n            last.setStart(node, 0)\n        }\n    }\n    if (!last) {\n        last = doc.createRange()\n        last.setStart(doc.body.firstChild ?? doc.body, 0)\n    }\n    last.setEndAfter(doc.body.lastChild ?? doc.body)\n    if (!rangeIsEmpty(last)) yield last\n}\n\nclass ListIterator {\n    #arr = []\n    #iter\n    #index = -1\n    #f\n    constructor(iter, f = x => x) {\n        this.#iter = iter\n        this.#f = f\n    }\n    current() {\n        if (this.#arr[this.#index]) return this.#f(this.#arr[this.#index])\n    }\n    first() {\n        const newIndex = 0\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n    }\n    prev() {\n        const newIndex = this.#index - 1\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n    }\n    next() {\n        const newIndex = this.#index + 1\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n        while (true) {\n            const { done, value } = this.#iter.next()\n            if (done) break\n            this.#arr.push(value)\n            if (this.#arr[newIndex]) {\n                this.#index = newIndex\n                return this.#f(this.#arr[newIndex])\n            }\n        }\n    }\n    find(f) {\n        const index = this.#arr.findIndex(x => f(x))\n        if (index > -1) {\n            this.#index = index\n            return this.#f(this.#arr[index])\n        }\n        while (true) {\n            const { done, value } = this.#iter.next()\n            if (done) break\n            this.#arr.push(value)\n            if (f(value)) {\n                this.#index = this.#arr.length - 1\n                return this.#f(value)\n            }\n        }\n    }\n}\n\nexport class TTS {\n    #list\n    #ranges\n    #lastMark\n    #serializer = new XMLSerializer()\n    constructor(doc, textWalker, nodeFilter, highlight, granularity) {\n        this.doc = doc\n        this.highlight = highlight\n        this.#list = new ListIterator(getBlocks(doc), range => {\n            const { entries, ssml } = getFragmentWithMarks(range, textWalker, nodeFilter, granularity)\n            this.#ranges = new Map(entries)\n            return [ssml, range]\n        })\n    }\n    #getMarkElement(doc, mark) {\n        if (!mark) return null\n        return doc.querySelector(`mark[name=\"${CSS.escape(mark)}\"`)\n    }\n    #speak(doc, getNode) {\n        if (!doc) return\n        if (!getNode) return this.#serializer.serializeToString(doc)\n        const ssml = document.implementation.createDocument(NS.SSML, 'speak')\n        ssml.documentElement.replaceWith(ssml.importNode(doc.documentElement, true))\n        let node = getNode(ssml)?.previousSibling\n        while (node) {\n            const next = node.previousSibling ?? node.parentNode?.previousSibling\n            node.parentNode.removeChild(node)\n            node = next\n        }\n        const ssmlStr = this.#serializer.serializeToString(ssml)\n        return ssmlStr\n    }\n    start() {\n        this.#lastMark = null\n        const [doc] = this.#list.first() ?? []\n        if (!doc) return this.next()\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, this.#lastMark))\n    }\n    resume() {\n        const [doc] = this.#list.current() ?? []\n        if (!doc) return this.next()\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, this.#lastMark))\n    }\n    prev(paused) {\n        this.#lastMark = null\n        const [doc, range] = this.#list.prev() ?? []\n        if (paused && range) this.highlight(range.cloneRange())\n        return this.#speak(doc)\n    }\n    next(paused) {\n        this.#lastMark = null\n        const [doc, range] = this.#list.next() ?? []\n        if (paused && range) this.highlight(range.cloneRange())\n        return this.#speak(doc)\n    }\n    prevMark(paused) {\n        const marks = Array.from(this.#ranges.keys())\n        if (marks.length === 0) return\n\n        const currentIndex = this.#lastMark ? marks.indexOf(this.#lastMark) : -1\n        if (currentIndex > 0) {\n            const prevMarkName = marks[currentIndex - 1]\n            const range = this.#ranges.get(prevMarkName)\n            if (range) {\n                this.#lastMark = prevMarkName\n                if (paused) this.highlight(range.cloneRange())\n\n                const [doc] = this.#list.current() ?? []\n                return this.#speak(doc, ssml => this.#getMarkElement(ssml, prevMarkName))\n            }\n        } else {\n            const [doc, range] = this.#list.prev() ?? []\n            if (doc && range) {\n                const prevMarks = Array.from(this.#ranges.keys())\n                if (prevMarks.length > 0) {\n                    const lastMarkName = prevMarks[prevMarks.length - 1]\n                    const lastMarkRange = this.#ranges.get(lastMarkName)\n                    if (lastMarkRange) {\n                        this.#lastMark = lastMarkName\n                        if (paused) this.highlight(lastMarkRange.cloneRange())\n                        return this.#speak(doc, ssml => this.#getMarkElement(ssml, lastMarkName))\n                    }\n                } else {\n                    this.#lastMark = null\n                    if (paused) this.highlight(range.cloneRange())\n                    return this.#speak(doc)\n                }\n            }\n        }\n    }\n    nextMark(paused) {\n        const marks = Array.from(this.#ranges.keys())\n        if (marks.length === 0) return\n\n        const currentIndex = this.#lastMark ? marks.indexOf(this.#lastMark) : -1\n        if (currentIndex >= 0 && currentIndex < marks.length - 1) {\n            const nextMarkName = marks[currentIndex + 1]\n            const range = this.#ranges.get(nextMarkName)\n            if (range) {\n                this.#lastMark = nextMarkName\n                if (paused) this.highlight(range.cloneRange())\n                const [doc] = this.#list.current() ?? []\n                return this.#speak(doc, ssml => this.#getMarkElement(ssml, nextMarkName))\n            }\n        } else {\n            const [doc, range] = this.#list.next() ?? []\n            if (doc && range) {\n                const nextMarks = Array.from(this.#ranges.keys())\n                if (nextMarks.length > 0) {\n                    const firstMarkName = nextMarks[0]\n                    const firstMarkRange = this.#ranges.get(firstMarkName)\n                    if (firstMarkRange) {\n                        this.#lastMark = firstMarkName\n                        if (paused) this.highlight(firstMarkRange.cloneRange())\n                        return this.#speak(doc, ssml => this.#getMarkElement(ssml, firstMarkName))\n                    }\n                } else {\n                    this.#lastMark = null\n                    if (paused) this.highlight(range.cloneRange())\n                    return this.#speak(doc)\n                }\n            }\n        }\n    }\n    from(range) {\n        this.#lastMark = null\n        const [doc] = this.#list.find(range_ =>\n            range.compareBoundaryPoints(Range.END_TO_START, range_) <= 0)\n        let mark\n        for (const [name, range_] of this.#ranges.entries())\n            if (range.compareBoundaryPoints(Range.START_TO_START, range_) <= 0) {\n                mark = name\n                break\n            }\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, mark))\n    }\n    setMark(mark) {\n        const range = this.#ranges.get(mark)\n        if (range) {\n            this.#lastMark = mark\n            this.highlight(range.cloneRange())\n            return range\n        }\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
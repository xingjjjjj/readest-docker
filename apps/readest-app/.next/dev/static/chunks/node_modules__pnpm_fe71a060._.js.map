{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/%40tauri-apps%2Bplugin-fs%402.4.5/node_modules/%40tauri-apps/plugin-fs/dist-js/index.js"],"sourcesContent":["export { BaseDirectory } from '@tauri-apps/api/path';\nimport { Resource, invoke, Channel } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n/**\n * Access the file system.\n *\n * ## Security\n *\n * This module prevents path traversal, not allowing parent directory accessors to be used\n * (i.e. \"/usr/path/to/../file\" or \"../path/to/file\" paths are not allowed).\n * Paths accessed with this API must be either relative to one of the {@link BaseDirectory | base directories}\n * or created with the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/ | path API}.\n *\n * The API has a scope configuration that forces you to restrict the paths that can be accessed using glob patterns.\n *\n * The scope configuration is an array of glob patterns describing file/directory paths that are allowed.\n * For instance, this scope configuration allows **all** enabled `fs` APIs to (only) access files in the\n * *databases* directory of the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | `$APPDATA` directory}:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:scope\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Scopes can also be applied to specific `fs` APIs by using the API's identifier instead of `fs:scope`:\n * ```json\n * {\n *   \"permissions\": [\n *     {\n *       \"identifier\": \"fs:allow-exists\",\n *       \"allow\": [{ \"path\": \"$APPDATA/databases/*\" }]\n *     }\n *   ]\n * }\n * ```\n *\n * Notice the use of the `$APPDATA` variable. The value is injected at runtime, resolving to the {@link https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | app data directory}.\n *\n * The available variables are:\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appconfigdir | $APPCONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appdatadir | $APPDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applocaldatadir | $APPLOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#appcachedir | $APPCACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#applogdir | $APPLOG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#audiodir | $AUDIO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#cachedir | $CACHE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#configdir | $CONFIG},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#datadir | $DATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#localdatadir | $LOCALDATA},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#desktopdir | $DESKTOP},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#documentdir | $DOCUMENT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#downloaddir | $DOWNLOAD},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#executabledir | $EXE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#fontdir | $FONT},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#homedir | $HOME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#picturedir | $PICTURE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#publicdir | $PUBLIC},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#runtimedir | $RUNTIME},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#templatedir | $TEMPLATE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#videodir | $VIDEO},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#resourcedir | $RESOURCE},\n * {@linkcode https://v2.tauri.app/reference/javascript/api/namespacepath/#tempdir | $TEMP}.\n *\n * Trying to execute any API with a URL not configured on the scope results in a promise rejection due to denied access.\n *\n * @module\n */\nvar SeekMode;\n(function (SeekMode) {\n    SeekMode[SeekMode[\"Start\"] = 0] = \"Start\";\n    SeekMode[SeekMode[\"Current\"] = 1] = \"Current\";\n    SeekMode[SeekMode[\"End\"] = 2] = \"End\";\n})(SeekMode || (SeekMode = {}));\nfunction parseFileInfo(r) {\n    return {\n        isFile: r.isFile,\n        isDirectory: r.isDirectory,\n        isSymlink: r.isSymlink,\n        size: r.size,\n        mtime: r.mtime !== null ? new Date(r.mtime) : null,\n        atime: r.atime !== null ? new Date(r.atime) : null,\n        birthtime: r.birthtime !== null ? new Date(r.birthtime) : null,\n        readonly: r.readonly,\n        fileAttributes: r.fileAttributes,\n        dev: r.dev,\n        ino: r.ino,\n        mode: r.mode,\n        nlink: r.nlink,\n        uid: r.uid,\n        gid: r.gid,\n        rdev: r.rdev,\n        blksize: r.blksize,\n        blocks: r.blocks\n    };\n}\n// https://gist.github.com/zapthedingbat/38ebfbedd98396624e5b5f2ff462611d\n/** Converts a big-endian eight byte array to number  */\nfunction fromBytes(buffer) {\n    const bytes = new Uint8ClampedArray(buffer);\n    const size = bytes.byteLength;\n    let x = 0;\n    for (let i = 0; i < size; i++) {\n        // eslint-disable-next-line security/detect-object-injection\n        const byte = bytes[i];\n        x *= 0x100;\n        x += byte;\n    }\n    return x;\n}\n/**\n *  The Tauri abstraction for reading and writing files.\n *\n * @since 2.0.0\n */\nclass FileHandle extends Resource {\n    /**\n     * Reads up to `p.byteLength` bytes into `p`. It resolves to the number of\n     * bytes read (`0` < `n` <= `p.byteLength`) and rejects if any error\n     * encountered. Even if `read()` resolves to `n` < `p.byteLength`, it may\n     * use all of `p` as scratch space during the call. If some data is\n     * available but not `p.byteLength` bytes, `read()` conventionally resolves\n     * to what is available instead of waiting for more.\n     *\n     * When `read()` encounters end-of-file condition, it resolves to EOF\n     * (`null`).\n     *\n     * When `read()` encounters an error, it rejects with an error.\n     *\n     * Callers should always process the `n` > `0` bytes returned before\n     * considering the EOF (`null`). Doing so correctly handles I/O errors that\n     * happen after reading some bytes and also both of the allowed EOF\n     * behaviors.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n     * // if \"$APPCONFIG/foo/bar.txt\" contains the text \"hello world\":\n     * const file = await open(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n     * const buf = new Uint8Array(100);\n     * const numberOfBytesRead = await file.read(buf); // 11 bytes\n     * const text = new TextDecoder().decode(buf);  // \"hello world\"\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async read(buffer) {\n        if (buffer.byteLength === 0) {\n            return 0;\n        }\n        const data = await invoke('plugin:fs|read', {\n            rid: this.rid,\n            len: buffer.byteLength\n        });\n        // Rust side will never return an empty array for this command and\n        // ensure there is at least 8 elements there.\n        //\n        // This is an optimization to include the number of read bytes (as bigendian bytes)\n        // at the end of returned array to avoid serialization overhead of separate values.\n        const nread = fromBytes(data.slice(-8));\n        const bytes = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        buffer.set(bytes.slice(0, bytes.length - 8));\n        return nread === 0 ? null : nread;\n    }\n    /**\n     * Seek sets the offset for the next `read()` or `write()` to offset,\n     * interpreted according to `whence`: `Start` means relative to the\n     * start of the file, `Current` means relative to the current offset,\n     * and `End` means relative to the end. Seek resolves to the new offset\n     * relative to the start of the file.\n     *\n     * Seeking to an offset before the start of the file is an error. Seeking to\n     * any positive offset is legal, but the behavior of subsequent I/O\n     * operations on the underlying object is implementation-dependent.\n     * It returns the number of cursor position.\n     *\n     * @example\n     * ```typescript\n     * import { open, SeekMode, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // Given hello.txt pointing to file with \"Hello world\", which is 11 bytes long:\n     * const file = await open('hello.txt', { read: true, write: true, truncate: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello world\"));\n     *\n     * // Seek 6 bytes from the start of the file\n     * console.log(await file.seek(6, SeekMode.Start)); // \"6\"\n     * // Seek 2 more bytes from the current position\n     * console.log(await file.seek(2, SeekMode.Current)); // \"8\"\n     * // Seek backwards 2 bytes from the end of the file\n     * console.log(await file.seek(-2, SeekMode.End)); // \"9\" (e.g. 11-2)\n     *\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async seek(offset, whence) {\n        return await invoke('plugin:fs|seek', {\n            rid: this.rid,\n            offset,\n            whence\n        });\n    }\n    /**\n     * Returns a {@linkcode FileInfo } for this file.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const file = await open(\"file.txt\", { read: true, baseDir: BaseDirectory.AppLocalData });\n     * const fileInfo = await file.stat();\n     * console.log(fileInfo.isFile); // true\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async stat() {\n        const res = await invoke('plugin:fs|fstat', {\n            rid: this.rid\n        });\n        return parseFileInfo(res);\n    }\n    /**\n     * Truncates or extends this file, to reach the specified `len`.\n     * If `len` is not specified then the entire file contents are truncated.\n     *\n     * @example\n     * ```typescript\n     * import { open, BaseDirectory } from '@tauri-apps/plugin-fs';\n     *\n     * // truncate the entire file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.truncate();\n     *\n     * // truncate part of the file\n     * const file = await open(\"my_file.txt\", { read: true, write: true, create: true, baseDir: BaseDirectory.AppLocalData });\n     * await file.write(new TextEncoder().encode(\"Hello World\"));\n     * await file.truncate(7);\n     * const data = new Uint8Array(32);\n     * await file.read(data);\n     * console.log(new TextDecoder().decode(data)); // Hello W\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async truncate(len) {\n        await invoke('plugin:fs|ftruncate', {\n            rid: this.rid,\n            len\n        });\n    }\n    /**\n     * Writes `data.byteLength` bytes from `data` to the underlying data stream. It\n     * resolves to the number of bytes written from `data` (`0` <= `n` <=\n     * `data.byteLength`) or reject with the error encountered that caused the\n     * write to stop early. `write()` must reject with a non-null error if\n     * would resolve to `n` < `data.byteLength`. `write()` must not modify the\n     * slice data, even temporarily.\n     *\n     * @example\n     * ```typescript\n     * import { open, write, BaseDirectory } from '@tauri-apps/plugin-fs';\n     * const encoder = new TextEncoder();\n     * const data = encoder.encode(\"Hello world\");\n     * const file = await open(\"bar.txt\", { write: true, baseDir: BaseDirectory.AppLocalData });\n     * const bytesWritten = await file.write(data); // 11\n     * await file.close();\n     * ```\n     *\n     * @since 2.0.0\n     */\n    async write(data) {\n        return await invoke('plugin:fs|write', {\n            rid: this.rid,\n            data\n        });\n    }\n}\n/**\n * Creates a file if none exists or truncates an existing file and resolves to\n *  an instance of {@linkcode FileHandle }.\n *\n * @example\n * ```typescript\n * import { create, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await create(\"foo/bar.txt\", { baseDir: BaseDirectory.AppConfig });\n * await file.write(new TextEncoder().encode(\"Hello world\"));\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function create(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|create', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Open a file and resolve to an instance of {@linkcode FileHandle}. The\n * file does not need to previously exist if using the `create` or `createNew`\n * open options. It is the callers responsibility to close the file when finished\n * with it.\n *\n * @example\n * ```typescript\n * import { open, BaseDirectory } from \"@tauri-apps/plugin-fs\"\n * const file = await open(\"foo/bar.txt\", { read: true, write: true, baseDir: BaseDirectory.AppLocalData });\n * // Do work with file\n * await file.close();\n * ```\n *\n * @since 2.0.0\n */\nasync function open(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const rid = await invoke('plugin:fs|open', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return new FileHandle(rid);\n}\n/**\n * Copies the contents and permissions of one file to another specified path, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { copyFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await copyFile('app.conf', 'app.conf.bk', { fromPathBaseDir: BaseDirectory.AppConfig, toPathBaseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function copyFile(fromPath, toPath, options) {\n    if ((fromPath instanceof URL && fromPath.protocol !== 'file:')\n        || (toPath instanceof URL && toPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|copy_file', {\n        fromPath: fromPath instanceof URL ? fromPath.toString() : fromPath,\n        toPath: toPath instanceof URL ? toPath.toString() : toPath,\n        options\n    });\n}\n/**\n * Creates a new directory with the specified path.\n * @example\n * ```typescript\n * import { mkdir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await mkdir('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function mkdir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|mkdir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads the directory given by path and returns an array of `DirEntry`.\n * @example\n * ```typescript\n * import { readDir, BaseDirectory } from '@tauri-apps/plugin-fs';\n * import { join } from '@tauri-apps/api/path';\n * const dir = \"users\"\n * const entries = await readDir('users', { baseDir: BaseDirectory.AppLocalData });\n * processEntriesRecursively(dir, entries);\n * async function processEntriesRecursively(parent, entries) {\n *   for (const entry of entries) {\n *     console.log(`Entry: ${entry.name}`);\n *     if (entry.isDirectory) {\n *        const dir = await join(parent, entry.name);\n *       processEntriesRecursively(dir, await readDir(dir, { baseDir: BaseDirectory.AppLocalData }))\n *     }\n *   }\n * }\n * ```\n *\n * @since 2.0.0\n */\nasync function readDir(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|read_dir', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Reads and resolves to the entire contents of a file as an array of bytes.\n * TextDecoder can be used to transform the bytes to string if required.\n * @example\n * ```typescript\n * import { readFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readFile('avatar.png', { baseDir: BaseDirectory.Resource });\n * ```\n *\n * @since 2.0.0\n */\nasync function readFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n}\n/**\n * Reads and returns the entire contents of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const contents = await readTextFile('app.conf', { baseDir: BaseDirectory.AppConfig });\n * ```\n *\n * @since 2.0.0\n */\nasync function readTextFile(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const arr = await invoke('plugin:fs|read_text_file', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    const bytes = arr instanceof ArrayBuffer ? arr : Uint8Array.from(arr);\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Returns an async {@linkcode AsyncIterableIterator} over the lines of a file as UTF-8 string.\n * @example\n * ```typescript\n * import { readTextFileLines, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const lines = await readTextFileLines('app.conf', { baseDir: BaseDirectory.AppConfig });\n * for await (const line of lines) {\n *   console.log(line);\n * }\n * ```\n * You could also call {@linkcode AsyncIterableIterator.next} to advance the\n * iterator so you can lazily read the next line whenever you want.\n *\n * @since 2.0.0\n */\nasync function readTextFileLines(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const pathStr = path instanceof URL ? path.toString() : path;\n    return await Promise.resolve({\n        path: pathStr,\n        rid: null,\n        async next() {\n            if (this.rid === null) {\n                this.rid = await invoke('plugin:fs|read_text_file_lines', {\n                    path: pathStr,\n                    options\n                });\n            }\n            const arr = await invoke('plugin:fs|read_text_file_lines_next', { rid: this.rid });\n            const bytes = arr instanceof ArrayBuffer ? new Uint8Array(arr) : Uint8Array.from(arr);\n            // Rust side will never return an empty array for this command and\n            // ensure there is at least one elements there.\n            //\n            // This is an optimization to include whether we finished iteration or not (1 or 0)\n            // at the end of returned array to avoid serialization overhead of separate values.\n            const done = bytes[bytes.byteLength - 1] === 1;\n            if (done) {\n                // a full iteration is over, reset rid for next iteration\n                this.rid = null;\n                return { value: null, done };\n            }\n            const line = new TextDecoder().decode(bytes.slice(0, bytes.byteLength - 1));\n            return {\n                value: line,\n                done\n            };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        }\n    });\n}\n/**\n * Removes the named file or directory.\n * If the directory is not empty and the `recursive` option isn't set to true, the promise will be rejected.\n * @example\n * ```typescript\n * import { remove, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await remove('users/file.txt', { baseDir: BaseDirectory.AppLocalData });\n * await remove('users', { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function remove(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|remove', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\n/**\n * Renames (moves) oldpath to newpath. Paths may be files or directories.\n * If newpath already exists and is not a directory, rename() replaces it.\n * OS-specific restrictions may apply when oldpath and newpath are in different directories.\n *\n * On Unix, this operation does not follow symlinks at either path.\n *\n * @example\n * ```typescript\n * import { rename, BaseDirectory } from '@tauri-apps/plugin-fs';\n * await rename('avatar.png', 'deleted.png', { oldPathBaseDir: BaseDirectory.App, newPathBaseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function rename(oldPath, newPath, options) {\n    if ((oldPath instanceof URL && oldPath.protocol !== 'file:')\n        || (newPath instanceof URL && newPath.protocol !== 'file:')) {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|rename', {\n        oldPath: oldPath instanceof URL ? oldPath.toString() : oldPath,\n        newPath: newPath instanceof URL ? newPath.toString() : newPath,\n        options\n    });\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. Will always\n * follow symlinks but will reject if the symlink points to a path outside of the scope.\n *\n * @example\n * ```typescript\n * import { stat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await stat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function stat(path, options) {\n    const res = await invoke('plugin:fs|stat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Resolves to a {@linkcode FileInfo} for the specified `path`. If `path` is a\n * symlink, information for the symlink will be returned instead of what it\n * points to.\n *\n * @example\n * ```typescript\n * import { lstat, BaseDirectory } from '@tauri-apps/plugin-fs';\n * const fileInfo = await lstat(\"hello.txt\", { baseDir: BaseDirectory.AppLocalData });\n * console.log(fileInfo.isFile); // true\n * ```\n *\n * @since 2.0.0\n */\nasync function lstat(path, options) {\n    const res = await invoke('plugin:fs|lstat', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n    return parseFileInfo(res);\n}\n/**\n * Truncates or extends the specified file, to reach the specified `len`.\n * If `len` is `0` or not specified, then the entire file contents are truncated.\n *\n * @example\n * ```typescript\n * import { truncate, readTextFile, writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // truncate the entire file\n * await truncate(\"my_file.txt\", 0, { baseDir: BaseDirectory.AppLocalData });\n *\n * // truncate part of the file\n * const filePath = \"file.txt\";\n * await writeTextFile(filePath, \"Hello World\", { baseDir: BaseDirectory.AppLocalData });\n * await truncate(filePath, 7, { baseDir: BaseDirectory.AppLocalData });\n * const data = await readTextFile(filePath, { baseDir: BaseDirectory.AppLocalData });\n * console.log(data);  // \"Hello W\"\n * ```\n *\n * @since 2.0.0\n */\nasync function truncate(path, len, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    await invoke('plugin:fs|truncate', {\n        path: path instanceof URL ? path.toString() : path,\n        len,\n        options\n    });\n}\n/**\n * Write `data` to the given `path`, by default creating a new file if needed, else overwriting.\n * @example\n * ```typescript\n * import { writeFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n *\n * let encoder = new TextEncoder();\n * let data = encoder.encode(\"Hello World\");\n * await writeFile('file.txt', data, { baseDir: BaseDirectory.AppLocalData });\n * ```\n *\n * @since 2.0.0\n */\nasync function writeFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    if (data instanceof ReadableStream) {\n        const file = await open(path, {\n            read: false,\n            create: true,\n            write: true,\n            ...options\n        });\n        const reader = data.getReader();\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                await file.write(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n            await file.close();\n        }\n    }\n    else {\n        await invoke('plugin:fs|write_file', data, {\n            headers: {\n                path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n                options: JSON.stringify(options)\n            }\n        });\n    }\n}\n/**\n  * Writes UTF-8 string `data` to the given `path`, by default creating a new file if needed, else overwriting.\n    @example\n  * ```typescript\n  * import { writeTextFile, BaseDirectory } from '@tauri-apps/plugin-fs';\n  *\n  * await writeTextFile('file.txt', \"Hello world\", { baseDir: BaseDirectory.AppLocalData });\n  * ```\n  *\n  * @since 2.0.0\n  */\nasync function writeTextFile(path, data, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    const encoder = new TextEncoder();\n    await invoke('plugin:fs|write_text_file', encoder.encode(data), {\n        headers: {\n            path: encodeURIComponent(path instanceof URL ? path.toString() : path),\n            options: JSON.stringify(options)\n        }\n    });\n}\n/**\n * Check if a path exists.\n * @example\n * ```typescript\n * import { exists, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Check if the `$APPDATA/avatar.png` file exists\n * await exists('avatar.png', { baseDir: BaseDirectory.AppData });\n * ```\n *\n * @since 2.0.0\n */\nasync function exists(path, options) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|exists', {\n        path: path instanceof URL ? path.toString() : path,\n        options\n    });\n}\nclass Watcher extends Resource {\n}\nasync function watchInternal(paths, cb, options) {\n    const watchPaths = Array.isArray(paths) ? paths : [paths];\n    for (const path of watchPaths) {\n        if (path instanceof URL && path.protocol !== 'file:') {\n            throw new TypeError('Must be a file URL.');\n        }\n    }\n    const onEvent = new Channel();\n    onEvent.onmessage = cb;\n    const rid = await invoke('plugin:fs|watch', {\n        paths: watchPaths.map((p) => (p instanceof URL ? p.toString() : p)),\n        options,\n        onEvent\n    });\n    const watcher = new Watcher(rid);\n    return () => {\n        void watcher.close();\n    };\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes (after a delay) on files or directories.\n *\n * @since 2.0.0\n */\nasync function watch(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        delayMs: 2000,\n        ...options\n    });\n}\n// TODO: Return `Watcher` instead in v3\n/**\n * Watch changes on files or directories.\n *\n * @since 2.0.0\n */\nasync function watchImmediate(paths, cb, options) {\n    return await watchInternal(paths, cb, {\n        ...options,\n        delayMs: undefined\n    });\n}\n/**\n * Get the size of a file or directory. For files, the `stat` functions can be used as well.\n *\n * If `path` is a directory, this function will recursively iterate over every file and every directory inside of `path` and therefore will be very time consuming if used on larger directories.\n *\n * @example\n * ```typescript\n * import { size, BaseDirectory } from '@tauri-apps/plugin-fs';\n * // Get the size of the `$APPDATA/tauri` directory.\n * const dirSize = await size('tauri', { baseDir: BaseDirectory.AppData });\n * console.log(dirSize); // 1024\n * ```\n *\n * @since 2.1.0\n */\nasync function size(path) {\n    if (path instanceof URL && path.protocol !== 'file:') {\n        throw new TypeError('Must be a file URL.');\n    }\n    return await invoke('plugin:fs|size', {\n        path: path instanceof URL ? path.toString() : path\n    });\n}\n\nexport { FileHandle, SeekMode, copyFile, create, exists, lstat, mkdir, open, readDir, readFile, readTextFile, readTextFileLines, remove, rename, size, stat, truncate, watch, watchImmediate, writeFile, writeTextFile };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/native.js"],"sourcesContent":["const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n"],"names":[],"mappings":";;;;AAAA,MAAM,aAAa,OAAO,WAAW,eAAe,OAAO,UAAU,IAAI,OAAO,UAAU,CAAC,IAAI,CAAC;uCACjF;IAAE;AAAW","ignoreList":[0]}},
    {"offset": {"line": 822, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/rng.js"],"sourcesContent":["let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n"],"names":[],"mappings":";;;;AAAA,IAAI;AACJ,MAAM,QAAQ,IAAI,WAAW;AACd,SAAS;IACpB,IAAI,CAAC,iBAAiB;QAClB,IAAI,OAAO,WAAW,eAAe,CAAC,OAAO,eAAe,EAAE;YAC1D,MAAM,IAAI,MAAM;QACpB;QACA,kBAAkB,OAAO,eAAe,CAAC,IAAI,CAAC;IAClD;IACA,OAAO,gBAAgB;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 841, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/regex.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n"],"names":[],"mappings":";;;;uCAAe","ignoreList":[0]}},
    {"offset": {"line": 850, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/validate.js"],"sourcesContent":["import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,SAAS,IAAI;IAClB,OAAO,OAAO,SAAS,YAAY,gNAAK,CAAC,IAAI,CAAC;AAClD;uCACe","ignoreList":[0]}},
    {"offset": {"line": 864, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/stringify.js"],"sourcesContent":["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n"],"names":[],"mappings":";;;;;;AAAA;;AACA,MAAM,YAAY,EAAE;AACpB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;IAC1B,UAAU,IAAI,CAAC,CAAC,IAAI,KAAK,EAAE,QAAQ,CAAC,IAAI,KAAK,CAAC;AAClD;AACO,SAAS,gBAAgB,GAAG,EAAE,SAAS,CAAC;IAC3C,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC9B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,MACA,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,MACA,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,MACA,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,GAC1B,MACA,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,GAC3B,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,GAC3B,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,GAC3B,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,GAC3B,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,GAC3B,SAAS,CAAC,GAAG,CAAC,SAAS,GAAG,CAAC,EAAE,WAAW;AAChD;AACA,SAAS,UAAU,GAAG,EAAE,SAAS,CAAC;IAC9B,MAAM,OAAO,gBAAgB,KAAK;IAClC,IAAI,CAAC,IAAA,mNAAQ,EAAC,OAAO;QACjB,MAAM,UAAU;IACpB;IACA,OAAO;AACX;uCACe","ignoreList":[0]}},
    {"offset": {"line": 891, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/node_modules/.pnpm/uuid%4011.1.0/node_modules/uuid/dist/esm-browser/v4.js"],"sourcesContent":["import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,SAAS,GAAG,OAAO,EAAE,GAAG,EAAE,MAAM;IAC5B,IAAI,iNAAM,CAAC,UAAU,IAAI,CAAC,OAAO,CAAC,SAAS;QACvC,OAAO,iNAAM,CAAC,UAAU;IAC5B;IACA,UAAU,WAAW,CAAC;IACtB,MAAM,OAAO,QAAQ,MAAM,IAAI,QAAQ,GAAG,QAAQ,IAAA,8MAAG;IACrD,IAAI,KAAK,MAAM,GAAG,IAAI;QAClB,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,EAAE,GAAG,AAAC,IAAI,CAAC,EAAE,GAAG,OAAQ;IAC7B,IAAI,CAAC,EAAE,GAAG,AAAC,IAAI,CAAC,EAAE,GAAG,OAAQ;IAC7B,IAAI,KAAK;QACL,SAAS,UAAU;QACnB,IAAI,SAAS,KAAK,SAAS,KAAK,IAAI,MAAM,EAAE;YACxC,MAAM,IAAI,WAAW,CAAC,gBAAgB,EAAE,OAAO,CAAC,EAAE,SAAS,GAAG,wBAAwB,CAAC;QAC3F;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,EAAE,EAAG;YACzB,GAAG,CAAC,SAAS,EAAE,GAAG,IAAI,CAAC,EAAE;QAC7B;QACA,OAAO;IACX;IACA,OAAO,IAAA,4NAAe,EAAC;AAC3B;uCACe","ignoreList":[0]}}]
}
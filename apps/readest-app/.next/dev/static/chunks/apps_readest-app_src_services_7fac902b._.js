(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/apps/readest-app/src/services/constants.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ANDROID_FONTS",
    ()=>ANDROID_FONTS,
    "BOOK_ACCEPT_FORMATS",
    ()=>BOOK_ACCEPT_FORMATS,
    "BOOK_IDS_SEPARATOR",
    ()=>BOOK_IDS_SEPARATOR,
    "BOOK_UNGROUPED_ID",
    ()=>BOOK_UNGROUPED_ID,
    "BOOK_UNGROUPED_NAME",
    ()=>BOOK_UNGROUPED_NAME,
    "CHECK_UPDATE_INTERVAL_SEC",
    ()=>CHECK_UPDATE_INTERVAL_SEC,
    "CJK_EXCLUDE_PATTENS",
    ()=>CJK_EXCLUDE_PATTENS,
    "CJK_FONTS_PATTENS",
    ()=>CJK_FONTS_PATTENS,
    "CJK_SANS_SERIF_FONTS",
    ()=>CJK_SANS_SERIF_FONTS,
    "CJK_SERIF_FONTS",
    ()=>CJK_SERIF_FONTS,
    "CUSTOM_THEME_TEMPLATES",
    ()=>CUSTOM_THEME_TEMPLATES,
    "DATA_SUBDIR",
    ()=>DATA_SUBDIR,
    "DEFAULT_ANNOTATOR_CONFIG",
    ()=>DEFAULT_ANNOTATOR_CONFIG,
    "DEFAULT_BOOK_FONT",
    ()=>DEFAULT_BOOK_FONT,
    "DEFAULT_BOOK_LANGUAGE",
    ()=>DEFAULT_BOOK_LANGUAGE,
    "DEFAULT_BOOK_LAYOUT",
    ()=>DEFAULT_BOOK_LAYOUT,
    "DEFAULT_BOOK_SEARCH_CONFIG",
    ()=>DEFAULT_BOOK_SEARCH_CONFIG,
    "DEFAULT_BOOK_STYLE",
    ()=>DEFAULT_BOOK_STYLE,
    "DEFAULT_CJK_VIEW_SETTINGS",
    ()=>DEFAULT_CJK_VIEW_SETTINGS,
    "DEFAULT_DAILY_TRANSLATION_QUOTA",
    ()=>DEFAULT_DAILY_TRANSLATION_QUOTA,
    "DEFAULT_EINK_VIEW_SETTINGS",
    ()=>DEFAULT_EINK_VIEW_SETTINGS,
    "DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS",
    ()=>DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS,
    "DEFAULT_KOSYNC_SETTINGS",
    ()=>DEFAULT_KOSYNC_SETTINGS,
    "DEFAULT_MOBILE_READSETTINGS",
    ()=>DEFAULT_MOBILE_READSETTINGS,
    "DEFAULT_MOBILE_SYSTEM_SETTINGS",
    ()=>DEFAULT_MOBILE_SYSTEM_SETTINGS,
    "DEFAULT_MOBILE_VIEW_SETTINGS",
    ()=>DEFAULT_MOBILE_VIEW_SETTINGS,
    "DEFAULT_NOTE_EXPORT_CONFIG",
    ()=>DEFAULT_NOTE_EXPORT_CONFIG,
    "DEFAULT_READSETTINGS",
    ()=>DEFAULT_READSETTINGS,
    "DEFAULT_SCREEN_CONFIG",
    ()=>DEFAULT_SCREEN_CONFIG,
    "DEFAULT_STORAGE_QUOTA",
    ()=>DEFAULT_STORAGE_QUOTA,
    "DEFAULT_SYSTEM_SETTINGS",
    ()=>DEFAULT_SYSTEM_SETTINGS,
    "DEFAULT_TRANSLATOR_CONFIG",
    ()=>DEFAULT_TRANSLATOR_CONFIG,
    "DEFAULT_TTS_CONFIG",
    ()=>DEFAULT_TTS_CONFIG,
    "DEFAULT_VIEW_CONFIG",
    ()=>DEFAULT_VIEW_CONFIG,
    "DISABLE_DOUBLE_CLICK_ON_MOBILE",
    ()=>DISABLE_DOUBLE_CLICK_ON_MOBILE,
    "DOUBLE_CLICK_INTERVAL_THRESHOLD_MS",
    ()=>DOUBLE_CLICK_INTERVAL_THRESHOLD_MS,
    "DOWNLOAD_READEST_URL",
    ()=>DOWNLOAD_READEST_URL,
    "FALLBACK_FONTS",
    ()=>FALLBACK_FONTS,
    "HIGHLIGHT_COLOR_HEX",
    ()=>HIGHLIGHT_COLOR_HEX,
    "IMAGE_ACCEPT_FORMATS",
    ()=>IMAGE_ACCEPT_FORMATS,
    "IOS_FONTS",
    ()=>IOS_FONTS,
    "LINUX_FONTS",
    ()=>LINUX_FONTS,
    "LOCAL_BOOKS_SUBDIR",
    ()=>LOCAL_BOOKS_SUBDIR,
    "LOCAL_FONTS_SUBDIR",
    ()=>LOCAL_FONTS_SUBDIR,
    "LOCAL_IMAGES_SUBDIR",
    ()=>LOCAL_IMAGES_SUBDIR,
    "LONG_HOLD_THRESHOLD",
    ()=>LONG_HOLD_THRESHOLD,
    "MACOS_FONTS",
    ()=>MACOS_FONTS,
    "MAX_ZOOM_LEVEL",
    ()=>MAX_ZOOM_LEVEL,
    "MIGHT_BE_RTL_LANGS",
    ()=>MIGHT_BE_RTL_LANGS,
    "MIN_ZOOM_LEVEL",
    ()=>MIN_ZOOM_LEVEL,
    "MONOSPACE_FONTS",
    ()=>MONOSPACE_FONTS,
    "NON_FREE_FONTS",
    ()=>NON_FREE_FONTS,
    "READEST_CHANGELOG_FILE",
    ()=>READEST_CHANGELOG_FILE,
    "READEST_NODE_BASE_URL",
    ()=>READEST_NODE_BASE_URL,
    "READEST_OPDS_USER_AGENT",
    ()=>READEST_OPDS_USER_AGENT,
    "READEST_PUBLIC_STORAGE_BASE_URL",
    ()=>READEST_PUBLIC_STORAGE_BASE_URL,
    "READEST_UPDATER_FILE",
    ()=>READEST_UPDATER_FILE,
    "READEST_WEB_BASE_URL",
    ()=>READEST_WEB_BASE_URL,
    "SANS_SERIF_FONTS",
    ()=>SANS_SERIF_FONTS,
    "SERIF_FONTS",
    ()=>SERIF_FONTS,
    "SETTINGS_FILENAME",
    ()=>SETTINGS_FILENAME,
    "SUPPORTED_BOOK_EXTS",
    ()=>SUPPORTED_BOOK_EXTS,
    "SUPPORTED_IMAGE_EXTS",
    ()=>SUPPORTED_IMAGE_EXTS,
    "SUPPORTED_LANGNAMES",
    ()=>SUPPORTED_LANGNAMES,
    "SUPPORTED_LANGS",
    ()=>SUPPORTED_LANGS,
    "SYNC_BOOKS_INTERVAL_SEC",
    ()=>SYNC_BOOKS_INTERVAL_SEC,
    "SYNC_NOTES_INTERVAL_SEC",
    ()=>SYNC_NOTES_INTERVAL_SEC,
    "SYNC_PROGRESS_INTERVAL_SEC",
    ()=>SYNC_PROGRESS_INTERVAL_SEC,
    "SYSTEM_SETTINGS_VERSION",
    ()=>SYSTEM_SETTINGS_VERSION,
    "TRANSLATED_LANGS",
    ()=>TRANSLATED_LANGS,
    "TRANSLATOR_LANGS",
    ()=>TRANSLATOR_LANGS,
    "WINDOWS_FONTS",
    ()=>WINDOWS_FONTS,
    "ZOOM_STEP",
    ()=>ZOOM_STEP
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$10_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$config$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/config.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
;
;
const DATA_SUBDIR = 'Readest';
const LOCAL_BOOKS_SUBDIR = `${DATA_SUBDIR}/Books`;
const LOCAL_FONTS_SUBDIR = `${DATA_SUBDIR}/Fonts`;
const LOCAL_IMAGES_SUBDIR = `${DATA_SUBDIR}/Images`;
const SETTINGS_FILENAME = 'settings.json';
const SUPPORTED_BOOK_EXTS = [
    'epub',
    'mobi',
    'azw',
    'azw3',
    'fb2',
    'zip',
    'cbz',
    'pdf',
    'txt'
];
const BOOK_ACCEPT_FORMATS = SUPPORTED_BOOK_EXTS.map((ext)=>`.${ext}`).join(', ');
const BOOK_UNGROUPED_NAME = '';
const BOOK_UNGROUPED_ID = '';
const SUPPORTED_IMAGE_EXTS = [
    'png',
    'jpg',
    'jpeg'
];
const IMAGE_ACCEPT_FORMATS = SUPPORTED_IMAGE_EXTS.map((ext)=>`.${ext}`).join(', ');
const DEFAULT_KOSYNC_SETTINGS = {
    serverUrl: 'https://sync.koreader.rocks/',
    username: '',
    userkey: '',
    deviceId: '',
    deviceName: '',
    checksumMethod: 'binary',
    strategy: 'prompt',
    enabled: false
};
const DEFAULT_SYSTEM_SETTINGS = {
    keepLogin: false,
    autoUpload: true,
    alwaysOnTop: false,
    openBookInNewWindow: true,
    alwaysShowStatusBar: false,
    alwaysInForeground: false,
    autoCheckUpdates: true,
    screenWakeLock: false,
    screenBrightness: -1,
    autoScreenBrightness: true,
    openLastBooks: false,
    lastOpenBooks: [],
    autoImportBooksOnOpen: false,
    telemetryEnabled: true,
    discordRichPresenceEnabled: false,
    libraryViewMode: 'grid',
    librarySortBy: 'updated',
    librarySortAscending: false,
    libraryCoverFit: 'crop',
    libraryAutoColumns: true,
    libraryColumns: 6,
    kosync: DEFAULT_KOSYNC_SETTINGS,
    lastSyncedAtBooks: 0,
    lastSyncedAtConfigs: 0,
    lastSyncedAtNotes: 0
};
const DEFAULT_MOBILE_SYSTEM_SETTINGS = {
    libraryColumns: 3
};
const HIGHLIGHT_COLOR_HEX = {
    red: '#f87171',
    yellow: '#facc15',
    green: '#4ade80',
    blue: '#60a5fa',
    violet: '#a78bfa'
};
const DEFAULT_READSETTINGS = {
    sideBarWidth: '15%',
    isSideBarPinned: true,
    notebookWidth: '25%',
    isNotebookPinned: false,
    autohideCursor: true,
    translationProvider: 'deepl',
    translateTargetLang: 'EN',
    customThemes: [],
    highlightStyle: 'highlight',
    highlightStyles: {
        highlight: 'yellow',
        underline: 'green',
        squiggly: 'blue'
    },
    customHighlightColors: HIGHLIGHT_COLOR_HEX,
    customTtsHighlightColors: []
};
const DEFAULT_MOBILE_READSETTINGS = {
    sideBarWidth: '25%',
    isSideBarPinned: false
};
const DEFAULT_BOOK_FONT = {
    serifFont: 'Bitter',
    sansSerifFont: 'Roboto',
    monospaceFont: 'Consolas',
    defaultFont: 'Serif',
    defaultCJKFont: 'LXGW WenKai GB Screen',
    defaultFontSize: 16,
    minimumFontSize: 8,
    fontWeight: 400
};
const DEFAULT_BOOK_LAYOUT = {
    marginTopPx: 44,
    marginBottomPx: 44,
    marginLeftPx: 16,
    marginRightPx: 16,
    compactMarginTopPx: 16,
    compactMarginBottomPx: 16,
    compactMarginLeftPx: 16,
    compactMarginRightPx: 16,
    gapPercent: 5,
    scrolled: false,
    disableClick: false,
    fullscreenClickArea: false,
    swapClickArea: false,
    disableDoubleClick: false,
    volumeKeysToFlip: false,
    continuousScroll: false,
    maxColumnCount: 2,
    maxInlineSize: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$config$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getDefaultMaxInlineSize"])(),
    maxBlockSize: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$config$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getDefaultMaxBlockSize"])(),
    animated: false,
    isEink: false,
    writingMode: 'auto',
    vertical: false,
    rtl: false,
    scrollingOverlap: 0,
    allowScript: false
};
const DEFAULT_BOOK_LANGUAGE = {
    replaceQuotationMarks: true,
    convertChineseVariant: 'none'
};
const DEFAULT_BOOK_STYLE = {
    zoomLevel: 100,
    paragraphMargin: 0.6,
    lineHeight: 1.4,
    wordSpacing: 0,
    letterSpacing: 0,
    textIndent: 0,
    fullJustification: true,
    hyphenation: true,
    invertImgColorInDark: false,
    theme: 'light',
    overrideFont: false,
    overrideLayout: false,
    overrideColor: false,
    backgroundTextureId: 'none',
    backgroundOpacity: 0.6,
    backgroundSize: 'cover',
    codeHighlighting: false,
    codeLanguage: 'auto-detect',
    userStylesheet: '',
    userUIStylesheet: '',
    zoomMode: 'fit-page',
    spreadMode: 'auto',
    keepCoverSpread: true
};
const DEFAULT_MOBILE_VIEW_SETTINGS = {
    fullJustification: false,
    animated: true,
    defaultFont: 'Sans-serif',
    marginBottomPx: 16,
    disableDoubleClick: true,
    spreadMode: 'none'
};
const DEFAULT_CJK_VIEW_SETTINGS = {
    fullJustification: true,
    textIndent: 2,
    paragraphMargin: 1,
    lineHeight: 1.6
};
const DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS = {
    overrideColor: false
};
const DEFAULT_EINK_VIEW_SETTINGS = {
    isEink: true,
    animated: false,
    volumeKeysToFlip: true
};
const DEFAULT_VIEW_CONFIG = {
    sideBarTab: 'toc',
    uiLanguage: '',
    sortedTOC: false,
    doubleBorder: false,
    borderColor: 'red',
    showHeader: true,
    showFooter: true,
    showBarsOnScroll: false,
    showRemainingTime: false,
    showRemainingPages: false,
    showProgressInfo: true,
    tapToToggleFooter: false,
    showMarginsOnScroll: false,
    progressStyle: 'fraction',
    progressInfoMode: 'all'
};
const DEFAULT_TTS_CONFIG = {
    ttsRate: 1.3,
    ttsVoice: '',
    ttsLocation: '',
    showTTSBar: false,
    ttsHighlightOptions: {
        style: 'highlight',
        color: '#808080'
    }
};
const DEFAULT_TRANSLATOR_CONFIG = {
    translationEnabled: false,
    translationProvider: 'deepl',
    translateTargetLang: '',
    showTranslateSource: true,
    ttsReadAloudText: 'both'
};
const DEFAULT_NOTE_EXPORT_CONFIG = {
    includeTitle: true,
    includeAuthor: true,
    includeDate: true,
    includeChapterTitles: true,
    includeQuotes: true,
    includeNotes: true,
    includeTimestamp: false,
    includeChapterSeparator: false,
    noteSeparator: '\n\n',
    useCustomTemplate: false,
    customTemplate: ''
};
const DEFAULT_ANNOTATOR_CONFIG = {
    enableAnnotationQuickActions: true,
    annotationQuickAction: null,
    copyToNotebook: false,
    noteExportConfig: DEFAULT_NOTE_EXPORT_CONFIG
};
const DEFAULT_SCREEN_CONFIG = {
    screenOrientation: 'auto'
};
const DEFAULT_BOOK_SEARCH_CONFIG = {
    scope: 'book',
    matchCase: false,
    matchWholeWords: false,
    matchDiacritics: false
};
const SYSTEM_SETTINGS_VERSION = 1;
const SERIF_FONTS = [
    'Bitter',
    'Literata',
    'Merriweather',
    'Roboto Slab',
    'Vollkorn',
    'PT Serif',
    'Georgia',
    'Times New Roman'
];
const NON_FREE_FONTS = [
    'Georgia',
    'Times New Roman'
];
const CJK_SERIF_FONTS = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('LXGW WenKai GB Screen'),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('LXGW WenKai TC'),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('GuanKiapTsingKhai-T'),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Source Han Serif CN VF'),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Huiwen-mincho'),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('KingHwa_OldSong')
];
const CJK_SANS_SERIF_FONTS = [
    'Noto Sans SC',
    'Noto Sans TC'
];
const SANS_SERIF_FONTS = [
    'Roboto',
    'Noto Sans',
    'Open Sans',
    'PT Sans',
    'Helvetica'
];
const MONOSPACE_FONTS = [
    'Fira Code',
    'Consolas',
    'Courier New',
    'Lucida Console',
    'PT Mono'
];
const FALLBACK_FONTS = [
    'MiSans L3'
];
const WINDOWS_FONTS = [
    'Arial',
    'Arial Black',
    'Bahnschrift',
    'Calibri',
    'Cambria',
    'Cambria Math',
    'Candara',
    'Comic Sans MS',
    'Consolas',
    'Constantia',
    'Corbel',
    'Courier New',
    'Ebrima',
    'FangSong',
    'Franklin Gothic Medium',
    'Gabriola',
    'Gadugi',
    'Georgia',
    'Heiti',
    'HoloLens MDL2 Assets',
    'Impact',
    'Ink Free',
    'Javanese Text',
    'KaiTi',
    'Leelawadee UI',
    'Lucida Console',
    'Lucida Sans Unicode',
    'LXGW WenKai GB Screen',
    'LXGW WenKai TC',
    'Malgun Gothic',
    'Marlett',
    'Microsoft Himalaya',
    'Microsoft JhengHei',
    'Microsoft New Tai Lue',
    'Microsoft PhagsPa',
    'Microsoft Sans Serif',
    'Microsoft Tai Le',
    'Microsoft YaHei',
    'Microsoft Yi Baiti',
    'MingLiU',
    'MingLiU-ExtB',
    'Mongolian Baiti',
    'MS Gothic',
    'MS Mincho',
    'MV Boli',
    'Myanmar Text',
    'Nirmala UI',
    'Noto Serif JP',
    'NSimSun',
    'Palatino Linotype',
    'PMingLiU',
    'Segoe MDL2 Assets',
    'Segoe Print',
    'Segoe Script',
    'Segoe UI',
    'Segoe UI Historic',
    'Segoe UI Emoji',
    'Segoe UI Symbol',
    'SimHei',
    'SimSun',
    'SimSun-ExtB',
    'Sitka',
    'Sylfaen',
    'Tahoma',
    'Times New Roman',
    'Trebuchet MS',
    'Verdana',
    'XiHeiti',
    'Yu Gothic',
    'Yu Mincho'
];
const MACOS_FONTS = [
    'American Typewriter',
    'Andale Mono',
    'Arial',
    'Arial Black',
    'Arial Narrow',
    'Arial Rounded MT Bold',
    'Arial Unicode MS',
    'Avenir',
    'Avenir Next',
    'Avenir Next Condensed',
    'Baskerville',
    'BiauKai',
    'Big Caslon',
    'Bodoni 72',
    'Bodoni 72 Oldstyle',
    'Bodoni 72 Smallcaps',
    'Bradley Hand',
    'Brush Script MT',
    'Chalkboard',
    'Chalkboard SE',
    'Chalkduster',
    'Charter',
    'Cochin',
    'Comic Sans MS',
    'Copperplate',
    'Courier',
    'Courier New',
    'Didot',
    'DIN Alternate',
    'DIN Condensed',
    'FangSong',
    'Futura',
    'Geneva',
    'Georgia',
    'Gill Sans',
    'Heiti SC',
    'Heiti TC',
    'Helvetica',
    'Helvetica Neue',
    'Herculanum',
    'Hiragino Sans',
    'Hiragino Mincho',
    'Hoefler Text',
    'Impact',
    'Kaiti SC',
    'Kaiti TC',
    'Kozuka Gothic Pro',
    'Kozuka Mincho Pro',
    'Lucida Grande',
    'Luminari',
    'LXGW WenKai GB Screen',
    'LXGW WenKai TC',
    'Marker Felt',
    'Menlo',
    'Microsoft Sans Serif',
    'Monaco',
    'Noteworthy',
    'Noto Serif JP',
    'Optima',
    'Palatino',
    'Papyrus',
    'PingFang HK',
    'PingFang SC',
    'PingFang TC',
    'Phosphate',
    'Rockwell',
    'Savoye LET',
    'SignPainter',
    'Skia',
    'Snell Roundhand',
    'Songti SC',
    'Songti TC',
    'STFangsong',
    'STKaiti',
    'STSong',
    'STXihei',
    'Tahoma',
    'Times',
    'Times New Roman',
    'Trattatello',
    'Trebuchet MS',
    'Verdana',
    'XiHeiti',
    'Yu Mincho',
    'Zapfino'
];
const LINUX_FONTS = [
    'Arial',
    'Cantarell',
    'Comic Sans MS',
    'Courier New',
    'DejaVu Sans',
    'DejaVu Sans Mono',
    'DejaVu Serif',
    'Droid Sans',
    'Droid Sans Mono',
    'FangSong',
    'FreeMono',
    'FreeSans',
    'FreeSerif',
    'Georgia',
    'Heiti',
    'Impact',
    'Kaiti',
    'Liberation Mono',
    'Liberation Sans',
    'Liberation Serif',
    'LXGW WenKai GB Screen',
    'LXGW WenKai TC',
    'Noto Mono',
    'Noto Sans',
    'Noto Sans JP',
    'Noto Sans CJK SC',
    'Noto Sans CJK TC',
    'Noto Serif',
    'Noto Serif JP',
    'Noto Serif CJK SC',
    'Noto Serif CJK TC',
    'Open Sans',
    'Poppins',
    'Sazanami Gothic',
    'Sazanami Mincho',
    'Source Han Sans',
    'Source Han Serif',
    'Times New Roman',
    'Ubuntu',
    'Ubuntu Mono',
    'WenQuanYi Micro Hei',
    'WenQuanYi Zen Hei',
    'XiHeiti'
];
const IOS_FONTS = [
    'Avenir',
    'Avenir Next',
    'Courier',
    'Courier New',
    'FangSong',
    'Georgia',
    'Heiti',
    'Helvetica',
    'Helvetica Neue',
    'Hiragino Mincho',
    'Hiragino Sans',
    'Kaiti',
    'LXGW WenKai GB Screen',
    'LXGW WenKai TC',
    'Palatino',
    'PingFang SC',
    'PingFang TC',
    'San Francisco',
    'SF Pro Display',
    'SF Pro Rounded',
    'SF Pro Text',
    'Songti',
    'Times New Roman',
    'Verdana',
    'XiHeiti'
];
const ANDROID_FONTS = [
    'Arial',
    'Droid Sans',
    'Droid Serif',
    'FangSong',
    'FZLanTingHei',
    'Georgia',
    'Heiti',
    'Kaiti',
    'LXGW WenKai GB Screen',
    'LXGW WenKai TC',
    'Noto Sans',
    'Noto Sans CJK',
    'Noto Sans JP',
    'Noto Serif',
    'Noto Serif CJK',
    'Noto Serif JP',
    'PingFang SC',
    'Roboto',
    'Source Han Sans',
    'Source Han Serif',
    'STHeiti',
    'STSong',
    'Tahoma',
    'Verdana',
    'XiHeiti'
];
const CJK_EXCLUDE_PATTENS = new RegExp([
    'AlBayan',
    'STIX',
    'Kailasa',
    'ITCTT',
    'Luminari',
    'Myanmar'
].join('|'), 'i');
const CJK_FONTS_PATTENS = new RegExp([
    'CJK',
    'TC$',
    'SC$',
    'HK',
    'JP',
    'TW',
    'Sim',
    'Kai',
    'Hei',
    'Yan',
    'Min',
    'Khai',
    'Yuan',
    'Song',
    'Ming',
    'FZ',
    'Huiwen',
    'KingHwa',
    'FangZheng',
    'WenQuanYi',
    'PingFang',
    'Hiragino',
    'Meiryo',
    'Source\\s?Han',
    'Yu\\s?Gothic',
    'Yu\\s?Mincho',
    'Mincho',
    'Nanum',
    'Malgun',
    'Gulim',
    'Dotum',
    'Batang',
    'Gungsuh',
    'OPPO sans',
    'MiSans',
    'Fallback'
].join('|'), 'i');
const BOOK_IDS_SEPARATOR = '+';
const DOWNLOAD_READEST_URL = 'https://readest.com?utm_source=readest_web';
const READEST_WEB_BASE_URL = ("TURBOPACK compile-time value", "http://localhost:3000") || 'https://web.readest.com';
const READEST_NODE_BASE_URL = ("TURBOPACK compile-time value", "http://localhost:3000") || 'https://node.readest.com';
const LATEST_DOWNLOAD_BASE_URL = 'https://download.readest.com/releases';
const READEST_UPDATER_FILE = `${LATEST_DOWNLOAD_BASE_URL}/latest.json`;
const READEST_CHANGELOG_FILE = `${LATEST_DOWNLOAD_BASE_URL}/release-notes.json`;
const READEST_PUBLIC_STORAGE_BASE_URL = ("TURBOPACK compile-time value", "http://localhost:3000") || 'https://storage.readest.com';
const READEST_OPDS_USER_AGENT = 'Readest/1.0 (OPDS Browser)';
const SYNC_PROGRESS_INTERVAL_SEC = 3;
const SYNC_NOTES_INTERVAL_SEC = 5;
const SYNC_BOOKS_INTERVAL_SEC = 5;
const CHECK_UPDATE_INTERVAL_SEC = 24 * 60 * 60;
const MAX_ZOOM_LEVEL = 500;
const MIN_ZOOM_LEVEL = 50;
const ZOOM_STEP = 10;
const DEFAULT_STORAGE_QUOTA = {
    free: 500 * 1024 * 1024,
    plus: 5 * 1024 * 1024 * 1024,
    pro: 20 * 1024 * 1024 * 1024,
    purchase: 0
};
const DEFAULT_DAILY_TRANSLATION_QUOTA = {
    free: 10 * 1024,
    plus: 100 * 1024,
    pro: 500 * 1024,
    purchase: 0
};
const DOUBLE_CLICK_INTERVAL_THRESHOLD_MS = 250;
const DISABLE_DOUBLE_CLICK_ON_MOBILE = true;
const LONG_HOLD_THRESHOLD = 500;
const CUSTOM_THEME_TEMPLATES = [
    {
        light: {
            fg: '#2b2b2b',
            bg: '#f3f3f3',
            primary: '#3c5a72'
        },
        dark: {
            fg: '#d0d0d0',
            bg: '#1a1c1f',
            primary: '#486e8a'
        }
    },
    {
        light: {
            fg: '#3f2f3c',
            bg: '#f5ecf8',
            primary: '#7b5291'
        },
        dark: {
            fg: '#d6cadd',
            bg: '#3a2c3d',
            primary: '#bda0cc'
        }
    },
    {
        light: {
            fg: '#2b2b2b',
            bg: '#defcd9',
            primary: '#00796b'
        },
        dark: {
            fg: '#c8e6c9',
            bg: '#273c33',
            primary: '#26a69a'
        }
    }
];
const MIGHT_BE_RTL_LANGS = [
    'zh',
    'ja',
    'ko',
    'ar',
    'he',
    'fa',
    'ur',
    'dv',
    'ps',
    'sd',
    'yi',
    ''
];
const TRANSLATED_LANGS = {
    en: 'English',
    fr: 'Français',
    de: 'Deutsch',
    nl: 'Nederlands',
    it: 'Italiano',
    ja: '日本語',
    ko: '한국어',
    es: 'Español',
    pt: 'Português',
    ru: 'Русский',
    ar: 'العربية',
    fa: 'فارسی',
    el: 'Ελληνικά',
    uk: 'Українська',
    pl: 'Polski',
    tr: 'Türkçe',
    hi: 'हिन्दी',
    id: 'Indonesia',
    vi: 'Tiếng Việt',
    th: 'ภาษาไทย',
    ms: 'Melayu',
    bo: 'བོད་སྐད་',
    bn: 'বাংলা',
    ta: 'தமிழ்',
    si: 'සිංහල',
    'zh-CN': '简体中文',
    'zh-TW': '正體中文'
};
const TRANSLATOR_LANGS = {
    ...TRANSLATED_LANGS,
    nb: 'Bokmål',
    sv: 'Svenska',
    fi: 'Suomi',
    da: 'Dansk',
    cs: 'Čeština',
    hu: 'Magyar',
    ro: 'Română',
    bg: 'Български',
    hr: 'Hrvatski',
    lt: 'Lietuvių',
    sl: 'Slovenščina',
    sk: 'Slovenčina',
    fa: 'فارسی'
};
const SUPPORTED_LANGS = {
    ...TRANSLATED_LANGS,
    zh: '中文'
};
const SUPPORTED_LANGNAMES = Object.fromEntries(_c1 = Object.entries(SUPPORTED_LANGS).map(_c = ([code, name])=>[
        name,
        code
    ]));
_c2 = SUPPORTED_LANGNAMES;
var _c, _c1, _c2;
__turbopack_context__.k.register(_c, "SUPPORTED_LANGNAMES$Object.fromEntries$Object.entries(SUPPORTED_LANGS).map");
__turbopack_context__.k.register(_c1, "SUPPORTED_LANGNAMES$Object.fromEntries");
__turbopack_context__.k.register(_c2, "SUPPORTED_LANGNAMES");
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "getAPIBaseUrl",
    ()=>getAPIBaseUrl,
    "getBaseUrl",
    ()=>getBaseUrl,
    "getNodeAPIBaseUrl",
    ()=>getNodeAPIBaseUrl,
    "getNodeBaseUrl",
    ()=>getNodeBaseUrl,
    "hasCli",
    ()=>hasCli,
    "isPWA",
    ()=>isPWA,
    "isTauriAppPlatform",
    ()=>isTauriAppPlatform,
    "isWebAppPlatform",
    ()=>isWebAppPlatform
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$next$40$16$2e$0$2e$10_$40$babel$2b$core$40$7$2e$28$2e$0_react$2d$dom$40$19$2e$2$2e$0_react$40$19$2e$2$2e$0_$5f$react$40$19$2e$2$2e$0$2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/.pnpm/next@16.0.10_@babel+core@7.28.0_react-dom@19.2.0_react@19.2.0__react@19.2.0/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$constants$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/constants.ts [client] (ecmascript)");
;
const appPlatform = ("TURBOPACK compile-time value", "web") || 'web';
const isTauriAppPlatform = ()=>appPlatform === 'tauri';
const isWebAppPlatform = ()=>appPlatform === 'web';
const hasCli = ()=>window.__READEST_CLI_ACCESS === true;
const isPWA = ()=>window.matchMedia('(display-mode: standalone)').matches;
const getBaseUrl = ()=>("TURBOPACK compile-time value", "http://localhost:3000") ?? __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$constants$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["READEST_WEB_BASE_URL"];
const getNodeBaseUrl = ()=>("TURBOPACK compile-time value", "http://localhost:3000") ?? __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$constants$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["READEST_NODE_BASE_URL"];
const isWebDevMode = ()=>("TURBOPACK compile-time value", "development") === 'development' && isWebAppPlatform();
const getAPIBaseUrl = ()=>isWebDevMode() ? '/api' : "TURBOPACK unreachable";
const getNodeAPIBaseUrl = ()=>isWebDevMode() ? '/api' : "TURBOPACK unreachable";
let nativeAppService = null;
const getNativeAppService = async ()=>{
    if (!nativeAppService) {
        const { NativeAppService } = await __turbopack_context__.A("[project]/apps/readest-app/src/services/nativeAppService.ts [client] (ecmascript, async loader)");
        nativeAppService = new NativeAppService();
        await nativeAppService.init();
    }
    return nativeAppService;
};
let webAppService = null;
const getWebAppService = async ()=>{
    if (!webAppService) {
        const { WebAppService } = await __turbopack_context__.A("[project]/apps/readest-app/src/services/webAppService.ts [client] (ecmascript, async loader)");
        webAppService = new WebAppService();
        await webAppService.init();
    }
    return webAppService;
};
const environmentConfig = {
    getAppService: async ()=>{
        // Check if actually running in Tauri environment (runtime check)
        const isTauriRuntime = ("TURBOPACK compile-time value", "object") !== 'undefined' && window.__TAURI__;
        if (isTauriAppPlatform() && isTauriRuntime) //TURBOPACK unreachable
        ;
        else {
            return getWebAppService();
        }
    }
};
const __TURBOPACK__default__export__ = environmentConfig;
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transferManager.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transferManager",
    ()=>transferManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/store/transferStore.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$event$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/event.ts [client] (ecmascript)");
;
;
const TRANSFER_QUEUE_KEY = 'readest_transfer_queue';
const RETRY_DELAY_BASE_MS = 2000;
class TransferManager {
    static instance;
    appService = null;
    isProcessing = false;
    abortControllers = new Map();
    isInitialized = false;
    getLibrary = null;
    updateBook = null;
    _ = null;
    constructor(){}
    static getInstance() {
        if (!TransferManager.instance) {
            TransferManager.instance = new TransferManager();
        }
        return TransferManager.instance;
    }
    async initialize(appService, getLibrary, updateBook, translationFn) {
        if (this.isInitialized) return;
        this.appService = appService;
        this.getLibrary = getLibrary;
        this.updateBook = updateBook;
        this._ = translationFn;
        await this.loadPersistedQueue();
        this.isInitialized = true;
        // Start processing queue
        this.processQueue();
    }
    isReady() {
        return this.isInitialized && this.appService !== null;
    }
    queueUpload(book, priority = 10) {
        if (!this.isReady()) {
            console.warn('TransferManager not initialized');
            return null;
        }
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        // Check if already queued or in progress
        const existing = store.getTransferByBookHash(book.hash, 'upload');
        if (existing) {
            return existing.id;
        }
        const transferId = store.addTransfer(book.hash, book.title, 'upload', priority);
        this.persistQueue();
        this.processQueue();
        return transferId;
    }
    queueDownload(book, priority = 10) {
        if (!this.isReady()) {
            console.warn('TransferManager not initialized');
            return null;
        }
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        const existing = store.getTransferByBookHash(book.hash, 'download');
        if (existing) {
            return existing.id;
        }
        const transferId = store.addTransfer(book.hash, book.title, 'download', priority);
        this.persistQueue();
        this.processQueue();
        return transferId;
    }
    queueDelete(book, priority = 10, isBackground = false) {
        if (!this.isReady()) {
            console.warn('TransferManager not initialized');
            return null;
        }
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        const existing = store.getTransferByBookHash(book.hash, 'delete');
        if (existing) {
            return existing.id;
        }
        const transferId = store.addTransfer(book.hash, book.title, 'delete', priority, isBackground);
        this.persistQueue();
        this.processQueue();
        return transferId;
    }
    queueBatchUploads(books, priority = 10) {
        return books.map((book)=>this.queueUpload(book, priority)).filter((id)=>id !== null);
    }
    cancelTransfer(transferId) {
        const controller = this.abortControllers.get(transferId);
        if (controller) {
            controller.abort();
            this.abortControllers.delete(transferId);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().setTransferStatus(transferId, 'cancelled');
        this.persistQueue();
    }
    retryTransfer(transferId) {
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        store.retryTransfer(transferId);
        this.persistQueue();
        this.processQueue();
    }
    retryAllFailed() {
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        const failed = store.getFailedTransfers();
        failed.forEach((transfer)=>{
            store.retryTransfer(transfer.id);
        });
        this.persistQueue();
        this.processQueue();
    }
    pauseQueue() {
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().pauseQueue();
        this.persistQueue();
    }
    resumeQueue() {
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().resumeQueue();
        this.processQueue();
        this.persistQueue();
    }
    async processQueue() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        try {
            await this._processQueueInternal();
        } finally{
            this.isProcessing = false;
        }
    }
    async _processQueueInternal() {
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        if (store.isQueuePaused) return;
        const pending = store.getPendingTransfers();
        const activeCount = store.getActiveTransfers().length;
        const maxConcurrent = store.maxConcurrent;
        const availableSlots = maxConcurrent - activeCount;
        if (availableSlots <= 0 || pending.length === 0) return;
        // Sort by priority (lower = higher priority) then by createdAt
        const sortedPending = [
            ...pending
        ].sort((a, b)=>{
            if (a.priority !== b.priority) return a.priority - b.priority;
            return a.createdAt - b.createdAt;
        });
        const toProcess = sortedPending.slice(0, availableSlots);
        await Promise.all(toProcess.map((transfer)=>this.executeTransfer(transfer)));
        // Check if more items to process
        const newStore = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        if (newStore.getPendingTransfers().length > 0 && !newStore.isQueuePaused) {
            setTimeout(()=>this.processQueue(), 100);
        }
    }
    async executeTransfer(transfer) {
        if (!this.appService || !this.getLibrary || !this.updateBook) {
            console.error('TransferManager not properly initialized');
            return;
        }
        const _ = this._;
        const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
        const abortController = new AbortController();
        this.abortControllers.set(transfer.id, abortController);
        store.setTransferStatus(transfer.id, 'in_progress');
        store.setActiveCount(store.getActiveTransfers().length + 1);
        const progressHandler = (progress)=>{
            if (abortController.signal.aborted) return;
            const percentage = progress.total > 0 ? progress.progress / progress.total * 100 : 0;
            __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().updateTransferProgress(transfer.id, percentage, progress.progress, progress.total, progress.transferSpeed);
        };
        try {
            const library = this.getLibrary();
            const book = library.find((b)=>b.hash === transfer.bookHash);
            if (!book) {
                throw new Error(_('Book not found in library'));
            }
            if (transfer.type === 'upload') {
                // Cloud upload functionality removed - using local server storage only
                throw new Error(_('Upload functionality has been removed'));
            } else if (transfer.type === 'download') {
                // Cloud download functionality removed - using local server storage only
                throw new Error(_('Download functionality has been removed'));
            } else if (transfer.type === 'delete') {
                await this.appService.deleteBook(book, 'cloud');
                await this.updateBook(book);
            }
            __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().setTransferStatus(transfer.id, 'completed');
            const successMessages = {
                upload: _('Book uploaded: {{title}}', {
                    title: transfer.bookTitle
                }),
                download: _('Book downloaded: {{title}}', {
                    title: transfer.bookTitle
                }),
                delete: _('Deleted cloud backup of the book: {{title}}', {
                    title: transfer.bookTitle
                })
            };
            if (!transfer.isBackground) {
                __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$event$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["eventDispatcher"].dispatch('toast', {
                    type: 'info',
                    timeout: 2000,
                    message: successMessages[transfer.type]
                });
            }
        } catch (error) {
            if (abortController.signal.aborted) {
                // Already cancelled, don't update status
                return;
            }
            const errorMessage = error instanceof Error ? error.message : _('Unknown error');
            const currentStore = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
            const currentTransfer = currentStore.transfers[transfer.id];
            if (currentTransfer && currentTransfer.retryCount < currentTransfer.maxRetries) {
                // Schedule retry with exponential backoff
                const delay = RETRY_DELAY_BASE_MS * Math.pow(2, currentTransfer.retryCount);
                currentStore.incrementRetryCount(transfer.id);
                currentStore.setTransferStatus(transfer.id, 'pending', `Retry ${currentTransfer.retryCount + 1}/${currentTransfer.maxRetries}`);
                setTimeout(()=>{
                    this.processQueue();
                }, delay);
            } else {
                if (errorMessage.includes('Not authenticated')) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$event$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["eventDispatcher"].dispatch('toast', {
                        type: 'error',
                        message: _('Please log in to continue')
                    });
                } else if (errorMessage.includes('Insufficient storage quota')) {
                    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$event$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["eventDispatcher"].dispatch('toast', {
                        type: 'error',
                        message: _('Insufficient storage quota')
                    });
                } else {
                    const errorMessages = {
                        upload: _('Failed to upload book: {{title}}', {
                            title: transfer.bookTitle
                        }),
                        download: _('Failed to download book: {{title}}', {
                            title: transfer.bookTitle
                        }),
                        delete: _('Failed to delete cloud backup of the book: {{title}}', {
                            title: transfer.bookTitle
                        })
                    };
                    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$event$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["eventDispatcher"].dispatch('toast', {
                        type: 'error',
                        message: errorMessages[transfer.type]
                    });
                }
                __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState().setTransferStatus(transfer.id, 'failed', errorMessage);
            }
        } finally{
            this.abortControllers.delete(transfer.id);
            const currentStore = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
            currentStore.setActiveCount(Math.max(0, currentStore.getActiveTransfers().length));
            this.persistQueue();
            // Continue processing
            setTimeout(()=>this.processQueue(), 100);
        }
    }
    async loadPersistedQueue() {
        try {
            if (typeof localStorage === 'undefined') return;
            const stored = localStorage.getItem(TRANSFER_QUEUE_KEY);
            if (!stored) return;
            const data = JSON.parse(stored);
            const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
            // Restore all transfers using the store's restore method
            // This preserves the original IDs and handles in_progress -> pending conversion
            store.restoreTransfers(data.transfers, data.isQueuePaused);
        } catch (error) {
            console.error('Failed to load transfer queue:', error);
        }
    }
    persistQueue() {
        try {
            if (typeof localStorage === 'undefined') return;
            const store = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$transferStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useTransferStore"].getState();
            // Persist all transfers including completed (for history)
            const data = {
                transfers: store.transfers,
                isQueuePaused: store.isQueuePaused
            };
            localStorage.setItem(TRANSFER_QUEUE_KEY, JSON.stringify(data));
        } catch (error) {
            console.error('Failed to persist transfer queue:', error);
        }
    }
}
const transferManager = TransferManager.getInstance();
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/types.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrorCodes",
    ()=>ErrorCodes
]);
const ErrorCodes = {
    UNAUTHORIZED: 'Unauthorized',
    DEEPL_API_ERROR: 'DeepL API Error',
    DAILY_QUOTA_EXCEEDED: 'Daily Quota Exceeded',
    INTERNAL_SERVER_ERROR: 'Internal Server Error'
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/cache.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clearCache",
    ()=>clearCache,
    "getCacheKey",
    ()=>getCacheKey,
    "getCacheStats",
    ()=>getCacheStats,
    "getFromCache",
    ()=>getFromCache,
    "initCache",
    ()=>initCache,
    "loadCacheFromDB",
    ()=>loadCacheFromDB,
    "pruneCache",
    ()=>pruneCache,
    "storeInCache",
    ()=>storeInCache
]);
const DB_NAME = 'TranslationCache';
const DB_VERSION = 1;
const STORE_NAME = 'translations';
const memoryCache = {};
const memoryTimestamps = {};
const openDatabase = ()=>{
    return new Promise((resolve, reject)=>{
        if (!window.indexedDB) {
            console.warn('IndexedDB not supported. Using in-memory cache only.');
            reject(new Error('IndexedDB not supported'));
            return;
        }
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (event)=>{
            console.error('IndexedDB error:', event);
            reject(new Error('Could not open IndexedDB'));
        };
        request.onsuccess = (event)=>{
            const db = event.target.result;
            resolve(db);
        };
        request.onupgradeneeded = (event)=>{
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, {
                    keyPath: 'key'
                });
                store.createIndex('provider', 'provider', {
                    unique: false
                });
                store.createIndex('timestamp', 'timestamp', {
                    unique: false
                });
            }
        };
    });
};
const loadCacheFromDB = async (options = {})=>{
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        let request;
        if (options.onlyLoadProviders && options.onlyLoadProviders.length > 0) {
            const providerPromises = options.onlyLoadProviders.map((provider)=>{
                return new Promise((resolve)=>{
                    const providerIndex = store.index('provider');
                    const request = providerIndex.getAll(provider);
                    request.onsuccess = ()=>{
                        resolve(request.result);
                    };
                    request.onerror = ()=>{
                        resolve([]);
                    };
                });
            });
            const allEntries = (await Promise.all(providerPromises)).flat();
            processLoadedEntries(allEntries, options);
        } else {
            request = store.getAll();
            request.onsuccess = ()=>{
                const entries = request.result;
                processLoadedEntries(entries, options);
            };
            request.onerror = (event)=>{
                console.error('Error loading cache from IndexedDB:', event);
            };
        }
        transaction.oncomplete = ()=>{
            db.close();
        };
    } catch (error) {
        console.error('Failed to load cache from IndexedDB:', error);
    }
};
const processLoadedEntries = (entries, options)=>{
    let filteredEntries = entries;
    if (options.maxAge) {
        const cutoff = Date.now() - options.maxAge;
        filteredEntries = filteredEntries.filter((entry)=>entry.timestamp >= cutoff);
    }
    if (options.onlyLoadLanguages) {
        if (options.onlyLoadLanguages.source && options.onlyLoadLanguages.source.length > 0) {
            filteredEntries = filteredEntries.filter((entry)=>options.onlyLoadLanguages.source.includes(entry.sourceLang));
        }
        if (options.onlyLoadLanguages.target && options.onlyLoadLanguages.target.length > 0) {
            filteredEntries = filteredEntries.filter((entry)=>options.onlyLoadLanguages.target.includes(entry.targetLang));
        }
    }
    if (options.maxEntries && filteredEntries.length > options.maxEntries) {
        filteredEntries.sort((a, b)=>b.timestamp - a.timestamp);
        filteredEntries = filteredEntries.slice(0, options.maxEntries);
    }
    filteredEntries.forEach((entry)=>{
        memoryCache[entry.key] = entry.translation;
        memoryTimestamps[entry.key] = entry.timestamp;
    });
// console.log(`Loaded ${filteredEntries.length} translations into memory cache`);
};
const getCacheKey = (text, sourceLang, targetLang, provider)=>{
    return `${provider}:${sourceLang}:${targetLang}:${text}`;
};
const getFromCache = async (text, sourceLang, targetLang, provider)=>{
    if (!text?.trim()) return null;
    const key = getCacheKey(text, sourceLang, targetLang, provider);
    if (memoryCache[key]) {
        return memoryCache[key];
    }
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);
        return new Promise((resolve)=>{
            request.onsuccess = ()=>{
                const entry = request.result;
                if (entry) {
                    memoryCache[key] = entry.translation;
                    memoryTimestamps[key] = entry.timestamp;
                    resolve(entry.translation);
                } else {
                    resolve(null);
                }
            };
            request.onerror = ()=>{
                resolve(null);
            };
            transaction.oncomplete = ()=>{
                db.close();
            };
        });
    } catch (error) {
        console.error('Error accessing IndexedDB:', error);
        return null;
    }
};
const storeInCache = async (text, translation, sourceLang, targetLang, provider)=>{
    if (!text?.trim() || !translation) return;
    const key = getCacheKey(text, sourceLang, targetLang, provider);
    const timestamp = Date.now();
    memoryCache[key] = translation;
    memoryTimestamps[key] = timestamp;
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const entry = {
            key,
            translation,
            timestamp,
            provider,
            sourceLang,
            targetLang,
            originalText: text
        };
        store.put(entry);
        return new Promise((resolve, reject)=>{
            transaction.oncomplete = ()=>{
                db.close();
                resolve();
            };
            transaction.onerror = (event)=>{
                console.error('Error storing in IndexedDB:', event);
                reject(new Error('Failed to store in IndexedDB'));
            };
        });
    } catch (error) {
        console.error('Error accessing IndexedDB:', error);
    }
};
const clearCache = async (filter)=>{
    let deletedCount = 0;
    if (!filter) {
        const count = Object.keys(memoryCache).length;
        Object.keys(memoryCache).forEach((key)=>{
            delete memoryCache[key];
            delete memoryTimestamps[key];
        });
        deletedCount = count;
    } else {
        const keysToDelete = [];
        Object.keys(memoryCache).forEach((key)=>{
            let shouldDelete = true;
            if (filter.provider) {
                const parts = key.split(':');
                const provider = parts[0];
                if (filter.provider && provider !== filter.provider) {
                    shouldDelete = false;
                }
            }
            if (shouldDelete && filter.maxAge && memoryTimestamps[key]) {
                const timestamp = memoryTimestamps[key];
                if (Date.now() - timestamp < filter.maxAge) {
                    shouldDelete = false;
                }
            }
            if (shouldDelete) {
                keysToDelete.push(key);
            }
        });
        keysToDelete.forEach((key)=>{
            delete memoryCache[key];
            delete memoryTimestamps[key];
        });
        deletedCount = keysToDelete.length;
    }
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        if (!filter) {
            store.clear();
        } else {
            const request = store.getAll();
            request.onsuccess = ()=>{
                const entries = request.result;
                const filteredEntries = entries.filter((entry)=>{
                    if (filter.provider && entry.provider !== filter.provider) {
                        return false;
                    }
                    if (filter.maxAge && Date.now() - entry.timestamp >= filter.maxAge) {
                        return true;
                    }
                    return true;
                });
                filteredEntries.forEach((entry)=>{
                    store.delete(entry.key);
                });
            };
        }
        return new Promise((resolve)=>{
            transaction.oncomplete = ()=>{
                db.close();
                resolve(deletedCount);
            };
            transaction.onerror = ()=>{
                db.close();
                resolve(deletedCount);
            };
        });
    } catch (error) {
        console.error('Error clearing IndexedDB cache:', error);
        return deletedCount;
    }
};
const getCacheStats = async (includeDB = false)=>{
    const memoryCacheEntries = Object.keys(memoryCache).length;
    let memoryCacheSizeInBytes = 0;
    for(const key in memoryCache){
        memoryCacheSizeInBytes += key.length;
        const value = memoryCache[key] || '';
        memoryCacheSizeInBytes += value.length;
    }
    if (!includeDB) {
        return {
            memoryCacheEntries,
            memoryCacheSizeInBytes
        };
    }
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const countRequest = store.count();
        return new Promise((resolve)=>{
            countRequest.onsuccess = ()=>{
                const dbCacheEntries = countRequest.result;
                const getAllRequest = store.getAll();
                getAllRequest.onsuccess = ()=>{
                    const entries = getAllRequest.result;
                    let dbCacheSizeInBytes = 0;
                    entries.forEach((entry)=>{
                        const entryString = JSON.stringify(entry);
                        dbCacheSizeInBytes += entryString.length;
                    });
                    const totalEntries = memoryCacheEntries + dbCacheEntries - Math.min(memoryCacheEntries, dbCacheEntries);
                    const totalSizeInBytes = memoryCacheSizeInBytes + dbCacheSizeInBytes;
                    resolve({
                        memoryCacheEntries,
                        memoryCacheSizeInBytes,
                        dbCacheEntries,
                        dbCacheSizeInBytes,
                        totalEntries,
                        totalSizeInBytes
                    });
                };
            };
            transaction.oncomplete = ()=>{
                db.close();
            };
            transaction.onerror = ()=>{
                db.close();
                resolve({
                    memoryCacheEntries,
                    memoryCacheSizeInBytes
                });
            };
        });
    } catch (error) {
        console.error('Error getting IndexedDB stats:', error);
        return {
            memoryCacheEntries,
            memoryCacheSizeInBytes
        };
    }
};
const pruneCache = async (options = {})=>{
    const { maxAge, maxEntries, maxSizeInBytes, dryRun = false } = options;
    if (!maxAge && !maxEntries && !maxSizeInBytes) {
        return 0;
    }
    try {
        const db = await openDatabase();
        const transaction = db.transaction(STORE_NAME, dryRun ? 'readonly' : 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const getAllRequest = store.getAll();
        return new Promise((resolve)=>{
            getAllRequest.onsuccess = ()=>{
                const entries = getAllRequest.result;
                const entriesToPrune = [];
                if (maxAge) {
                    const cutoffTime = Date.now() - maxAge;
                    const agedEntries = entries.filter((entry)=>entry.timestamp < cutoffTime);
                    entriesToPrune.push(...agedEntries);
                }
                if (maxEntries && entries.length > maxEntries) {
                    const sortedEntries = [
                        ...entries
                    ].sort((a, b)=>a.timestamp - b.timestamp);
                    const excessEntries = sortedEntries.slice(0, entries.length - maxEntries);
                    const prunedKeys = new Set(entriesToPrune.map((e)=>e.key));
                    excessEntries.forEach((entry)=>{
                        if (!prunedKeys.has(entry.key)) {
                            entriesToPrune.push(entry);
                        }
                    });
                }
                if (maxSizeInBytes) {
                    let currentSize = 0;
                    entries.forEach((entry)=>{
                        const entryString = JSON.stringify(entry);
                        currentSize += entryString.length;
                    });
                    if (currentSize > maxSizeInBytes) {
                        const remainingEntries = entries.filter((entry)=>!entriesToPrune.some((e)=>e.key === entry.key)).sort((a, b)=>a.timestamp - b.timestamp);
                        let sizeToRemove = currentSize - maxSizeInBytes;
                        const prunedKeys = new Set(entriesToPrune.map((e)=>e.key));
                        for (const entry of remainingEntries){
                            if (sizeToRemove <= 0) break;
                            if (!prunedKeys.has(entry.key)) {
                                const entryString = JSON.stringify(entry);
                                const entrySize = entryString.length * 2;
                                entriesToPrune.push(entry);
                                prunedKeys.add(entry.key);
                                sizeToRemove -= entrySize;
                            }
                        }
                    }
                }
                const pruneCount = entriesToPrune.length;
                if (!dryRun && pruneCount > 0) {
                    entriesToPrune.forEach((entry)=>{
                        store.delete(entry.key);
                        delete memoryCache[entry.key];
                        delete memoryTimestamps[entry.key];
                    });
                }
                resolve(pruneCount);
            };
            getAllRequest.onerror = ()=>{
                resolve(0);
            };
            transaction.oncomplete = ()=>{
                db.close();
            };
        });
    } catch (error) {
        console.error('Error pruning cache:', error);
        return 0;
    }
};
const initCache = async (options = {})=>{
    const { preload = true, preloadOptions = {
        maxAge: 30 * 24 * 60 * 60 * 1000,
        maxEntries: 10000
    }, autoPrune = true, pruneInterval = 60 * 60 * 1000, pruneOptions = {
        maxAge: 90 * 24 * 60 * 60 * 1000,
        maxEntries: 100000,
        maxSizeInBytes: 10 * 1024 * 1024
    } } = options;
    if (preload) {
        await loadCacheFromDB(preloadOptions);
    }
    let intervalId = null;
    if (autoPrune) {
        await pruneCache(pruneOptions);
        intervalId = window.setInterval(async ()=>{
            await pruneCache(pruneOptions);
        }, pruneInterval);
    }
    return ()=>{
        if (intervalId !== null) {
            clearInterval(intervalId);
        }
    };
};
let cleanupFunction = null;
if ("TURBOPACK compile-time truthy", 1) {
    initCache().then((cleanup)=>{
        cleanupFunction = cleanup;
    });
    window.addEventListener('beforeunload', ()=>{
        if (cleanupFunction) {
            cleanupFunction();
        }
    });
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/polish.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "basicPolish",
    ()=>basicPolish,
    "getPolisher",
    ()=>getPolisher,
    "polish",
    ()=>polish
]);
const languagePolishers = {
    // Chinese - fix punctuation spacing
    zh: (text)=>text.replace(/--/g, '⸺').replace(/\s+([。、！？])/g, '$1').replace(/([。、！？])\s+/g, '$1'),
    // Spanish - fix punctuation spacing
    es: (text)=>text.replace(/\?([A-ZÁÉÍÓÚÑÜ])/g, '? $1').replace(/\!([A-ZÁÉÍÓÚÑÜ])/g, '! $1'),
    // French - fix punctuation spacing
    fr: (text)=>text.replace(/\s+([!?:;])/g, ' $1').replace(/([!?:;])\s+/g, '$1 '),
    // Japanese - fix punctuation spacing
    ja: (text)=>text.replace(/\s+([。、！？])/g, '$1').replace(/([。、！？])\s+/g, '$1')
};
const basicPolish = (text)=>{
    return text.replace(/\s+/g, ' ') // Multiple spaces to single space
    .replace(/\s+([.,!?;:])/g, '$1') // Remove space before punctuation
    .trim();
};
function getPolisher(targetLang) {
    const langCode = targetLang.split('-')[0].toLowerCase();
    const languagePolisher = languagePolishers[langCode];
    if (languagePolisher) {
        return (text)=>{
            const basicPolished = basicPolish(text);
            const polished = languagePolisher(basicPolished);
            return polished;
        };
    }
    return basicPolish;
}
function polish(texts, targetLang) {
    const polisher = getPolisher(targetLang);
    return texts.map(polisher);
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/preprocess.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "basicSubstitute",
    ()=>basicSubstitute,
    "createPreprocessor",
    ()=>createPreprocessor,
    "preprocess",
    ()=>preprocess
]);
const defaultSubstitutions = {
    Cover: 'The Cover',
    Dedication: 'Dedication Page',
    Acknowledgements: 'The Acknowledgements'
};
const basicSubstitute = (text, substitutions)=>{
    const allSubstitutions = {
        ...defaultSubstitutions,
        ...substitutions
    };
    if (Object.keys(allSubstitutions).length === 0) {
        return text;
    }
    if (allSubstitutions[text]) {
        return allSubstitutions[text];
    }
    return text;
};
function createPreprocessor(substitutions = {}) {
    return (text)=>basicSubstitute(text, substitutions);
}
function preprocess(texts, substitutions = {}) {
    const preprocessor = createPreprocessor(substitutions);
    return texts.map(preprocessor);
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/utils.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getDailyUsage",
    ()=>getDailyUsage,
    "isTranslationAvailable",
    ()=>isTranslationAvailable,
    "saveDailyUsage",
    ()=>saveDailyUsage
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
;
;
const DAILY_USAGE_KEY = 'translationDailyUsage';
const saveDailyUsage = (usage, date)=>{
    if ("TURBOPACK compile-time truthy", 1) {
        const isoDate = date || new Date().toISOString().split('T')[0];
        const dailyUsage = {
            [isoDate]: usage
        };
        localStorage.setItem(DAILY_USAGE_KEY, JSON.stringify(dailyUsage));
    }
};
const getDailyUsage = (date)=>{
    if ("TURBOPACK compile-time truthy", 1) {
        const isoDate = date || new Date().toISOString().split('T')[0];
        const usage = localStorage.getItem(DAILY_USAGE_KEY);
        if (usage) {
            const dailyUsage = JSON.parse(usage);
            if (dailyUsage[isoDate]) {
                return dailyUsage[isoDate];
            }
        }
    }
    return null;
};
const isTranslationAvailable = (book, targetLanguage)=>{
    if (!book || book.format === 'PDF') {
        return false;
    }
    const primaryLanguage = book.primaryLanguage || '';
    if (!primaryLanguage || primaryLanguage.toLowerCase() === 'und') {
        return false;
    }
    if (targetLanguage && (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isSameLang"])(primaryLanguage, targetLanguage)) {
        return false;
    }
    if (!targetLanguage && (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isSameLang"])(primaryLanguage, (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getLocale"])())) {
        return false;
    }
    return true;
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/providers/deepl.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deeplProvider",
    ()=>deeplProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$types$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/types.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$access$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/access.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$constants$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/constants.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$utils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/utils.ts [client] (ecmascript)");
;
;
;
;
;
;
;
const DEEPL_API_ENDPOINT = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getAPIBaseUrl"])() + '/deepl/translate';
const deeplProvider = {
    name: 'deepl',
    label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('DeepL'),
    authRequired: true,
    quotaExceeded: false,
    translate: async (text, sourceLang, targetLang, token, useCache = false)=>{
        const authRequired = deeplProvider.authRequired;
        const headers = {
            'Content-Type': 'application/json'
        };
        let userPlan = 'free';
        if (token) {
            userPlan = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$access$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getSubscriptionPlan"])(token);
            headers['Authorization'] = `Bearer ${token}`;
        }
        if (authRequired && !token) {
            throw new Error('Authentication token is required for DeepL translation');
        }
        const body = JSON.stringify({
            text: text,
            source_lang: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(sourceLang).toUpperCase(),
            target_lang: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(targetLang).toUpperCase(),
            use_cache: useCache
        });
        const quota = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$constants$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["DEFAULT_DAILY_TRANSLATION_QUOTA"][userPlan];
        try {
            const response = await fetch(DEEPL_API_ENDPOINT, {
                method: 'POST',
                headers,
                body
            });
            if (!response.ok) {
                const data = await response.json();
                if (data && data.error && data.error === __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$types$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["ErrorCodes"].DAILY_QUOTA_EXCEEDED) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$utils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["saveDailyUsage"])(quota);
                    deeplProvider.quotaExceeded = true;
                    throw new Error(__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$types$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["ErrorCodes"].DAILY_QUOTA_EXCEEDED);
                }
                throw new Error(`Translation failed with status ${response.status}`);
            }
            const data = await response.json();
            if (!data || !data.translations) {
                throw new Error('Invalid response from translation service');
            }
            return text.map((line, i)=>{
                if (!line?.trim().length) {
                    return line;
                }
                const translation = data.translations?.[i];
                if (translation?.daily_usage) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$utils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["saveDailyUsage"])(translation.daily_usage);
                    deeplProvider.quotaExceeded = data.daily_usage >= quota;
                }
                return translation?.text || line;
            });
        } catch (error) {
            throw error;
        }
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/providers/azure.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "azureProvider",
    ()=>azureProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tauri-apps+plugin-http@2.5.6/node_modules/@tauri-apps/plugin-http/dist-js/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
;
;
;
;
let tokenCache = null;
const getAuthToken = async ()=>{
    const now = Date.now();
    if (tokenCache && tokenCache.expiresAt > now) {
        return tokenCache.token;
    }
    try {
        const fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetch"] : window.fetch;
        const tokenResponse = await fetch('https://edge.microsoft.com/translate/auth', {
            method: 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0'
            }
        });
        if (!tokenResponse.ok) {
            throw new Error(`Failed to get auth token: ${tokenResponse.status}`);
        }
        const token = await tokenResponse.text();
        const expiresAt = now + 8 * 60 * 1000;
        tokenCache = {
            token,
            expiresAt
        };
        return token;
    } catch (error) {
        console.error('Error getting Microsoft translation auth token:', error);
        throw error;
    }
};
const azureProvider = {
    name: 'azure',
    label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Azure Translator'),
    translate: async (text, sourceLang, targetLang)=>{
        if (!text.length) return [];
        const results = [];
        const msSourceLang = sourceLang ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToFullLang"])(sourceLang) : '';
        const msTargetLang = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToFullLang"])(targetLang);
        const translationPromises = text.map(async (line, index)=>{
            if (!line?.trim().length) {
                results[index] = line;
                return;
            }
            const url = 'https://api-edge.cognitive.microsofttranslator.com/translate';
            const params = new URLSearchParams({
                to: msTargetLang,
                'api-version': '3.0'
            });
            if (msSourceLang && msSourceLang.toLowerCase() !== 'auto') {
                params.append('from', msSourceLang);
            }
            const token = await getAuthToken();
            const fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetch"] : window.fetch;
            const response = await fetch(`${url}?${params.toString()}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`
                },
                body: JSON.stringify([
                    {
                        Text: line
                    }
                ])
            });
            if (!response.ok) {
                throw new Error(`Translation failed with status ${response.status}`);
            }
            const data = await response.json();
            if (Array.isArray(data) && data.length > 0 && data[0].translations) {
                results[index] = data[0].translations[0].text || line;
            } else {
                results[index] = line;
            }
        });
        await Promise.all(translationPromises);
        return results;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/providers/google.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "googleProvider",
    ()=>googleProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tauri-apps+plugin-http@2.5.6/node_modules/@tauri-apps/plugin-http/dist-js/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
;
;
;
;
const googleProvider = {
    name: 'google',
    label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Google Translate'),
    translate: async (text, sourceLang, targetLang)=>{
        if (!text.length) return [];
        const results = [];
        const translationPromises = text.map(async (line, index)=>{
            if (!line?.trim().length) {
                results[index] = line;
                return;
            }
            const url = new URL('https://translate.googleapis.com/translate_a/single');
            url.searchParams.append('client', 'gtx');
            url.searchParams.append('dt', 't');
            url.searchParams.append('sl', (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(sourceLang).toLowerCase() || 'auto');
            url.searchParams.append('tl', (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(targetLang).toLowerCase());
            url.searchParams.append('q', line);
            const fetch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetch"] : window.fetch;
            const response = await fetch(url.toString());
            if (!response.ok) {
                throw new Error(`Translation failed with status ${response.status}`);
            }
            const data = await response.json();
            if (Array.isArray(data) && Array.isArray(data[0])) {
                const translatedText = data[0].filter((segment)=>Array.isArray(segment) && segment[0]).map((segment)=>segment[0]).join('');
                results[index] = translatedText || line;
            } else {
                results[index] = line;
            }
        });
        await Promise.all(translationPromises);
        return results;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/providers/yandex.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "yandexProvider",
    ()=>yandexProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tauri-apps+plugin-http@2.5.6/node_modules/@tauri-apps/plugin-http/dist-js/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
;
;
;
;
/**
 * Based on https://translate.toil.cc/v2/docs API specification
 */ async function translateSingleTextForService(text, lang, service) {
    const fetchImpl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetch"] : window.fetch;
    const url = 'https://translate.toil.cc/v2/translate/';
    const request = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            lang: lang,
            service: service,
            text: text
        })
    };
    const response = await fetchImpl(url, request);
    if (!response.ok) {
        const response_json = JSON.stringify(await response.json());
        throw new Error(`${service} failed with status ${response.status}\n${text.length}\n${JSON.stringify(request)}\n${response_json}`);
    }
    const data = await response.json();
    if (data && Array.isArray(data.translations)) {
        return data.translations;
    } else {
        // fallback: return original texts if translation failed
        return [
            text
        ];
    }
}
const yandexProvider = {
    name: 'yandex',
    label: (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Yandex Translate'),
    authRequired: false,
    translate: async (texts, sourceLang, targetLang)=>{
        if (!texts.length) return [];
        /**
      Possible options:
      - yandexcloud: often returns 500: {"error":"The text couldn't be translated, because Forbidden"}
      - yandexgpt: often better than others
      - yandextranslate
      - yandexbrowser
    */ const service = "yandexgpt";
        // Yandex does not accept "auto" language
        const source_lang = sourceLang == "AUTO" ? "en" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(sourceLang).toLowerCase();
        const target_lang = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["normalizeToShortLang"])(targetLang).toLowerCase();
        const lang = `${source_lang}-${target_lang}`;
        const responses = await Promise.all(texts.map(async (text)=>{
            return await translateSingleTextForService(text, lang, service);
        }));
        const translatedTexts = responses.flat();
        return translatedTexts;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/providers/index.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getTranslator",
    ()=>getTranslator,
    "getTranslators",
    ()=>getTranslators
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$deepl$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/providers/deepl.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$azure$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/providers/azure.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$google$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/providers/google.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$yandex$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/providers/yandex.ts [client] (ecmascript)");
;
;
;
;
function createTranslator(name, implementation) {
    if (name !== implementation.name) {
        throw Error(`Translator name "${name}" does not match implementation name "${implementation.name}"`);
    }
    return implementation;
}
const deeplTranslator = createTranslator('deepl', __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$deepl$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["deeplProvider"]);
const azureTranslator = createTranslator('azure', __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$azure$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["azureProvider"]);
const googleTranslator = createTranslator('google', __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$google$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["googleProvider"]);
const yandexTranslator = createTranslator('yandex', __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$yandex$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["yandexProvider"]);
const availableTranslators = [
    deeplTranslator,
    azureTranslator,
    googleTranslator,
    yandexTranslator
];
const getTranslator = (name)=>{
    return availableTranslators.find((translator)=>translator.name === name);
};
const getTranslators = ()=>{
    return availableTranslators;
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/translators/index.ts [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$types$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/types.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$cache$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/cache.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$polish$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/polish.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$preprocess$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/preprocess.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$translators$2f$providers$2f$index$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/translators/providers/index.ts [client] (ecmascript)");
;
;
;
;
;
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/sync/KOSyncClient.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "KOSyncClient",
    ()=>KOSyncClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$md5$40$0$2e$8$2e$3$2f$node_modules$2f$js$2d$md5$2f$src$2f$md5$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/js-md5@0.8.3/node_modules/js-md5/src/md5.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tauri-apps+plugin-http@2.5.6/node_modules/@tauri-apps/plugin-http/dist-js/index.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$network$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/network.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/environment.ts [client] (ecmascript)");
;
;
;
;
class KOSyncClient {
    config;
    isLanServer;
    constructor(config){
        this.config = config;
        this.config.serverUrl = config.serverUrl.replace(/\/$/, '');
        this.isLanServer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$network$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isLanAddress"])(this.config.serverUrl);
    }
    async request(endpoint, options = {}) {
        const { method = 'GET', body, headers: additionalHeaders, useAuth = true } = options;
        const headers = new Headers(additionalHeaders || {});
        if (useAuth) {
            headers.set('X-Auth-User', this.config.username);
            headers.set('X-Auth-Key', this.config.userkey);
        }
        if (this.isLanServer || (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])()) {
            const fetch1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isTauriAppPlatform"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$plugin$2d$http$40$2$2e$5$2e$6$2f$node_modules$2f40$tauri$2d$apps$2f$plugin$2d$http$2f$dist$2d$js$2f$index$2e$js__$5b$client$5d$__$28$ecmascript$29$__["fetch"] : window.fetch;
            const directUrl = `${this.config.serverUrl}${endpoint}`;
            return fetch1(directUrl, {
                method,
                headers: {
                    accept: 'application/vnd.koreader.v1+json',
                    ...method === 'GET' ? {} : {
                        'Content-Type': 'application/json'
                    },
                    ...Object.fromEntries(headers.entries())
                },
                body,
                danger: {
                    acceptInvalidCerts: true,
                    acceptInvalidHostnames: true
                }
            });
        }
        const proxyUrl = `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$environment$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getAPIBaseUrl"])()}/kosync`;
        const proxyBody = {
            serverUrl: this.config.serverUrl,
            endpoint,
            method,
            headers: Object.fromEntries(headers.entries()),
            body: body ? JSON.parse(body) : undefined
        };
        return fetch(proxyUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(proxyBody)
        });
    }
    /**
   * Connects to the KOSync server with authentication
   * @param username - The username for authentication
   * @param password - The password for authentication
   * @returns Promise with success status and optional message
   */ async connect(username, password) {
        const userkey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$js$2d$md5$40$0$2e$8$2e$3$2f$node_modules$2f$js$2d$md5$2f$src$2f$md5$2e$js__$5b$client$5d$__$28$ecmascript$29$__["md5"])(password);
        try {
            const authResponse = await this.request('/users/auth', {
                method: 'GET',
                headers: {
                    'X-Auth-User': username,
                    'X-Auth-Key': userkey
                }
            });
            if (authResponse.ok) {
                return {
                    success: true,
                    message: 'Login successful.'
                };
            }
            if (authResponse.status === 401) {
                const registerResponse = await this.request('/users/create', {
                    method: 'POST',
                    useAuth: false,
                    body: JSON.stringify({
                        username,
                        password: userkey
                    })
                });
                if (registerResponse.ok) {
                    return {
                        success: true,
                        message: 'Registration successful.'
                    };
                }
                const regError = await registerResponse.json().catch(()=>({}));
                if (registerResponse.status === 402) {
                    return {
                        success: false,
                        message: 'Invalid credentials.'
                    };
                }
                return {
                    success: false,
                    message: regError.message || 'Registration failed.'
                };
            }
            const errorBody = await authResponse.json().catch(()=>({}));
            return {
                success: false,
                message: errorBody.message || `Authorization failed with status: ${authResponse.status}`
            };
        } catch (e) {
            console.error('KOSync connection failed', e);
            return {
                success: false,
                message: e.message || 'Connection error.'
            };
        }
    }
    /**
   * Retrieves the reading progress for a specific book from the server
   * @param book - The book to get progress for
   * @returns Promise with the progress data or null if not found
   */ async getProgress(book) {
        if (!this.config.userkey) return null;
        const documentHash = this.getDocumentDigest(book);
        if (!documentHash) return null;
        try {
            const response = await this.request(`/syncs/progress/${documentHash}`);
            if (!response.ok) {
                console.error(`KOSync: Failed to get progress for ${book.title}. Status: ${response.status}`);
                return null;
            }
            const data = await response.json();
            return data.document ? data : null;
        } catch (e) {
            console.error('KOSync getProgress failed', e);
            return null;
        }
    }
    /**
   * Updates the reading progress for a specific book on the server
   * @param book - The book to update progress for
   * @param progress - The current reading progress position
   * @param percentage - The reading completion percentage
   * @returns Promise with boolean indicating success
   */ async updateProgress(book, progress, percentage) {
        if (!this.config.userkey) return false;
        const documentHash = this.getDocumentDigest(book);
        if (!documentHash) return false;
        const payload = {
            document: documentHash,
            progress,
            percentage,
            device: this.config.deviceName,
            device_id: this.config.deviceId
        };
        try {
            const response = await this.request('/syncs/progress', {
                method: 'PUT',
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                console.error(`KOSync: Failed to update progress for ${book.title}. Status: ${response.status}`);
                return false;
            }
            return true;
        } catch (e) {
            console.error('KOSync updateProgress failed', e);
            return false;
        }
    }
    getDocumentDigest(book) {
        if (this.config.checksumMethod === 'filename') {
            console.warn('This is not possible anymore, using md5 instead.');
        }
        return book.hash;
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/footnote.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "footnoteTransformer",
    ()=>footnoteTransformer
]);
const footnoteTransformer = {
    name: 'footnote',
    transform: async (ctx)=>{
        let result = ctx.content;
        result = result.replace(/<aside\s+epub:type\s*=\s*["'](footnote|endnote|note|rearnote)["']([^>]*)>/gi, '<aside class="epubtype-footnote" epub:type="$1"$2>');
        return result;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/language.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "languageTransformer",
    ()=>languageTransformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/lang.ts [client] (ecmascript)");
;
const languageTransformer = {
    name: 'language',
    transform: async (ctx)=>{
        const primaryLanguage = ctx.primaryLanguage;
        let result = ctx.content;
        const attrsMatch = result.match(/<html\b([^>]*)>/i);
        if (attrsMatch) {
            let attrs = attrsMatch[1] || '';
            const langRegex = / lang="([^"]*)"/i;
            const xmlLangRegex = / xml:lang="([^"]*)"/i;
            const xmlLangMatch = attrs.match(xmlLangRegex);
            const langMatch = attrs.match(langRegex);
            const docLang = langMatch?.[1] || xmlLangMatch?.[1];
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isValidLang"])(docLang) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isSameLang"])(docLang, primaryLanguage)) {
                const mainContent = result.replace(/<[^>]+>/g, ' ');
                const lang = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isValidLang"])(primaryLanguage) && primaryLanguage !== 'en' ? primaryLanguage : (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["detectLanguage"])(mainContent);
                const languageInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getLanguageInfo"])(lang || '');
                const newLangAttr = ` lang="${lang}"`;
                const newXmlLangAttr = ` xml:lang="${lang}"`;
                const dirAttr = languageInfo?.direction === 'rtl' ? ' dir="rtl"' : '';
                attrs = langMatch ? attrs.replace(langRegex, newLangAttr) : attrs + newLangAttr + dirAttr;
                attrs = xmlLangMatch ? attrs.replace(xmlLangRegex, newXmlLangAttr) : attrs + newXmlLangAttr + dirAttr;
                result = result.replace(attrsMatch[0], `<html${attrs}>`);
            }
        } else {
            const lang = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["isValidLang"])(primaryLanguage) && primaryLanguage !== 'en' ? primaryLanguage : (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["detectLanguage"])(result.replace(/<[^>]+>/g, ' '));
            const languageInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$lang$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getLanguageInfo"])(lang || '');
            const dirAttr = languageInfo?.direction === 'rtl' ? ' dir="rtl"' : '';
            const newAttrs = ` lang="${lang}" xml:lang="${lang}" ${dirAttr}`;
            result = result.replace(/<html>/i, `<html${newAttrs}>`);
        }
        return result;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/punctuation.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "punctuationTransformer",
    ()=>punctuationTransformer
]);
const verticalQuotationsMapHans = {
    '“': '﹃',
    '”': '﹄',
    '‘': '﹁',
    '’': '﹂',
    '「': '﹁',
    '」': '﹂',
    '『': '﹃',
    '』': '﹄'
};
const verticalQuotationsMapHant = {
    '“': '﹁',
    '”': '﹂',
    '‘': '﹃',
    '’': '﹄',
    '「': '﹁',
    '」': '﹂',
    '『': '﹃',
    '』': '﹄'
};
const quotationsMapHans2Hant = {
    '“': '「',
    '”': '」',
    '‘': '『',
    '’': '』',
    '﹃': '﹁',
    '﹄': '﹂',
    '﹁': '﹃',
    '﹂': '﹄'
};
const punctuationTransformer = {
    name: 'punctuation',
    transform: async (ctx)=>{
        if (!ctx.viewSettings.replaceQuotationMarks) return ctx.content;
        let result = ctx.content;
        const convertChineseVariant = ctx.viewSettings.convertChineseVariant;
        const reversePunctuationTransform = ctx.reversePunctuationTransform || false;
        const shouldConvertChineseVariants = convertChineseVariant && convertChineseVariant !== 'none';
        if (shouldConvertChineseVariants) {
            for (const [s, t] of Object.entries(quotationsMapHans2Hant)){
                const shouldReverse = reversePunctuationTransform !== convertChineseVariant.includes('2s');
                const [from, to] = shouldReverse ? [
                    t,
                    s
                ] : [
                    s,
                    t
                ];
                result = result.replace(new RegExp(from, 'g'), to);
            }
        }
        const shouldTransformVertical = ctx.viewSettings.vertical;
        if (shouldTransformVertical) {
            const traditionalChineseLocales = [
                'zh-Hant',
                'zh-TW',
                'zh_TW'
            ];
            let punctuationMap = verticalQuotationsMapHans;
            if (traditionalChineseLocales.includes(ctx.primaryLanguage || '') || traditionalChineseLocales.includes(ctx.userLocale)) {
                punctuationMap = verticalQuotationsMapHant;
            }
            for (const [original, vertical] of Object.entries(punctuationMap)){
                if (ctx.reversePunctuationTransform) {
                    result = result.replace(new RegExp(vertical, 'g'), original);
                } else {
                    result = result.replace(new RegExp(original, 'g'), vertical);
                }
            }
        }
        return result;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/whitespace.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "whitespaceTransformer",
    ()=>whitespaceTransformer
]);
const whitespaceTransformer = {
    name: 'whitespace',
    transform: async (ctx)=>{
        const viewSettings = ctx.viewSettings;
        if (viewSettings.overrideLayout) {
            const cleaned = ctx.content// Replace &nbsp; but skip literal "&amp;nbsp;"
            .replace(/(&amp;)?&nbsp;/g, (match, amp)=>amp ? match : ' ')// Replace literal non-breaking space characters (U+00A0) with normal spaces
            .replace(/\u00A0/g, ' ')// Collapse consecutive spaces into one
            .replace(/ {2,}/g, ' ');
            return cleaned;
        } else {
            return ctx.content;
        }
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/sanitizer.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sanitizerTransformer",
    ()=>sanitizerTransformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$dompurify$40$3$2e$3$2e$0$2f$node_modules$2f$dompurify$2f$dist$2f$purify$2e$es$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/dompurify@3.3.0/node_modules/dompurify/dist/purify.es.mjs [client] (ecmascript)");
;
const sanitizerTransformer = {
    name: 'sanitizer',
    transform: async (ctx)=>{
        const allowScript = ctx.viewSettings.allowScript;
        if (allowScript) return ctx.content;
        const result = ctx.content.replaceAll('&nbsp;', '&#160;');
        const sanitized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f$dompurify$40$3$2e$3$2e$0$2f$node_modules$2f$dompurify$2f$dist$2f$purify$2e$es$2e$mjs__$5b$client$5d$__$28$ecmascript$29$__["default"].sanitize(result, {
            WHOLE_DOCUMENT: true,
            FORBID_TAGS: [
                'script'
            ],
            ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|blob|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
            ADD_TAGS: [
                'link',
                'meta'
            ],
            ADD_ATTR: (attributeName)=>{
                const attrWhitelist = [
                    'xmlns',
                    'http-equiv',
                    'content',
                    'charset',
                    'link',
                    'vlink',
                    'imt-state',
                    'data-wr-footernote',
                    'zy-footnote'
                ];
                return attrWhitelist.includes(attributeName) || attributeName.startsWith('xml:') || attributeName.startsWith('xmlns:') || attributeName.startsWith('epub:');
            },
            RETURN_DOM: true
        });
        const serializer = new XMLSerializer();
        let serialized = serializer.serializeToString(sanitized);
        serialized = serialized.replaceAll('&#160;', '&nbsp;').replaceAll('\u00A0', '&nbsp;');
        serialized = '<?xml version="1.0" encoding="utf-8"?>' + serialized;
        serialized = serialized.replace(/(<head[^>]*>)/i, '\n$1');
        serialized = serialized.replace(/(<\/body>)(<\/html>)/i, '$1\n$2');
        // console.log(`Sanitizer diff:\n${diff(result, serialized)}`);
        return serialized;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/simplecc.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "simpleccTransformer",
    ()=>simpleccTransformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$simplecc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/simplecc.ts [client] (ecmascript)");
;
const simpleccTransformer = {
    name: 'simplecc',
    transform: async (ctx)=>{
        const convertChineseVariant = ctx.viewSettings.convertChineseVariant;
        if (!convertChineseVariant || convertChineseVariant === 'none') {
            return ctx.content;
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$simplecc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["initSimpleCC"])();
        const parser = new DOMParser();
        const doc = parser.parseFromString(ctx.content, 'text/html');
        const walker = document.createTreeWalker(doc.body || doc.documentElement, NodeFilter.SHOW_TEXT, {
            acceptNode: (node)=>{
                const parent = node.parentElement;
                if (parent && (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE')) {
                    return NodeFilter.FILTER_REJECT;
                }
                return node.textContent?.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
            }
        });
        const textNodes = [];
        let currentNode;
        while(currentNode = walker.nextNode()){
            textNodes.push(currentNode);
        }
        for (const textNode of textNodes){
            if (textNode.textContent) {
                textNode.textContent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$simplecc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["runSimpleCC"])(textNode.textContent, convertChineseVariant);
            }
        }
        const serializer = new XMLSerializer();
        return serializer.serializeToString(doc);
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/style.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "styleTransformer",
    ()=>styleTransformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$style$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/style.ts [client] (ecmascript)");
;
const styleTransformer = {
    name: 'style',
    transform: async (ctx)=>{
        let result = ctx.content;
        const styleMatches = [
            ...result.matchAll(/<style[^>]*>([\s\S]*?)<\/style>/gi)
        ];
        for (const match of styleMatches){
            const [full, css] = match;
            const transformed = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$style$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["transformStylesheet"])(css, ctx.width || window.innerWidth, ctx.height || window.innerHeight, ctx.viewSettings.vertical);
            result = result.replace(full, `<style>${transformed}</style>`);
        }
        return result;
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/proofread.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "proofreadTransformer",
    ()=>proofreadTransformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$foliate$2d$js$2f$epubcfi$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/foliate-js/epubcfi.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$settingsStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/store/settingsStore.ts [client] (ecmascript)");
;
;
const isUnicodeWordChar = (char)=>/[\p{L}\p{N}_]/u.test(char || '');
const hasUnicodeChars = (text)=>/[^\x00-\x7F]/.test(text);
// Scripts that don't use spaces between words (no word boundaries)
// CJK: Chinese, Japanese, Korean
// Thai, Lao, Khmer, Myanmar, Tibetan
const NO_WORD_BOUNDARY_RANGES = [
    '\u4E00-\u9FFF',
    '\u3400-\u4DBF',
    '\u3000-\u303F',
    '\uFF00-\uFFEF',
    '\u3040-\u309F',
    '\u30A0-\u30FF',
    '\uAC00-\uD7AF',
    '\u0E00-\u0E7F',
    '\u0E80-\u0EFF',
    '\u1780-\u17FF',
    '\u1000-\u109F',
    '\u0F00-\u0FFF'
].join('');
const isNoWordBoundaryChar = (char)=>new RegExp(`[${NO_WORD_BOUNDARY_RANGES}]`).test(char || '');
const isPureNoWordBoundaryScript = (text)=>new RegExp(`^[${NO_WORD_BOUNDARY_RANGES}]+$`).test(text);
function normalizePattern(pattern, isRegex, caseSensitive = true) {
    const hasUnicode = hasUnicodeChars(pattern);
    let flags = hasUnicode ? 'ug' : 'g';
    if (!caseSensitive) flags += 'i';
    if (isRegex) {
        const source = pattern.includes('\\b') || hasUnicode ? pattern : `\\b${pattern}\\b`;
        return {
            source,
            flags
        };
    }
    const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    if (hasUnicode) {
        return {
            source: escaped,
            flags
        };
    }
    const startsWithPunctuation = /^[^\w\s]/.test(pattern);
    const endsWithPunctuation = /[^\w\s]$/.test(pattern);
    if (startsWithPunctuation || endsWithPunctuation) {
        const wordMatch = pattern.match(/[\w]+/);
        if (!wordMatch) return {
            source: escaped,
            flags
        };
        const wordPart = wordMatch[0];
        const wordStart = pattern.indexOf(wordPart);
        const wordEnd = wordStart + wordPart.length;
        const wordEscaped = wordPart.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const beforeWord = escaped.substring(0, wordStart);
        const afterWord = escaped.substring(wordEnd);
        return {
            source: `${beforeWord}\\b${wordEscaped}\\b${afterWord}`,
            flags
        };
    }
    return {
        source: `\\b${escaped}\\b`,
        flags
    };
}
function isValidMatch(text, match, rule) {
    if (!rule.isRegex) {
        const isCaseSensitive = rule.caseSensitive !== false;
        const isExactMatch = isCaseSensitive ? match[0] === rule.pattern : match[0].toLowerCase() === rule.pattern.toLowerCase();
        if (!isExactMatch) return false;
    }
    // Skip word boundary check for scripts without word boundaries (CJK, Thai, Lao, Khmer, Myanmar, Tibetan)
    if (hasUnicodeChars(rule.pattern) && !isPureNoWordBoundaryScript(rule.pattern)) {
        const charBefore = text[match.index - 1] ?? '';
        const charAfter = text[match.index + match[0].length] ?? '';
        // Only check word boundaries if adjacent chars are from scripts that use word boundaries
        if (!isNoWordBoundaryChar(charBefore) && !isNoWordBoundaryChar(charAfter)) {
            if (isUnicodeWordChar(charBefore) || isUnicodeWordChar(charAfter)) {
                return false;
            }
        }
    }
    return true;
}
function applyReplacementMulti(textNodes, rule) {
    let regex;
    try {
        regex = new RegExp(rule.normalizedPattern.source, rule.normalizedPattern.flags);
    } catch  {
        return;
    }
    for (const textNode of textNodes){
        if (!textNode.textContent) continue;
        let text = textNode.textContent;
        const matches = [];
        let match;
        while((match = regex.exec(text)) !== null){
            if (!isValidMatch(text, match, rule)) continue;
            matches.push({
                index: match.index,
                length: match[0].length
            });
        }
        if (matches.length === 0) continue;
        for(let i = matches.length - 1; i >= 0; i--){
            const m = matches[i];
            text = text.slice(0, m.index) + rule.replacement + text.slice(m.index + m.length);
        }
        textNode.textContent = text;
    }
}
function applyReplacementSingle(doc, rule) {
    let regex;
    try {
        regex = new RegExp(rule.normalizedPattern.source, rule.normalizedPattern.flags);
    } catch  {
        return;
    }
    const parts = __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$foliate$2d$js$2f$epubcfi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["parse"](rule.cfi);
    if (parts.parent) {
        parts.parent.shift();
        const range = __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$foliate$2d$js$2f$epubcfi$2e$js__$5b$client$5d$__$28$ecmascript$29$__["toRange"](doc, parts);
        if (range) {
            const startContainer = range.startContainer;
            const endContainer = range.endContainer;
            if (startContainer === endContainer && startContainer.nodeType === Node.TEXT_NODE) {
                const textNode = startContainer;
                const text = textNode.textContent || '';
                const startOffset = range.startOffset;
                const endOffset = range.endOffset;
                // Add 32-char tolerance buffer around the selection
                const bufferSize = 32;
                const bufferStart = Math.max(0, startOffset - bufferSize);
                const bufferEnd = Math.min(text.length, endOffset + bufferSize);
                const bufferedText = text.slice(bufferStart, bufferEnd);
                const selectedText = text.slice(startOffset, endOffset);
                const match = regex.exec(bufferedText);
                if (match && isValidMatch(selectedText, match, rule)) {
                    const matchStartInBuffer = match.index;
                    const matchStartInText = bufferStart + matchStartInBuffer;
                    const matchEnd = matchStartInText + match[0].length;
                    if (matchEnd >= startOffset - bufferSize && matchStartInText <= endOffset + bufferSize) {
                        const newText = text.slice(0, matchStartInText) + rule.replacement + text.slice(matchEnd);
                        textNode.textContent = newText;
                        return;
                    }
                }
            }
        }
    }
}
function getTextNodes(doc) {
    const walker = document.createTreeWalker(doc.body || doc.documentElement, NodeFilter.SHOW_TEXT, {
        acceptNode: (node)=>{
            const parent = node.parentElement;
            if (parent?.tagName === 'SCRIPT' || parent?.tagName === 'STYLE') {
                return NodeFilter.FILTER_REJECT;
            }
            return node.textContent?.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        }
    });
    const textNodes = [];
    let node;
    while(node = walker.nextNode()){
        textNodes.push(node);
    }
    return textNodes;
}
const proofreadTransformer = {
    name: 'proofread',
    transform: async (ctx, options)=>{
        const { docType = 'text/html', onlyForTTS = false } = options || {};
        const globalRules = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$store$2f$settingsStore$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["useSettingsStore"].getState().settings?.globalViewSettings?.proofreadRules;
        const bookRules = ctx.viewSettings.proofreadRules;
        const merged = [
            ...globalRules ?? [],
            ...bookRules ?? []
        ].sort((a, b)=>(a.order ?? 0) - (b.order ?? 0));
        if (!merged.length) return ctx.content;
        const processed = merged.filter((r)=>r.enabled && r.pattern.trim()).filter((r)=>onlyForTTS ? r.onlyForTTS : !r.onlyForTTS).map((r)=>({
                ...r,
                normalizedPattern: normalizePattern(r.pattern, r.isRegex, r.caseSensitive !== false)
            }));
        if (!processed.length) return ctx.content;
        const parser = new DOMParser();
        const doc = parser.parseFromString(ctx.content, docType);
        const textNodes = getTextNodes(doc);
        const byScope = {
            selection: processed.filter((r)=>r.scope === 'selection'),
            book: processed.filter((r)=>r.scope === 'book'),
            library: processed.filter((r)=>r.scope === 'library')
        };
        const ordered = [
            ...byScope.selection,
            ...byScope.book,
            ...byScope.library
        ];
        for (const rule of ordered){
            if (rule.scope === 'selection') {
                const ruleBase = rule.sectionHref?.split('#')[0];
                const ctxBase = ctx.sectionHref?.split('#')[0];
                if (ctxBase !== ruleBase) continue;
            }
            if (rule.scope === 'selection') {
                applyReplacementSingle(doc, rule);
            } else {
                applyReplacementMulti(textNodes, rule);
            }
        }
        return new XMLSerializer().serializeToString(doc);
    }
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformers/index.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "availableTransformers",
    ()=>availableTransformers
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$footnote$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/footnote.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$language$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/language.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$punctuation$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/punctuation.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$whitespace$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/whitespace.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$sanitizer$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/sanitizer.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$simplecc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/simplecc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$style$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/style.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$proofread$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/proofread.ts [client] (ecmascript)");
;
;
;
;
;
;
;
;
const availableTransformers = [
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$punctuation$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["punctuationTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$footnote$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["footnoteTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$language$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["languageTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$style$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["styleTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$whitespace$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["whitespaceTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$sanitizer$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["sanitizerTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$simplecc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["simpleccTransformer"],
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$proofread$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["proofreadTransformer"]
];
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/transformService.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transformContent",
    ()=>transformContent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$index$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/transformers/index.ts [client] (ecmascript)");
;
const transformContent = async (ctx)=>{
    let transformed = ctx.content;
    const activeTransformers = ctx.transformers.map((name)=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$transformers$2f$index$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["availableTransformers"].find((transformer)=>transformer.name === name)).filter((transformer)=>!!transformer);
    for (const transformer of activeTransformers){
        try {
            transformed = await transformer.transform({
                ...ctx,
                content: transformed
            });
        } catch (error) {
            console.warn(`Error in transformer ${transformer.name}:`, error);
        }
    }
    return transformed;
};
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/types.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/TTSClient.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/TTSData.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SILENCE_DATA",
    ()=>SILENCE_DATA,
    "WEB_SPEECH_BLACKLISTED_VOICES",
    ()=>WEB_SPEECH_BLACKLISTED_VOICES
]);
const SILENCE_DATA = 'data:audio/mp3;base64,//MkxAAHiAICWABElBeKPL/RANb2w+yiT1g/gTok//lP/W/l3h8QO/OCdCqCW2Cw//MkxAQHkAIWUAhEmAQXWUOFW2dxPu//9mr60ElY5sseQ+xxesmHKtZr7bsqqX2L//MkxAgFwAYiQAhEAC2hq22d3///9FTV6tA36JdgBJoOGgc+7qvqej5Zu7/7uI9l//MkxBQHAAYi8AhEAO193vt9KGOq+6qcT7hhfN5FTInmwk8RkqKImTM55pRQHQSq//MkxBsGkgoIAABHhTACIJLf99nVI///yuW1uBqWfEu7CgNPWGpUadBmZ////4sL//MkxCMHMAH9iABEmAsKioqKigsLCwtVTEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVV//MkxCkECAUYCAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
const WEB_SPEECH_BLACKLISTED_VOICES = [
    'Albert',
    'Bad News',
    'Bahh',
    'Bells',
    'Boing',
    'Bubbles',
    'Cellos',
    'Eddy',
    'Flo',
    'Fred',
    'Good News',
    'Grandma',
    'Grandpa',
    'Jester',
    'Junior',
    'Kathy',
    'Organ',
    'Ralph',
    'Reed',
    'Rocko',
    'Sandy',
    'Shelley',
    'Superstar',
    'Trinoids',
    'Whisper',
    'Wobble',
    'Zarvox'
];
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/TTSUtils.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TTSUtils",
    ()=>TTSUtils
]);
class TTSUtils {
    static LOCAL_STORAGE_KEY = 'ttsPreferredVoices';
    static PREFERRED_CLIENT_KEY = 'preferredClient';
    static normalizeLanguage(language) {
        if (!language) return 'n/a';
        return language.toLowerCase().slice(0, 2);
    }
    static setPreferredClient(engine) {
        if (!engine) return;
        const preferences = this.getPreferences();
        preferences[this.PREFERRED_CLIENT_KEY] = engine;
        localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(preferences));
    }
    static setPreferredVoice(engine, language, voiceId) {
        if (!engine || !language || !voiceId) return;
        const preferences = this.getPreferences();
        const lang = this.normalizeLanguage(language);
        preferences[`${engine}-${lang}`] = voiceId;
        localStorage.setItem(this.LOCAL_STORAGE_KEY, JSON.stringify(preferences));
    }
    static getPreferredClient() {
        const preferences = this.getPreferences();
        return preferences[this.PREFERRED_CLIENT_KEY] || null;
    }
    static getPreferredVoice(engine, language) {
        const preferences = this.getPreferences();
        const lang = this.normalizeLanguage(language);
        return preferences[`${engine}-${lang}`] || null;
    }
    static getPreferences() {
        const storedPreferences = localStorage.getItem(this.LOCAL_STORAGE_KEY);
        return storedPreferences ? JSON.parse(storedPreferences) : {};
    }
    static sortVoicesFunc(a, b) {
        const aRegion = a.lang.split('-')[1] || '';
        const bRegion = b.lang.split('-')[1] || '';
        if (aRegion === bRegion) {
            return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
        }
        if (aRegion === 'CN') return -1;
        if (bRegion === 'CN') return 1;
        if (aRegion === 'TW') return -1;
        if (bRegion === 'TW') return 1;
        if (aRegion === 'HK') return -1;
        if (bRegion === 'HK') return 1;
        if (aRegion === 'US') return -1;
        if (bRegion === 'US') return 1;
        if (aRegion === 'GB') return -1;
        if (bRegion === 'GB') return 1;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/WebSpeechClient.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebSpeechClient",
    ()=>WebSpeechClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/ssml.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSData$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSData.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSUtils.ts [client] (ecmascript)");
;
;
;
;
async function* speakWithMarks(ssml, primaryLang, getRate, getPitch, getVoice, setCurrentVoice, setSpeakingLang, dispatchSpeakMark) {
    const { marks } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["parseSSMLMarks"])(ssml, primaryLang);
    const synth = window.speechSynthesis;
    const utterance = new SpeechSynthesisUtterance();
    for (const mark of marks){
        const { language: voiceLang } = mark;
        dispatchSpeakMark(mark);
        utterance.text = mark.text;
        utterance.rate = getRate();
        utterance.pitch = getPitch();
        const voice = await getVoice(voiceLang);
        if (voice) {
            utterance.voice = voice;
            setCurrentVoice(voice.voiceURI);
        }
        if (voiceLang) {
            utterance.lang = voiceLang;
            setSpeakingLang(voiceLang);
        }
        yield {
            type: 'boundary',
            speaking: true,
            name: 'sentence',
            mark: mark.name
        };
        const result = await new Promise((resolve)=>{
            utterance.onend = ()=>resolve({
                    type: 'end',
                    speaking: false
                });
            utterance.onerror = (event)=>resolve({
                    type: 'error',
                    speaking: false,
                    error: event.error
                });
            synth.speak(utterance);
        });
        yield result;
        if (result.type === 'error') {
            break;
        }
    }
}
class WebSpeechClient {
    name = 'web-speech';
    initialized = false;
    controller;
    #voices = [];
    #primaryLang = 'en';
    #speakingLang = '';
    #currentVoiceId = '';
    #rate = 1.0;
    #pitch = 1.0;
    #synth = window.speechSynthesis;
    constructor(controller){
        this.controller = controller;
    }
    async init() {
        if (!this.#synth) {
            this.initialized = false;
            return this.initialized;
        }
        await new Promise((resolve)=>{
            const populateVoices = ()=>{
                this.#voices = this.#synth.getVoices().map((voice)=>{
                    const webSpeechVoice = voice;
                    webSpeechVoice.id = voice.voiceURI || voice.name;
                    return webSpeechVoice;
                });
                // console.log('Voices', this.#voices);
                resolve();
            };
            if (this.#synth.getVoices().length > 0) {
                populateVoices();
            } else if (this.#synth.onvoiceschanged !== undefined) {
                this.#synth.onvoiceschanged = populateVoices;
            } else {
                console.warn('Voiceschanged event not supported.');
                resolve();
            }
        });
        this.initialized = true;
        return this.initialized;
    }
    getVoiceIdFromLang = async (lang)=>{
        const preferredVoiceId = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].getPreferredVoice(this.name, lang);
        const preferredVoice = this.#voices.find((v)=>v.id === preferredVoiceId);
        const defaultVoice = preferredVoice ? preferredVoice : (await this.getVoices(lang))[0]?.voices[0] || null;
        return defaultVoice?.id || this.#currentVoiceId || '';
    };
    getWebSpeechVoiceFromLang = async (lang)=>{
        const voiceId = await this.getVoiceIdFromLang(lang);
        return this.#voices.find((v)=>v.id === voiceId) || null;
    };
    async *speak(ssml, signal, preload = false) {
        // no need to preload for web speech
        if (preload) return;
        for await (const ev of speakWithMarks(ssml, this.#primaryLang, ()=>this.#rate, ()=>this.#pitch, this.getWebSpeechVoiceFromLang, (voiceId)=>this.#currentVoiceId = voiceId, (lang)=>this.#speakingLang = lang, (mark)=>this.controller?.dispatchSpeakMark(mark))){
            if (signal.aborted) {
                console.log('TTS aborted');
                yield {
                    code: 'error',
                    message: 'Aborted'
                };
                return;
            }
            if (ev.type === 'boundary') {
                yield {
                    code: 'boundary',
                    mark: ev.mark ?? '',
                    message: `${ev.name ?? 'Unknown'} ${ev.charIndex ?? 0}/${ev.charLength ?? 0}`
                };
            } else if (ev.type === 'error') {
                yield {
                    code: 'error',
                    message: ev.error ?? 'Unknown error'
                };
            } else if (ev.type === 'end') {
                yield {
                    code: 'end',
                    message: 'Speech finished'
                };
            }
        }
    }
    async pause() {
        this.#synth.pause();
        return true;
    }
    async resume() {
        this.#synth.resume();
        return true;
    }
    async stop() {
        this.#synth.cancel();
    }
    setPrimaryLang(lang) {
        this.#primaryLang = lang;
    }
    async setRate(rate) {
        // The Web Speech API uses utterance.rate in [0.1 .. 10],
        this.#rate = rate;
    }
    async setPitch(pitch) {
        // The Web Speech API uses pitch in [0 .. 2].
        this.#pitch = pitch;
    }
    async setVoice(voiceId) {
        const selectedVoice = this.#voices.find((v)=>v.id === voiceId);
        if (selectedVoice) {
            this.#currentVoiceId = selectedVoice.id;
        }
    }
    async getAllVoices() {
        const voices = this.#voices.map((voice)=>{
            return {
                id: voice.id,
                name: voice.name,
                lang: voice.lang,
                disabled: !this.initialized
            };
        });
        return voices;
    }
    async getVoices(lang) {
        const locale = lang === 'en' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getUserLocale"])(lang) || lang : lang;
        const isValidVoice = (id)=>{
            return !id.includes('com.apple') || id.includes('com.apple.voice.compact');
        };
        const isNotBlacklisted = (voice)=>{
            return __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSData$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["WEB_SPEECH_BLACKLISTED_VOICES"].some((name)=>voice.name.includes(name)) === false;
        };
        const filteredVoices = this.#voices.filter((voice)=>voice.lang.startsWith(locale) || lang === 'en' && [
                'en-US',
                'en-GB'
            ].includes(voice.lang)).filter((voice)=>isValidVoice(voice.voiceURI || '')).filter(isNotBlacklisted);
        const seenIds = new Set();
        const voices = filteredVoices.map((voice)=>({
                id: voice.voiceURI,
                name: voice.name,
                lang: voice.lang
            })).filter((voice)=>{
            if (seenIds.has(voice.id)) {
                return false;
            }
            seenIds.add(voice.id);
            return true;
        });
        voices.forEach((voice)=>{
            voice.disabled = !this.initialized;
        });
        const voicesGroup = {
            id: 'web-speech-api',
            name: 'Web TTS',
            voices: voices.sort(__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].sortVoicesFunc),
            disabled: !this.initialized || voices.length === 0
        };
        return [
            voicesGroup
        ];
    }
    getGranularities() {
        // currently only support sentence boundary and disable word boundary as changing voice
        // in the middle of speech is not possible for different granularities
        return [
            'sentence'
        ];
    }
    getVoiceId() {
        return this.#currentVoiceId;
    }
    getSpeakingLang() {
        return this.#speakingLang;
    }
    async shutdown() {
        this.initialized = false;
        this.#voices = [];
        await this.stop();
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/EdgeTTSClient.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EdgeTTSClient",
    ()=>EdgeTTSClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$libs$2f$edgeTTS$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/libs/edgeTTS.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/ssml.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSUtils.ts [client] (ecmascript)");
;
;
;
;
class EdgeTTSClient {
    name = 'edge-tts';
    initialized = false;
    controller;
    #voices = [];
    #primaryLang = 'en';
    #speakingLang = '';
    #currentVoiceId = '';
    #rate = 1.0;
    #pitch = 1.0;
    #edgeTTS = null;
    #audioElement = null;
    #isPlaying = false;
    #pausedAt = 0;
    #startedAt = 0;
    #fadeCompensation = null;
    constructor(controller){
        this.controller = controller;
    }
    async init(protocol = 'wss') {
        this.#edgeTTS = new __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$libs$2f$edgeTTS$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["EdgeSpeechTTS"](protocol);
        this.#voices = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$libs$2f$edgeTTS$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["EdgeSpeechTTS"].voices;
        try {
            await this.#edgeTTS.create({
                lang: 'en',
                text: 'test',
                voice: 'en-US-AriaNeural',
                rate: 1.0,
                pitch: 1.0
            });
            this.initialized = true;
        } catch  {
            if (protocol === 'wss') {
                if (this.controller?.isAuthenticated) {
                    await this.init('https');
                } else {
                    this.controller?.dispatchEvent(new CustomEvent('tts-need-auth'));
                }
            } else {
                this.initialized = false;
            }
        }
        return this.initialized;
    }
    getPayload = (lang, text, voiceId)=>{
        return {
            lang,
            text,
            voice: voiceId,
            rate: 1.0,
            pitch: this.#pitch
        };
    };
    getVoiceIdFromLang = async (lang)=>{
        const preferredVoiceId = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].getPreferredVoice(this.name, lang);
        const preferredVoice = this.#voices.find((v)=>v.id === preferredVoiceId);
        if (preferredVoice) return preferredVoice.id;
        const availableVoices = (await this.getVoices(lang))[0]?.voices || [];
        const defaultVoice = availableVoices[0] || null;
        if (defaultVoice?.id === 'en-US-AnaNeural') return 'en-US-AriaNeural'; // avoid using AnaNeural as default
        return defaultVoice?.id || this.#currentVoiceId || 'en-US-AriaNeural';
    };
    async *speak(ssml, signal, preload = false) {
        const { marks } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["parseSSMLMarks"])(ssml, this.#primaryLang);
        if (preload) {
            // preload the first 2 marks immediately and the rest in the background
            const maxImmediate = 2;
            for(let i = 0; i < Math.min(maxImmediate, marks.length); i++){
                if (signal.aborted) break;
                const mark = marks[i];
                const { language: voiceLang } = mark;
                const voiceId = await this.getVoiceIdFromLang(voiceLang);
                this.#currentVoiceId = voiceId;
                await this.#edgeTTS?.createAudioUrl(this.getPayload(voiceLang, mark.text, voiceId)).catch((err)=>{
                    console.warn('Error preloading mark', i, err);
                });
            }
            if (marks.length > maxImmediate) {
                (async ()=>{
                    for(let i = maxImmediate; i < marks.length; i++){
                        const mark = marks[i];
                        try {
                            if (signal.aborted) break;
                            const { language: voiceLang } = mark;
                            const voiceId = await this.getVoiceIdFromLang(voiceLang);
                            await this.#edgeTTS?.createAudioUrl(this.getPayload(voiceLang, mark.text, voiceId));
                        } catch (err) {
                            console.warn('Error preloading mark (bg)', i, err);
                        }
                    }
                })();
            }
            yield {
                code: 'end',
                message: 'Preload finished'
            };
            return;
        }
        await this.stopInternal();
        // Reuse the same Audio element inside the ssml session
        if (!this.#audioElement) {
            this.#audioElement = new Audio();
        }
        const audio = this.#audioElement;
        audio.setAttribute('x-webkit-airplay', 'deny');
        audio.preload = 'auto';
        for (const mark of marks){
            this.controller?.dispatchSpeakMark(mark);
            let abortHandler = null;
            try {
                const { language: voiceLang } = mark;
                const voiceId = await this.getVoiceIdFromLang(voiceLang);
                this.#speakingLang = voiceLang;
                const audioUrl = await this.#edgeTTS?.createAudioUrl(this.getPayload(voiceLang, mark.text, voiceId));
                if (signal.aborted) {
                    yield {
                        code: 'error',
                        message: 'Aborted'
                    };
                    break;
                }
                yield {
                    code: 'boundary',
                    message: `Start chunk: ${mark.name}`,
                    mark: mark.name
                };
                const result = await new Promise((resolve)=>{
                    const cleanUp = ()=>{
                        audio.onended = null;
                        audio.onerror = null;
                        audio.src = '';
                    };
                    abortHandler = ()=>{
                        cleanUp();
                        resolve({
                            code: 'error',
                            message: 'Aborted'
                        });
                    };
                    if (signal.aborted) {
                        abortHandler();
                        return;
                    } else {
                        signal.addEventListener('abort', abortHandler);
                    }
                    audio.onended = ()=>{
                        cleanUp();
                        resolve({
                            code: 'end',
                            message: `Chunk finished: ${mark.name}`
                        });
                    };
                    audio.onerror = (e)=>{
                        cleanUp();
                        console.warn('Audio playback error:', e);
                        resolve({
                            code: 'error',
                            message: 'Audio playback error'
                        });
                    };
                    this.#isPlaying = true;
                    audio.src = audioUrl || '';
                    audio.play().then(()=>audio.playbackRate = this.#rate).catch((err)=>{
                        cleanUp();
                        console.error('Failed to play audio:', err);
                        resolve({
                            code: 'error',
                            message: 'Playback failed: ' + err.message
                        });
                    });
                });
                yield result;
            } catch (error) {
                if (error instanceof Error && error.message === 'No audio data received.') {
                    console.warn('No audio data received for:', mark.text);
                    yield {
                        code: 'end',
                        message: `Chunk finished: ${mark.name}`
                    };
                    continue;
                }
                const message = error instanceof Error ? error.message : String(error);
                console.warn('TTS error for mark:', mark.text, message);
                yield {
                    code: 'error',
                    message
                };
                break;
            } finally{
                if (abortHandler) {
                    signal.removeEventListener('abort', abortHandler);
                }
            }
        }
        await this.stopInternal();
    }
    async pause() {
        if (!this.#isPlaying || !this.#audioElement) return true;
        this.#pausedAt = this.#audioElement.currentTime - this.#startedAt;
        await this.#audioElement.pause();
        this.#isPlaying = false;
        return true;
    }
    #getFadeCompensation() {
        if (this.#fadeCompensation !== null) return this.#fadeCompensation;
        const userAgent = navigator.userAgent;
        const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(userAgent);
        if (isSafari || isIOS) {
            this.#fadeCompensation = 0.2;
        } else {
            this.#fadeCompensation = 0.0;
        }
        return this.#fadeCompensation;
    }
    async resume() {
        if (this.#isPlaying || !this.#audioElement) return true;
        const fadeCompensation = this.#getFadeCompensation();
        this.#audioElement.currentTime = Math.max(0, this.#audioElement.currentTime - fadeCompensation);
        await this.#audioElement.play();
        this.#isPlaying = true;
        this.#startedAt = this.#audioElement.currentTime - this.#pausedAt;
        return true;
    }
    async stop() {
        await this.stopInternal();
    }
    async stopInternal() {
        this.#isPlaying = false;
        this.#pausedAt = 0;
        this.#startedAt = 0;
        if (this.#audioElement) {
            this.#audioElement.pause();
            this.#audioElement.currentTime = 0;
            if (this.#audioElement?.onended) {
                this.#audioElement.onended(new Event('stopped'));
            }
            this.#audioElement.src = '';
        }
    }
    async setRate(rate) {
        // The Edge TTS API uses rate in [0.5 .. 2.0].
        this.#rate = rate;
    }
    async setPitch(pitch) {
        // The Edge TTS API uses pitch in [0.5 .. 1.5].
        this.#pitch = pitch;
    }
    async setVoice(voice) {
        const selectedVoice = this.#voices.find((v)=>v.id === voice);
        if (selectedVoice) {
            this.#currentVoiceId = selectedVoice.id;
        }
    }
    async getAllVoices() {
        this.#voices.forEach((voice)=>{
            voice.disabled = !this.initialized;
        });
        return this.#voices;
    }
    async getVoices(lang) {
        const locale = lang === 'en' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getUserLocale"])(lang) || lang : lang;
        const voices = await this.getAllVoices();
        const filteredVoices = voices.filter((v)=>v.lang.startsWith(locale) || lang === 'en' && [
                'en-US',
                'en-GB'
            ].includes(v.lang));
        const voicesGroup = {
            id: 'edge-tts',
            name: 'Edge TTS',
            voices: filteredVoices.sort(__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].sortVoicesFunc),
            disabled: !this.initialized || filteredVoices.length === 0
        };
        return [
            voicesGroup
        ];
    }
    setPrimaryLang(lang) {
        this.#primaryLang = lang;
    }
    getGranularities() {
        return [
            'sentence'
        ];
    }
    getVoiceId() {
        return this.#currentVoiceId;
    }
    getSpeakingLang() {
        return this.#speakingLang;
    }
    async shutdown() {
        this.initialized = false;
        this.#audioElement = null;
        this.#voices = [];
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/NativeTTSClient.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NativeTTSClient",
    ()=>NativeTTSClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@tauri-apps+api@2.9.1/node_modules/@tauri-apps/api/core.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/misc.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/ssml.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSUtils.ts [client] (ecmascript)");
;
;
;
;
;
;
const TTSEngines = {
    default: 'System TTS',
    msctts: 'Msc TTS',
    mstrans: 'MSTrans TTS',
    microsoft: 'Microsoft TTS',
    bytedance: 'ByteDance TTS',
    peiyinya: 'PeiYinYa TTS',
    huoshan: 'HuoShan TTS',
    sougou: 'Sougou TTS',
    xiaomi: 'XiaoMi TTS',
    bdetts: 'BDeTTS',
    bdotts: 'BDoTTS',
    vcstts: 'VcsTTS',
    isstts: 'IssTTS',
    xfpeiyin: 'XFPeiYin',
    azure: 'Azure TTS',
    edgetts: 'Edge TTS',
    google: 'Google TTS',
    gemini: 'Gemini TTS',
    weread: 'WeRead TTS',
    aispeech: 'Aispeech'
};
class NativeTTSClient {
    name = 'native-tts';
    initialized = false;
    controller;
    #voices = [];
    #primaryLang = 'en';
    #speakingLang = '';
    #currentVoiceId = '';
    #rate = 1.0;
    #pitch = 1.0;
    #eventListener = null;
    #activeUtterances = new Map();
    constructor(controller){
        this.controller = controller;
    }
    async setupEventListener() {
        try {
            if (this.#eventListener) return;
            this.#eventListener = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["addPluginListener"])('native-tts', 'tts_events', (event)=>{
                const { utteranceId, code, message, mark } = event;
                const utteranceData = this.#activeUtterances.get(utteranceId);
                if (!utteranceData) return;
                const ttsEvent = {
                    code,
                    message,
                    mark
                };
                utteranceData.eventQueue.push(ttsEvent);
                if (code === 'end' || code === 'error') {
                    utteranceData.finished = true;
                    if (utteranceData.resolver) {
                        utteranceData.resolver({
                            value: undefined,
                            done: true
                        });
                    }
                } else if (utteranceData.resolver) {
                    utteranceData.resolver({
                        value: ttsEvent,
                        done: false
                    });
                    utteranceData.resolver = null;
                }
            });
        } catch (error) {
            console.error('Failed to setup TTS event listener:', error);
        }
    }
    async init() {
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|init');
        this.initialized = result.success;
        if (this.initialized) {
            this.setupEventListener();
        }
        return this.initialized;
    }
    async *speakMark(mark, preload, signal) {
        if (preload) {
            yield {
                code: 'end',
                message: 'Dummy preload finished'
            };
            return;
        }
        const { language: voiceLang } = mark;
        const voiceId = await this.getVoiceIdFromLang(voiceLang);
        this.#currentVoiceId = voiceId;
        this.#speakingLang = voiceLang;
        await this.setVoice(voiceId);
        try {
            const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|speak', {
                payload: {
                    text: mark.text,
                    preload
                }
            });
            const utteranceId = result.utteranceId;
            this.#activeUtterances.set(utteranceId, {
                eventQueue: [],
                resolver: null,
                finished: false
            });
            const abortHandler = ()=>{
                const utteranceData = this.#activeUtterances.get(utteranceId);
                if (utteranceData && utteranceData.resolver) {
                    const error = {
                        code: 'error',
                        message: 'Aborted'
                    };
                    utteranceData.resolver({
                        value: error,
                        done: true
                    });
                    utteranceData.resolver = null;
                }
                this.stop();
            };
            signal.addEventListener('abort', abortHandler);
            try {
                while(true){
                    const utteranceData = this.#activeUtterances.get(utteranceId);
                    if (!utteranceData) break;
                    if (utteranceData.eventQueue.length > 0) {
                        const event = utteranceData.eventQueue.shift();
                        event.mark = mark.name;
                        yield event;
                        if (event.code === 'end' || event.code === 'error') {
                            break;
                        }
                    } else if (utteranceData.finished) {
                        break;
                    } else {
                        const eventPromise = new Promise((resolve)=>{
                            const utteranceData = this.#activeUtterances.get(utteranceId);
                            if (!utteranceData) return resolve();
                            utteranceData.resolver = (res)=>resolve(res.value?.code === 'error' ? res.value : undefined);
                        });
                        const timeoutPromise = new Promise((resolve)=>setTimeout(()=>resolve(null), 100));
                        const result = await Promise.race([
                            eventPromise,
                            timeoutPromise
                        ]);
                        if (result) yield result;
                    }
                    if (signal.aborted) {
                        break;
                    }
                }
            } finally{
                signal.removeEventListener('abort', abortHandler);
                this.#activeUtterances.delete(utteranceId);
            }
        } catch (error) {
            console.error('Failed to speak:', error);
            throw error;
        }
    }
    async *speak(ssml, signal, preload = false) {
        const { marks } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["parseSSMLMarks"])(ssml, this.#primaryLang);
        for (const mark of marks){
            this.controller?.dispatchSpeakMark(mark);
            for await (const ev of this.speakMark(mark, preload, signal)){
                if (signal.aborted) {
                    yield {
                        code: 'error',
                        message: 'Aborted'
                    };
                    return;
                }
                yield ev;
            }
        }
    }
    async getVoiceIdFromLang(lang) {
        const preferredVoiceId = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].getPreferredVoice(this.name, lang);
        const preferredVoice = this.#voices.find((v)=>v.id === preferredVoiceId);
        const defaultVoice = preferredVoice ? preferredVoice : (await this.getVoices(lang))[0]?.voices[0] || null;
        return defaultVoice?.id || '';
    }
    async pause() {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|pause');
        return false;
    }
    async resume() {
        // No-op for Android TextToSpeech
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|resume');
        return false;
    }
    async stop() {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|stop');
        this.#activeUtterances.clear();
    }
    async setRate(rate) {
        // Power the rate to match the EdgeTTS behavior
        this.#rate = parseFloat(Math.pow(rate, 2.5).toFixed(2));
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|set_rate', {
            payload: {
                rate: this.#rate
            }
        });
    }
    async setPitch(pitch) {
        this.#pitch = pitch;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|set_pitch', {
            payload: {
                pitch: this.#pitch
            }
        });
    }
    async setVoice(voice) {
        this.#currentVoiceId = voice;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|set_voice', {
            payload: {
                voice
            }
        });
    }
    async getAllVoices() {
        if (this.#voices.length > 0) {
            return this.#voices;
        }
        try {
            const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$tauri$2d$apps$2b$api$40$2$2e$9$2e$1$2f$node_modules$2f40$tauri$2d$apps$2f$api$2f$core$2e$js__$5b$client$5d$__$28$ecmascript$29$__["invoke"])('plugin:native-tts|get_all_voices');
            this.#voices = result.voices;
            return this.#voices;
        } catch (error) {
            console.error('Failed to get all voices:', error);
            return [];
        }
    }
    async getVoices(lang) {
        const locale = lang === 'en' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["getUserLocale"])(lang) || lang : lang;
        const voices = await this.getAllVoices();
        const filteredVoices = voices.filter((v)=>v.lang.startsWith(locale) || lang === 'en' && [
                'en-US',
                'en-GB'
            ].includes(v.lang));
        const voiceGroups = new Map();
        filteredVoices.forEach((voice)=>{
            const { name, lang } = voice;
            let groupId = voice.id.split('_')[0];
            if (groupId in TTSEngines) {
                voice.name = name.replace(`${groupId}_`, '').replace(`${lang}-`, '').replace('Neural', '').trim();
            } else {
                groupId = 'default';
            }
            voice.name = voice.name.replace('NOT_SET', (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$misc$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["stubTranslation"])('Default'));
            if (!voiceGroups.has(groupId)) {
                voiceGroups.set(groupId, []);
            }
            voiceGroups.get(groupId).push(voice);
        });
        return Array.from(voiceGroups.entries()).map(([groupId, voices])=>({
                id: groupId,
                name: TTSEngines[groupId] || groupId,
                voices: voices.sort(__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].sortVoicesFunc),
                disabled: !this.initialized || voices.length === 0
            })).sort((a, b)=>{
            if (a.id === 'default') return -1;
            if (b.id === 'default') return 1;
            return a.id.localeCompare(b.id);
        });
    }
    setPrimaryLang(lang) {
        this.#primaryLang = lang;
    }
    getGranularities() {
        return [
            'sentence'
        ];
    }
    getVoiceId() {
        return this.#currentVoiceId;
    }
    getSpeakingLang() {
        return this.#speakingLang;
    }
    async shutdown() {
        if (this.#eventListener) {
            this.#eventListener.unregister();
            this.#eventListener = null;
        }
        await this.stop();
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/TTSController.ts [client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TTSController",
    ()=>TTSController
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/ssml.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$foliate$2d$js$2f$overlayer$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/packages/foliate-js/overlayer.js [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$node$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/utils/node.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$WebSpeechClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/WebSpeechClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$NativeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/NativeTTSClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$EdgeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/EdgeTTSClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSUtils.ts [client] (ecmascript)");
;
;
;
;
;
;
;
const HIGHLIGHT_KEY = 'tts-highlight';
class TTSController extends EventTarget {
    appService = null;
    view;
    isAuthenticated = false;
    preprocessCallback;
    #nossmlCnt = 0;
    #currentSpeakAbortController = null;
    #currentSpeakPromise = null;
    state = 'stopped';
    ttsLang = '';
    ttsRate = 1.0;
    ttsClient;
    ttsWebClient;
    ttsEdgeClient;
    ttsNativeClient = null;
    ttsWebVoices = [];
    ttsEdgeVoices = [];
    ttsNativeVoices = [];
    ttsTargetLang = '';
    options = {
        style: 'highlight',
        color: 'gray'
    };
    constructor(appService, view, isAuthenticated = false, preprocessCallback){
        super();
        this.ttsWebClient = new __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$WebSpeechClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["WebSpeechClient"](this);
        this.ttsEdgeClient = new __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$EdgeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["EdgeTTSClient"](this);
        // TODO: implement native TTS client for iOS and PC
        if (appService?.isAndroidApp) {
            this.ttsNativeClient = new __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$NativeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["NativeTTSClient"](this);
        }
        this.ttsClient = this.ttsWebClient;
        this.appService = appService;
        this.view = view;
        this.isAuthenticated = isAuthenticated;
        this.preprocessCallback = preprocessCallback;
    }
    async init() {
        const availableClients = [];
        if (await this.ttsEdgeClient.init()) {
            availableClients.push(this.ttsEdgeClient);
        }
        if (this.ttsNativeClient && await this.ttsNativeClient.init()) {
            availableClients.push(this.ttsNativeClient);
            this.ttsNativeVoices = await this.ttsNativeClient.getAllVoices();
        }
        if (await this.ttsWebClient.init()) {
            availableClients.push(this.ttsWebClient);
        }
        this.ttsClient = availableClients[0] || this.ttsWebClient;
        const preferredClientName = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].getPreferredClient();
        if (preferredClientName) {
            const preferredClient = availableClients.find((client)=>client.name === preferredClientName);
            if (preferredClient) {
                this.ttsClient = preferredClient;
            }
        }
        this.ttsWebVoices = await this.ttsWebClient.getAllVoices();
        this.ttsEdgeVoices = await this.ttsEdgeClient.getAllVoices();
    }
    #getHighlighter() {
        return (range)=>{
            const { overlayer } = this.view.renderer.getContents()[0];
            const { style, color } = this.options;
            overlayer?.remove(HIGHLIGHT_KEY);
            overlayer?.add(HIGHLIGHT_KEY, range, __TURBOPACK__imported__module__$5b$project$5d2f$packages$2f$foliate$2d$js$2f$overlayer$2e$js__$5b$client$5d$__$28$ecmascript$29$__["Overlayer"][style], {
                color
            });
        };
    }
    #clearHighlighter() {
        const { overlayer } = this.view.renderer.getContents()?.[0] || {};
        overlayer?.remove(HIGHLIGHT_KEY);
    }
    async initViewTTS(options) {
        if (options) {
            this.options.style = options.style;
            this.options.color = options.color;
        }
        let granularity = this.view.language.isCJK ? 'sentence' : 'word';
        const supportedGranularities = this.ttsClient.getGranularities();
        if (!supportedGranularities.includes(granularity)) {
            granularity = supportedGranularities[0];
        }
        await this.view.initTTS(granularity, (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$node$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["createRejectFilter"])({
            tags: [
                'rt'
            ],
            contents: [
                {
                    tag: 'a',
                    content: /^[\[\(]?[\*\d]+[\)\]]?$/
                }
            ]
        }), this.#getHighlighter());
    }
    async preloadSSML(ssml, signal) {
        if (!ssml) return;
        const iter = await this.ttsClient.speak(ssml, signal, true);
        for await (const _ of iter);
    }
    async preloadNextSSML(count = 4) {
        const tts = this.view.tts;
        if (!tts) return;
        let preloaded = 0;
        for(let i = 0; i < count; i++){
            const ssml = await this.#preprocessSSML(tts.next());
            this.preloadSSML(ssml, new AbortController().signal);
            if (ssml) preloaded++;
        }
        for(let i = 0; i < preloaded; i++){
            tts.prev();
        }
    }
    async #preprocessSSML(ssml) {
        if (!ssml) return;
        ssml = ssml.replace(/<emphasis[^>]*>([^<]+)<\/emphasis>/g, '$1').replace(/[–—]/g, ',').replace('<break/>', ' ').replace(/\.{3,}/g, '   ').replace(/……/g, '  ').replace(/\*/g, ' ').replace(/·/g, ' ');
        if (this.ttsTargetLang) {
            ssml = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["filterSSMLWithLang"])(ssml, this.ttsTargetLang);
        }
        if (this.preprocessCallback) {
            ssml = await this.preprocessCallback(ssml);
        }
        return ssml;
    }
    async #speak(ssml, oneTime = false) {
        await this.stop();
        this.#currentSpeakAbortController = new AbortController();
        const { signal } = this.#currentSpeakAbortController;
        this.#currentSpeakPromise = new Promise(async (resolve, reject)=>{
            try {
                console.log('TTS speak');
                this.state = 'playing';
                signal.addEventListener('abort', ()=>{
                    resolve();
                });
                ssml = await this.#preprocessSSML(await ssml);
                if (!ssml) {
                    this.#nossmlCnt++;
                    // FIXME: in case we are at the end of the book, need a better way to handle this
                    if (this.#nossmlCnt < 10 && this.state === 'playing' && !oneTime) {
                        resolve();
                        await this.view.next();
                        await this.forward();
                    }
                    console.log('no SSML, skipping for', this.#nossmlCnt);
                    return;
                } else {
                    this.#nossmlCnt = 0;
                }
                const { plainText, marks } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$utils$2f$ssml$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["parseSSMLMarks"])(ssml);
                if ((!plainText || marks.length === 0) && !oneTime) {
                    resolve();
                    return await this.forward();
                } else {
                    this.dispatchSpeakMark(marks[0]);
                }
                await this.preloadSSML(ssml, signal);
                const iter = await this.ttsClient.speak(ssml, signal);
                let lastCode;
                for await (const { code } of iter){
                    if (signal.aborted) {
                        resolve();
                        return;
                    }
                    lastCode = code;
                }
                if (lastCode === 'end' && this.state === 'playing' && !oneTime) {
                    resolve();
                    await this.forward();
                }
                resolve();
            } catch (e) {
                if (signal.aborted) {
                    resolve();
                } else {
                    reject(e);
                }
            } finally{
                if (this.#currentSpeakAbortController) {
                    this.#currentSpeakAbortController.abort();
                    this.#currentSpeakAbortController = null;
                }
            }
        });
        await this.#currentSpeakPromise.catch((e)=>this.error(e));
    }
    async speak(ssml, oneTime = false) {
        await this.initViewTTS();
        this.#speak(ssml, oneTime).catch((e)=>this.error(e));
        this.preloadNextSSML();
        this.dispatchSpeakMark();
    }
    play() {
        if (this.state !== 'playing') {
            this.start();
        } else {
            this.pause();
        }
    }
    async start() {
        await this.initViewTTS();
        const ssml = this.state.includes('paused') ? this.view.tts?.resume() : this.view.tts?.start();
        if (this.state.includes('paused')) {
            this.resume();
        }
        this.#speak(ssml);
        this.preloadNextSSML();
    }
    async pause() {
        this.state = 'paused';
        if (!await this.ttsClient.pause().catch((e)=>this.error(e))) {
            await this.stop();
            this.state = 'stop-paused';
        }
    }
    async resume() {
        this.state = 'playing';
        await this.ttsClient.resume().catch((e)=>this.error(e));
    }
    async stop() {
        if (this.#currentSpeakAbortController) {
            this.#currentSpeakAbortController.abort();
        }
        await this.ttsClient.stop().catch((e)=>this.error(e));
        if (this.#currentSpeakPromise) {
            const timeout = new Promise((_, reject)=>setTimeout(()=>reject(new Error('Stop operation timed out')), 3000));
            await Promise.race([
                this.#currentSpeakPromise.catch((e)=>this.error(e)),
                timeout
            ]).catch((e)=>this.error(e));
            this.#currentSpeakPromise = null;
        }
        this.state = 'stopped';
    }
    // goto previous mark/paragraph
    async backward(byMark = false) {
        await this.initViewTTS();
        if (this.state === 'playing') {
            await this.stop();
            if (byMark) this.#speak(this.view.tts?.prevMark());
            else this.#speak(this.view.tts?.prev());
        } else {
            await this.stop();
            this.state = 'backward-paused';
            if (byMark) this.view.tts?.prevMark(true);
            else this.view.tts?.prev(true);
        }
    }
    // goto next mark/paragraph
    async forward(byMark = false) {
        await this.initViewTTS();
        if (this.state === 'playing') {
            await this.stop();
            if (byMark) this.#speak(this.view.tts?.nextMark());
            else {
                this.#speak(this.view.tts?.next());
                this.preloadNextSSML();
            }
        } else {
            await this.stop();
            this.state = 'forward-paused';
            if (byMark) this.view.tts?.nextMark(true);
            else this.view.tts?.next(true);
        }
    }
    async setLang(lang) {
        this.ttsLang = lang;
        this.setPrimaryLang(lang);
    }
    async setPrimaryLang(lang) {
        if (this.ttsEdgeClient.initialized) this.ttsEdgeClient.setPrimaryLang(lang);
        if (this.ttsWebClient.initialized) this.ttsWebClient.setPrimaryLang(lang);
        if (this.ttsNativeClient?.initialized) this.ttsNativeClient?.setPrimaryLang(lang);
    }
    async setRate(rate) {
        this.state = 'setrate-paused';
        this.ttsRate = rate;
        await this.ttsClient.setRate(this.ttsRate);
    }
    async getVoices(lang) {
        const ttsWebVoices = await this.ttsWebClient.getVoices(lang);
        const ttsEdgeVoices = await this.ttsEdgeClient.getVoices(lang);
        const ttsNativeVoices = await this.ttsNativeClient?.getVoices(lang) ?? [];
        const voicesGroups = [
            ...ttsNativeVoices,
            ...ttsEdgeVoices,
            ...ttsWebVoices
        ];
        return voicesGroups;
    }
    async setVoice(voiceId, lang) {
        this.state = 'setvoice-paused';
        const useEdgeTTS = !!this.ttsEdgeVoices.find((voice)=>(voiceId === '' || voice.id === voiceId) && !voice.disabled);
        const useNativeTTS = !!this.ttsNativeVoices.find((voice)=>(voiceId === '' || voice.id === voiceId) && !voice.disabled);
        if (useEdgeTTS) {
            this.ttsClient = this.ttsEdgeClient;
            await this.ttsClient.setRate(this.ttsRate);
        } else if (useNativeTTS) {
            if (!this.ttsNativeClient) {
                throw new Error('Native TTS client is not available');
            }
            this.ttsClient = this.ttsNativeClient;
            await this.ttsClient.setRate(this.ttsRate);
        } else {
            this.ttsClient = this.ttsWebClient;
            await this.ttsClient.setRate(this.ttsRate);
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].setPreferredClient(this.ttsClient.name);
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSUtils$2e$ts__$5b$client$5d$__$28$ecmascript$29$__["TTSUtils"].setPreferredVoice(this.ttsClient.name, lang, voiceId);
        await this.ttsClient.setVoice(voiceId);
    }
    getVoiceId() {
        return this.ttsClient.getVoiceId();
    }
    getSpeakingLang() {
        return this.ttsClient.getSpeakingLang();
    }
    setTargetLang(lang) {
        this.ttsTargetLang = lang;
    }
    dispatchSpeakMark(mark) {
        this.dispatchEvent(new CustomEvent('tts-speak-mark', {
            detail: mark || {
                text: ''
            }
        }));
        if (mark) {
            const range = this.view.tts?.setMark(mark.name);
            this.dispatchEvent(new CustomEvent('tts-highlight-mark', {
                detail: range
            }));
        }
    }
    error(e) {
        console.error(e);
        this.state = 'stopped';
    }
    async shutdown() {
        await this.stop();
        this.#clearHighlighter();
        if (this.ttsWebClient.initialized) {
            await this.ttsWebClient.shutdown();
        }
        if (this.ttsEdgeClient.initialized) {
            await this.ttsEdgeClient.shutdown();
        }
        if (this.ttsNativeClient?.initialized) {
            await this.ttsNativeClient.shutdown();
        }
    }
}
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
"[project]/apps/readest-app/src/services/tts/index.ts [client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$types$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/types.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$WebSpeechClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/WebSpeechClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$EdgeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/EdgeTTSClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$NativeTTSClient$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/NativeTTSClient.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSController$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSController.ts [client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$readest$2d$app$2f$src$2f$services$2f$tts$2f$TTSData$2e$ts__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/readest-app/src/services/tts/TTSData.ts [client] (ecmascript)");
;
;
;
;
;
;
;
if (typeof globalThis.$RefreshHelpers$ === 'object' && globalThis.$RefreshHelpers !== null) {
    __turbopack_context__.k.registerExports(__turbopack_context__.m, globalThis.$RefreshHelpers$);
}
}),
]);

//# sourceMappingURL=apps_readest-app_src_services_7fac902b._.js.map
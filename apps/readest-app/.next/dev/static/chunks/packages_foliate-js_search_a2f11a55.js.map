{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/search.js"],"sourcesContent":["// length for context in excerpts\nconst CONTEXT_LENGTH = 50\n\nconst normalizeWhitespace = str => str.replace(/\\s+/g, ' ')\n\nconst makeExcerpt = (strs, { startIndex, startOffset, endIndex, endOffset }) => {\n    const start = strs[startIndex]\n    const end = strs[endIndex]\n    const match = start === end\n        ? start.slice(startOffset, endOffset)\n        : start.slice(startOffset)\n            + strs.slice(start + 1, end).join('')\n            + end.slice(0, endOffset)\n    const trimmedStart = normalizeWhitespace(start.slice(0, startOffset)).trimStart()\n    const trimmedEnd = normalizeWhitespace(end.slice(endOffset)).trimEnd()\n    const ellipsisPre = trimmedStart.length < CONTEXT_LENGTH ? '' : '…'\n    const ellipsisPost = trimmedEnd.length < CONTEXT_LENGTH ? '' : '…'\n    const pre = `${ellipsisPre}${trimmedStart.slice(-CONTEXT_LENGTH)}`\n    const post = `${trimmedEnd.slice(0, CONTEXT_LENGTH)}${ellipsisPost}`\n    return { pre, match, post }\n}\n\nconst simpleSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', sensitivity } = options\n    const matchCase = sensitivity === 'variant'\n    const haystack = strs.join('')\n    const lowerHaystack = matchCase ? haystack : haystack.toLocaleLowerCase(locales)\n    const needle = matchCase ? query : query.toLocaleLowerCase(locales)\n    const needleLength = needle.length\n    let index = -1\n    let strIndex = -1\n    let sum = 0\n    do {\n        index = lowerHaystack.indexOf(needle, index + 1)\n        if (index > -1) {\n            while (sum <= index) sum += strs[++strIndex].length\n            const startIndex = strIndex\n            const startOffset = index - (sum - strs[strIndex].length)\n            const end = index + needleLength\n            while (sum <= end) sum += strs[++strIndex].length\n            const endIndex = strIndex\n            const endOffset = end - (sum - strs[strIndex].length)\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n    } while (index > -1)\n}\n\nconst segmenterSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', granularity = 'word', sensitivity = 'base' } = options\n    let segmenter, collator\n    try {\n        segmenter = new Intl.Segmenter(locales, { usage: 'search', granularity })\n        collator = new Intl.Collator(locales, { sensitivity })\n    } catch (e) {\n        console.warn(e)\n        segmenter = new Intl.Segmenter('en', { usage: 'search', granularity })\n        collator = new Intl.Collator('en', { sensitivity })\n    }\n    const queryLength = Array.from(segmenter.segment(query)).length\n\n    const substrArr = []\n    let strIndex = 0\n    let segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n    main: while (strIndex < strs.length) {\n        while (substrArr.length < queryLength) {\n            const { done, value } = segments.next()\n            if (done) {\n                // the current string is exhausted\n                // move on to the next string\n                strIndex++\n                if (strIndex < strs.length) {\n                    segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n                    continue\n                } else break main\n            }\n            const { index, segment } = value\n            // ignore formatting characters\n            if (!/[^\\p{Format}]/u.test(segment)) continue\n            // normalize whitespace\n            if (/\\s/u.test(segment)) {\n                if (!/\\s/u.test(substrArr[substrArr.length - 1]?.segment))\n                    substrArr.push({ strIndex, index, segment: ' ' })\n                continue\n            }\n            value.strIndex = strIndex\n            substrArr.push(value)\n        }\n        const substr = substrArr.map(x => x.segment).join('')\n        if (collator.compare(query, substr) === 0) {\n            const endIndex = strIndex\n            const lastSeg = substrArr[substrArr.length - 1]\n            const endOffset = lastSeg.index + lastSeg.segment.length\n            const startIndex = substrArr[0].strIndex\n            const startOffset = substrArr[0].index\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n        substrArr.shift()\n    }\n}\n\nexport const search = (strs, query, options) => {\n    const { granularity = 'grapheme', sensitivity = 'base' } = options\n    if (!Intl?.Segmenter || granularity === 'grapheme'\n    && (sensitivity === 'variant' || sensitivity === 'accent'))\n        return simpleSearch(strs, query, options)\n    return segmenterSearch(strs, query, options)\n}\n\nexport const searchMatcher = (textWalker, opts) => {\n    const { defaultLocale, matchCase, matchDiacritics, matchWholeWords, acceptNode } = opts\n    return function* (doc, query) {\n        const iter = textWalker(doc, function* (strs, makeRange) {\n            for (const result of search(strs, query, {\n                locales: doc.body.lang || doc.documentElement.lang || defaultLocale || 'en',\n                granularity: matchWholeWords ? 'word' : 'grapheme',\n                sensitivity: matchDiacritics && matchCase ? 'variant'\n                : matchDiacritics && !matchCase ? 'accent'\n                : !matchDiacritics && matchCase ? 'case'\n                : 'base',\n            })) {\n                const { startIndex, startOffset, endIndex, endOffset } = result.range\n                result.range = makeRange(startIndex, startOffset, endIndex, endOffset)\n                yield result\n            }\n        }, acceptNode)\n        for (const result of iter) yield result\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
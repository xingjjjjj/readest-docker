{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/app/api/storage/_lib/localFs.ts"],"sourcesContent":["import fs from 'node:fs/promises';\nimport type { Dirent } from 'node:fs';\nimport path from 'node:path';\n\nexport const isLocalStorageEnabled = () =>\n    (process.env['STORAGE_MODE'] || process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n\nexport const STORAGE_ROOT = path.resolve(\n    process.env['LOCAL_STORAGE_ROOT'] || path.join(process.cwd(), 'data', 'storage'),\n);\nexport const TEMP_ROOT = path.resolve(\n    process.env['LOCAL_STORAGE_TEMP_ROOT'] || path.join(STORAGE_ROOT, 'temp'),\n);\n\nexport const ensureRoots = async () => {\n    await fs.mkdir(STORAGE_ROOT, { recursive: true });\n    await fs.mkdir(TEMP_ROOT, { recursive: true });\n};\n\n// Keep user-provided relative paths intact; only trim leading slashes.\nconst stripUserPrefix = (fileKey: string) => fileKey.replace(/^\\/+/, '');\n\nexport const resolveLocalPath = (fileKey: string, useTemp = false) => {\n    const base = useTemp ? TEMP_ROOT : STORAGE_ROOT;\n\n    // Allow absolute paths inside the storage root without re-prefixing.\n    if (path.isAbsolute(fileKey)) {\n        const fullPath = path.resolve(fileKey);\n        if (!fullPath.startsWith(base)) {\n            throw new Error('Invalid file path');\n        }\n        const relPath = path.posix.normalize(path.relative(base, fullPath));\n        return { fullPath, relPath, basePath: base };\n    }\n\n    const cleanKey = stripUserPrefix(fileKey);\n\n    // In local storage mode, route certain files to .readest directory\n    if (isLocalStorageEnabled()) {\n        // Settings files go to .readest/ directory\n        if (cleanKey === 'settings.json' || cleanKey === 'settings.json.bak') {\n            const settingsRelPath = path.posix.normalize(`.readest/${cleanKey}`);\n            const settingsFullPath = path.join(base, settingsRelPath);\n            if (!settingsFullPath.startsWith(base)) {\n                throw new Error('Invalid file path');\n            }\n            console.log('[LocalFS] Settings file routed:', cleanKey, '->', settingsRelPath);\n            return { fullPath: settingsFullPath, relPath: settingsRelPath, basePath: base };\n        }\n\n        // Library files also go to .readest/ directory\n        if (cleanKey === 'library.json' || cleanKey === 'library.json.bak' || cleanKey === 'library_backup.json') {\n            const libraryRelPath = path.posix.normalize(`.readest/${cleanKey}`);\n            const libraryFullPath = path.join(base, libraryRelPath);\n            if (!libraryFullPath.startsWith(base)) {\n                throw new Error('Invalid file path');\n            }\n            console.log('[LocalFS] Library file routed:', cleanKey, '->', libraryRelPath);\n            return { fullPath: libraryFullPath, relPath: libraryRelPath, basePath: base };\n        }\n\n        // All other files use flat structure\n        console.log('[LocalFS] ✓ Using flat storage, cleanKey:', cleanKey);\n    }\n\n    const relPath = path.posix.normalize(cleanKey);\n    if (relPath.startsWith('..')) {\n        throw new Error('Invalid file path');\n    }\n    const fullPath = path.join(base, relPath);\n    if (!fullPath.startsWith(base)) {\n        throw new Error('Invalid file path');\n    }\n    console.log('[LocalFS] ✓ Final paths - Full:', fullPath, ', Relative:', relPath);\n    return { fullPath, relPath, basePath: base };\n};\n\nexport const ensureParentDir = async (fullPath: string) => {\n    const dir = path.dirname(fullPath);\n    await fs.mkdir(dir, { recursive: true });\n};\n\nexport const readFileBuffer = async (fullPath: string) => {\n    try {\n        const stats = await fs.stat(fullPath);\n        const fileSizeMB = stats.size / (1024 * 1024);\n\n        console.log(`[readFileBuffer] Reading file: ${fullPath}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // 警告：文件超过 100MB\n        if (stats.size > 100 * 1024 * 1024) {\n            console.warn(`[readFileBuffer] ⚠️ Large file detected: ${fileSizeMB.toFixed(2)} MB`);\n        }\n\n        // 限制：文件超过 500MB 时抛出错误\n        if (stats.size > 500 * 1024 * 1024) {\n            throw new Error(`File too large: ${fileSizeMB.toFixed(2)} MB. Maximum size is 500 MB.`);\n        }\n\n        const buffer = Buffer.from(await fs.readFile(fullPath));\n        console.log(`[readFileBuffer] ✓ Successfully read ${fileSizeMB.toFixed(2)} MB`);\n        return buffer;\n    } catch (error: any) {\n        console.error(`[readFileBuffer] ✗ Error reading file ${fullPath}:`, error.message);\n        if (error.code === 'ENOMEM' || error.message?.includes('memory')) {\n            throw new Error(`Out of memory while reading file. File may be too large.`);\n        }\n        throw error;\n    }\n};\n\nexport const writeFileBuffer = async (fullPath: string, buffer: Buffer) => {\n    await ensureParentDir(fullPath);\n    await fs.writeFile(fullPath, buffer);\n};\n\nexport const deleteIfExists = async (fullPath: string) => {\n    try {\n        await fs.unlink(fullPath);\n        return true;\n    } catch (error: any) {\n        if (error?.code === 'ENOENT') return false;\n        throw error;\n    }\n};\n\nexport type LocalFileInfo = {\n    fileKey: string;\n    size: number;\n    mtime: number;\n};\n\nexport const walkFiles = async (root: string, prefix = ''): Promise<LocalFileInfo[]> => {\n    let entries: Dirent[] = [];\n    try {\n        entries = await fs.readdir(root, { withFileTypes: true });\n    } catch (error: any) {\n        if (error?.code === 'ENOENT') return [];\n        throw error;\n    }\n    const files: LocalFileInfo[] = [];\n\n    for (const entry of entries) {\n        const relKey = path.posix.join(prefix, entry.name);\n        const fullPath = path.join(root, entry.name);\n        if (entry.isDirectory()) {\n            files.push(...(await walkFiles(fullPath, relKey)));\n        } else if (entry.isFile()) {\n            const stat = await fs.stat(fullPath);\n            files.push({ fileKey: relKey, size: stat.size, mtime: stat.mtimeMs });\n        }\n    }\n\n    return files;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/app/api/storage/reconcile/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { STORAGE_ROOT, ensureRoots, isLocalStorageEnabled } from '../_lib/localFs';\n\nconst SUPPORTED_EXTS = ['.epub', '.mobi', '.azw', '.azw3', '.fb2', '.cbz', '.pdf', '.txt'];\nconst METADATA_DIR = '.readest';\n\ninterface ReconcileResult {\n    hash: string;\n    status: 'matched' | 'moved' | 'missing' | 'duplicated';\n    oldRelativePath?: string;\n    newRelativePath?: string;\n    absolutePath?: string;\n    suggestedGroupName?: string;\n    message?: string;\n}\n\ninterface LibraryBook {\n    hash: string;\n    relativePath?: string;\n    absolutePath?: string;\n    title: string;\n    groupName?: string;\n}\n\n/**\n * 书籍路径校准 API\n * \n * 功能：\n * 1. 扫描文件系统中的所有书籍文件\n * 2. 与 library.json 中的记录进行对比\n * 3. 检测路径不一致、文件移动、文件丢失等情况\n * 4. 根据文件实际位置推断分组信息\n * 5. 返回需要调整的书籍列表\n */\nexport async function POST(req: NextRequest) {\n    if (!isLocalStorageEnabled()) {\n        return NextResponse.json({ error: 'Local storage disabled' }, { status: 501 });\n    }\n\n    await ensureRoots();\n\n    try {\n        const { library } = await req.json();\n\n        if (!Array.isArray(library)) {\n            return NextResponse.json(\n                { error: 'Invalid library data: expected an array' },\n                { status: 400 }\n            );\n        }\n\n        console.log('[Reconcile] Starting reconciliation with', library.length, 'books');\n\n        // Step 1: 扫描文件系统中的所有书籍文件\n        const filesInStorage = await scanAllBooks(STORAGE_ROOT);\n        console.log('[Reconcile] Found', filesInStorage.size, 'files in storage');\n\n        // Step 2: 对比 library 中的每一本书\n        const results: ReconcileResult[] = [];\n        const processedFiles = new Set<string>();\n\n        for (const book of library as LibraryBook[]) {\n            if (!book.hash) continue;\n\n            const result = await reconcileBook(book, filesInStorage, processedFiles);\n            results.push(result);\n        }\n\n        // Step 3: 检查未匹配的文件（可能是新增的书籍）\n        const unmatchedFiles: string[] = [];\n        for (const filePath of filesInStorage.keys()) {\n            if (!processedFiles.has(filePath)) {\n                unmatchedFiles.push(filePath);\n            }\n        }\n\n        const summary = {\n            total: library.length,\n            matched: results.filter(r => r.status === 'matched').length,\n            moved: results.filter(r => r.status === 'moved').length,\n            missing: results.filter(r => r.status === 'missing').length,\n            duplicated: results.filter(r => r.status === 'duplicated').length,\n            unmatched: unmatchedFiles.length,\n        };\n\n        console.log('[Reconcile] Summary:', summary);\n\n        return NextResponse.json({\n            success: true,\n            summary,\n            results,\n            unmatchedFiles,\n        });\n    } catch (error: any) {\n        console.error('[Reconcile] Error:', error?.message);\n        return NextResponse.json(\n            { error: error?.message || 'Reconciliation failed' },\n            { status: 500 }\n        );\n    }\n}\n\n/**\n * 扫描所有书籍文件，返回 Map<relativePath, absolutePath>\n */\nasync function scanAllBooks(baseDir: string): Promise<Map<string, string>> {\n    const books = new Map<string, string>();\n\n    async function scanDir(dir: string) {\n        try {\n            const entries = await fs.readdir(dir, { withFileTypes: true });\n\n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n\n                // 跳过元数据目录\n                if (entry.name === METADATA_DIR) continue;\n\n                if (entry.isDirectory()) {\n                    await scanDir(fullPath);\n                } else if (entry.isFile()) {\n                    const ext = path.extname(entry.name).toLowerCase();\n                    if (SUPPORTED_EXTS.includes(ext)) {\n                        const relativePath = path.relative(baseDir, fullPath);\n                        books.set(relativePath, fullPath);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error('[Reconcile] Error scanning directory:', dir, error);\n        }\n    }\n\n    await scanDir(baseDir);\n    return books;\n}\n\n/**\n * 校准单本书籍\n */\nasync function reconcileBook(\n    book: LibraryBook,\n    filesInStorage: Map<string, string>,\n    processedFiles: Set<string>\n): Promise<ReconcileResult> {\n    const { hash, relativePath, absolutePath, title } = book;\n\n    // Case 1: 书籍有 relativePath，检查是否在文件系统中\n    if (relativePath) {\n        const absolutePathInStorage = filesInStorage.get(relativePath);\n\n        if (absolutePathInStorage) {\n            // 文件在预期位置\n            processedFiles.add(relativePath);\n            return {\n                hash,\n                status: 'matched',\n                oldRelativePath: relativePath,\n                newRelativePath: relativePath,\n                absolutePath: absolutePathInStorage,\n                message: 'Book file found at expected location',\n            };\n        } else {\n            // 文件不在预期位置，尝试根据文件名查找\n            const fileName = path.basename(relativePath);\n            const matchedPath = findFileByName(fileName, filesInStorage);\n\n            if (matchedPath) {\n                // 文件被移动了\n                const [newRelativePath, newAbsolutePath] = matchedPath;\n                const suggestedGroupName = inferGroupFromPath(newRelativePath);\n                processedFiles.add(newRelativePath);\n\n                return {\n                    hash,\n                    status: 'moved',\n                    oldRelativePath: relativePath,\n                    newRelativePath,\n                    absolutePath: newAbsolutePath,\n                    suggestedGroupName,\n                    message: `Book file moved from ${relativePath} to ${newRelativePath}`,\n                };\n            } else {\n                // 文件丢失\n                return {\n                    hash,\n                    status: 'missing',\n                    oldRelativePath: relativePath,\n                    message: `Book file not found: ${relativePath}`,\n                };\n            }\n        }\n    }\n\n    // Case 2: 书籍有 absolutePath，尝试匹配\n    if (absolutePath) {\n        for (const [relPath, absPath] of filesInStorage.entries()) {\n            if (absPath === absolutePath) {\n                processedFiles.add(relPath);\n                return {\n                    hash,\n                    status: 'matched',\n                    oldRelativePath: relativePath,\n                    newRelativePath: relPath,\n                    absolutePath: absPath,\n                    message: 'Book file found via absolutePath',\n                };\n            }\n        }\n    }\n\n    // Case 3: 尝试根据标题匹配\n    const fileName = `${title}.epub`; // 简化处理，实际可能需要更复杂的匹配逻辑\n    const matchedPath = findFileByName(fileName, filesInStorage);\n\n    if (matchedPath) {\n        const [newRelativePath, newAbsolutePath] = matchedPath;\n        const suggestedGroupName = inferGroupFromPath(newRelativePath);\n        processedFiles.add(newRelativePath);\n\n        return {\n            hash,\n            status: 'moved',\n            oldRelativePath: relativePath,\n            newRelativePath,\n            absolutePath: newAbsolutePath,\n            suggestedGroupName,\n            message: `Book file found by title: ${newRelativePath}`,\n        };\n    }\n\n    // 文件丢失\n    return {\n        hash,\n        status: 'missing',\n        oldRelativePath: relativePath,\n        message: 'Book file not found in storage',\n    };\n}\n\n/**\n * 根据文件名查找文件\n */\nfunction findFileByName(\n    fileName: string,\n    filesInStorage: Map<string, string>\n): [string, string] | null {\n    for (const [relPath, absPath] of filesInStorage.entries()) {\n        if (path.basename(relPath) === fileName) {\n            return [relPath, absPath];\n        }\n    }\n    return null;\n}\n\n/**\n * 从路径推断分组名称\n * 例如：fiction/scifi/book.epub -> fiction/scifi\n */\nfunction inferGroupFromPath(relativePath: string): string {\n    const dir = path.dirname(relativePath);\n    return dir === '.' ? '' : dir.replace(/\\\\/g, '/');\n}\n"],"names":[],"mappings":"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"}}]
}
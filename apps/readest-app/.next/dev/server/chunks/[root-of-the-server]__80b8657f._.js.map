{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/app/api/storage/_lib/localFs.ts"],"sourcesContent":["import fs from 'node:fs/promises';\nimport type { Dirent } from 'node:fs';\nimport path from 'node:path';\n\nexport const isLocalStorageEnabled = () =>\n    (process.env['STORAGE_MODE'] || process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n\nexport const STORAGE_ROOT = path.resolve(\n    process.env['LOCAL_STORAGE_ROOT'] || path.join(process.cwd(), 'data', 'storage'),\n);\nexport const TEMP_ROOT = path.resolve(\n    process.env['LOCAL_STORAGE_TEMP_ROOT'] || path.join(STORAGE_ROOT, 'temp'),\n);\n\nexport const ensureRoots = async () => {\n    await fs.mkdir(STORAGE_ROOT, { recursive: true });\n    await fs.mkdir(TEMP_ROOT, { recursive: true });\n};\n\n// Keep user-provided relative paths intact; only trim leading slashes.\nconst stripUserPrefix = (fileKey: string) => fileKey.replace(/^\\/+/, '');\n\nexport const resolveLocalPath = (fileKey: string, useTemp = false) => {\n    const base = useTemp ? TEMP_ROOT : STORAGE_ROOT;\n\n    // Allow absolute paths inside the storage root without re-prefixing.\n    if (path.isAbsolute(fileKey)) {\n        const fullPath = path.resolve(fileKey);\n        if (!fullPath.startsWith(base)) {\n            throw new Error('Invalid file path');\n        }\n        const relPath = path.posix.normalize(path.relative(base, fullPath));\n        return { fullPath, relPath, basePath: base };\n    }\n\n    const cleanKey = stripUserPrefix(fileKey);\n\n    // In local storage mode, route certain files to .readest directory\n    if (isLocalStorageEnabled()) {\n        // Settings files go to .readest/ directory\n        if (cleanKey === 'settings.json' || cleanKey === 'settings.json.bak') {\n            const settingsRelPath = path.posix.normalize(`.readest/${cleanKey}`);\n            const settingsFullPath = path.join(base, settingsRelPath);\n            if (!settingsFullPath.startsWith(base)) {\n                throw new Error('Invalid file path');\n            }\n            console.log('[LocalFS] Settings file routed:', cleanKey, '->', settingsRelPath);\n            return { fullPath: settingsFullPath, relPath: settingsRelPath, basePath: base };\n        }\n\n        // Library files also go to .readest/ directory\n        if (cleanKey === 'library.json' || cleanKey === 'library.json.bak' || cleanKey === 'library_backup.json') {\n            const libraryRelPath = path.posix.normalize(`.readest/${cleanKey}`);\n            const libraryFullPath = path.join(base, libraryRelPath);\n            if (!libraryFullPath.startsWith(base)) {\n                throw new Error('Invalid file path');\n            }\n            console.log('[LocalFS] Library file routed:', cleanKey, '->', libraryRelPath);\n            return { fullPath: libraryFullPath, relPath: libraryRelPath, basePath: base };\n        }\n\n        // All other files use flat structure\n        console.log('[LocalFS] ✓ Using flat storage, cleanKey:', cleanKey);\n    }\n\n    const relPath = path.posix.normalize(cleanKey);\n    if (relPath.startsWith('..')) {\n        throw new Error('Invalid file path');\n    }\n    const fullPath = path.join(base, relPath);\n    if (!fullPath.startsWith(base)) {\n        throw new Error('Invalid file path');\n    }\n    console.log('[LocalFS] ✓ Final paths - Full:', fullPath, ', Relative:', relPath);\n    return { fullPath, relPath, basePath: base };\n};\n\nexport const ensureParentDir = async (fullPath: string) => {\n    const dir = path.dirname(fullPath);\n    await fs.mkdir(dir, { recursive: true });\n};\n\nexport const readFileBuffer = async (fullPath: string) => {\n    try {\n        const stats = await fs.stat(fullPath);\n        const fileSizeMB = stats.size / (1024 * 1024);\n\n        console.log(`[readFileBuffer] Reading file: ${fullPath}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // 警告：文件超过 100MB\n        if (stats.size > 100 * 1024 * 1024) {\n            console.warn(`[readFileBuffer] ⚠️ Large file detected: ${fileSizeMB.toFixed(2)} MB`);\n        }\n\n        // 限制：文件超过 500MB 时抛出错误\n        if (stats.size > 500 * 1024 * 1024) {\n            throw new Error(`File too large: ${fileSizeMB.toFixed(2)} MB. Maximum size is 500 MB.`);\n        }\n\n        const buffer = Buffer.from(await fs.readFile(fullPath));\n        console.log(`[readFileBuffer] ✓ Successfully read ${fileSizeMB.toFixed(2)} MB`);\n        return buffer;\n    } catch (error: any) {\n        console.error(`[readFileBuffer] ✗ Error reading file ${fullPath}:`, error.message);\n        if (error.code === 'ENOMEM' || error.message?.includes('memory')) {\n            throw new Error(`Out of memory while reading file. File may be too large.`);\n        }\n        throw error;\n    }\n};\n\nexport const writeFileBuffer = async (fullPath: string, buffer: Buffer) => {\n    await ensureParentDir(fullPath);\n    await fs.writeFile(fullPath, buffer);\n};\n\nexport const deleteIfExists = async (fullPath: string) => {\n    try {\n        await fs.unlink(fullPath);\n        return true;\n    } catch (error: any) {\n        if (error?.code === 'ENOENT') return false;\n        throw error;\n    }\n};\n\nexport type LocalFileInfo = {\n    fileKey: string;\n    size: number;\n    mtime: number;\n};\n\nexport const walkFiles = async (root: string, prefix = ''): Promise<LocalFileInfo[]> => {\n    let entries: Dirent[] = [];\n    try {\n        entries = await fs.readdir(root, { withFileTypes: true });\n    } catch (error: any) {\n        if (error?.code === 'ENOENT') return [];\n        throw error;\n    }\n    const files: LocalFileInfo[] = [];\n\n    for (const entry of entries) {\n        const relKey = path.posix.join(prefix, entry.name);\n        const fullPath = path.join(root, entry.name);\n        if (entry.isDirectory()) {\n            files.push(...(await walkFiles(fullPath, relKey)));\n        } else if (entry.isFile()) {\n            const stat = await fs.stat(fullPath);\n            files.push({ fileKey: relKey, size: stat.size, mtime: stat.mtimeMs });\n        }\n    }\n\n    return files;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 241, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/app/api/storage/scan/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { STORAGE_ROOT, ensureRoots, isLocalStorageEnabled } from '../_lib/localFs';\nimport { createHash } from 'crypto';\n\nconst SUPPORTED_EXTS = ['.epub', '.mobi', '.azw', '.azw3', '.fb2', '.cbz', '.pdf', '.txt'];\nconst METADATA_DIR = '.readest';\n\ninterface ScannedBook {\n    filePath: string;\n    relativePath: string;\n    fileName: string;\n    directory: string;\n    size: number;\n    mtime: number;\n    ext: string;\n    hash?: string;\n}\n\n/**\n * Calculate a lightweight hash for deduplication without reading the full file.\n * Uses the first 1MB plus the file size for stability.\n */\nasync function calculatePartialHash(filePath: string, fileSize: number): Promise<string> {\n    const SAMPLE_SIZE = 1024 * 1024; // 1MB\n    try {\n        const hash = createHash('md5');\n        const handle = await fs.open(filePath, 'r');\n        const buffer = Buffer.alloc(Math.min(SAMPLE_SIZE, fileSize));\n        const { bytesRead } = await handle.read(buffer, 0, buffer.length);\n        await handle.close();\n\n        hash.update(buffer.slice(0, bytesRead));\n        hash.update(fileSize.toString());\n        return hash.digest('hex').slice(0, 16);\n    } catch (error) {\n        console.error('[Storage Scan] Hash calculation failed for', filePath, error);\n        return createHash('md5').update(`${filePath}-${fileSize}`).digest('hex').slice(0, 16);\n    }\n}\n\nasync function scanDirectory(dir: string, baseDir: string): Promise<ScannedBook[]> {\n    const books: ScannedBook[] = [];\n\n    try {\n        const entries = await fs.readdir(dir, { withFileTypes: true });\n\n        for (const entry of entries) {\n            const fullPath = path.join(dir, entry.name);\n\n            // Skip metadata directory\n            if (entry.name === METADATA_DIR) continue;\n\n            if (entry.isDirectory()) {\n                const subBooks = await scanDirectory(fullPath, baseDir);\n                books.push(...subBooks);\n            } else if (entry.isFile()) {\n                const ext = path.extname(entry.name).toLowerCase();\n                if (SUPPORTED_EXTS.includes(ext)) {\n                    const stat = await fs.stat(fullPath);\n                    const relativePath = path.relative(baseDir, fullPath);\n                    const directory = path.dirname(relativePath);\n\n                    const hash = await calculatePartialHash(fullPath, stat.size);\n\n                    books.push({\n                        filePath: fullPath,\n                        relativePath,\n                        fileName: entry.name,\n                        directory: directory === '.' ? '' : directory,\n                        size: stat.size,\n                        mtime: stat.mtimeMs,\n                        ext: ext.slice(1), // Remove leading dot\n                        hash,\n                    });\n                }\n            }\n        }\n    } catch (error) {\n        console.error('Error scanning directory:', dir, error);\n    }\n\n    return books;\n}\n\nexport async function POST(_req: NextRequest) {\n    if (!isLocalStorageEnabled()) {\n        return NextResponse.json({ error: 'Local storage disabled' }, { status: 501 });\n    }\n\n    await ensureRoots();\n\n    try {\n        console.log('[Storage Scan] Starting scan of:', STORAGE_ROOT);\n        const books = await scanDirectory(STORAGE_ROOT, STORAGE_ROOT);\n        console.log('[Storage Scan] Found', books.length, 'books');\n\n        return NextResponse.json({\n            success: true,\n            count: books.length,\n            books,\n        });\n    } catch (error: any) {\n        console.error('[Storage Scan] Error:', error?.message);\n        return NextResponse.json(\n            { error: error?.message || 'Scan failed' },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
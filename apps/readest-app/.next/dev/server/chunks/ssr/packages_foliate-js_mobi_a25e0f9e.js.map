{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/mobi.js"],"sourcesContent":["const unescapeHTML = str => {\n    if (!str) return ''\n    const textarea = document.createElement('textarea')\n    textarea.innerHTML = str\n    return textarea.value\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n}\n\nconst PDB_HEADER = {\n    name: [0, 32, 'string'],\n    type: [60, 4, 'string'],\n    creator: [64, 4, 'string'],\n    numRecords: [76, 2, 'uint'],\n}\n\nconst PALMDOC_HEADER = {\n    compression: [0, 2, 'uint'],\n    numTextRecords: [8, 2, 'uint'],\n    recordSize: [10, 2, 'uint'],\n    encryption: [12, 2, 'uint'],\n}\n\nconst MOBI_HEADER = {\n    magic: [16, 4, 'string'],\n    length: [20, 4, 'uint'],\n    type: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    uid: [32, 4, 'uint'],\n    version: [36, 4, 'uint'],\n    titleOffset: [84, 4, 'uint'],\n    titleLength: [88, 4, 'uint'],\n    localeRegion: [94, 1, 'uint'],\n    localeLanguage: [95, 1, 'uint'],\n    resourceStart: [108, 4, 'uint'],\n    huffcdic: [112, 4, 'uint'],\n    numHuffcdic: [116, 4, 'uint'],\n    exthFlag: [128, 4, 'uint'],\n    trailingFlags: [240, 4, 'uint'],\n    indx: [244, 4, 'uint'],\n}\n\nconst KF8_HEADER = {\n    resourceStart: [108, 4, 'uint'],\n    fdst: [192, 4, 'uint'],\n    numFdst: [196, 4, 'uint'],\n    frag: [248, 4, 'uint'],\n    skel: [252, 4, 'uint'],\n    guide: [260, 4, 'uint'],\n}\n\nconst EXTH_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    count: [8, 4, 'uint'],\n}\n\nconst INDX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    type: [8, 4, 'uint'],\n    idxt: [20, 4, 'uint'],\n    numRecords: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    language: [32, 4, 'uint'],\n    total: [36, 4, 'uint'],\n    ordt: [40, 4, 'uint'],\n    ligt: [44, 4, 'uint'],\n    numLigt: [48, 4, 'uint'],\n    numCncx: [52, 4, 'uint'],\n}\n\nconst TAGX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numControlBytes: [8, 4, 'uint'],\n}\n\nconst HUFF_HEADER = {\n    magic: [0, 4, 'string'],\n    offset1: [8, 4, 'uint'],\n    offset2: [12, 4, 'uint'],\n}\n\nconst CDIC_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numEntries: [8, 4, 'uint'],\n    codeLength: [12, 4, 'uint'],\n}\n\nconst FDST_HEADER = {\n    magic: [0, 4, 'string'],\n    numEntries: [8, 4, 'uint'],\n}\n\nconst FONT_HEADER = {\n    flags: [8, 4, 'uint'],\n    dataStart: [12, 4, 'uint'],\n    keyLength: [16, 4, 'uint'],\n    keyStart: [20, 4, 'uint'],\n}\n\nconst MOBI_ENCODING = {\n    1252: 'windows-1252',\n    65001: 'utf-8',\n}\n\nconst EXTH_RECORD_TYPE = {\n    100: ['creator', 'string', true],\n    101: ['publisher'],\n    103: ['description'],\n    104: ['isbn'],\n    105: ['subject', 'string', true],\n    106: ['date'],\n    108: ['contributor', 'string', true],\n    109: ['rights'],\n    110: ['subjectCode', 'string', true],\n    112: ['source', 'string', true],\n    113: ['asin'],\n    121: ['boundary', 'uint'],\n    122: ['fixedLayout'],\n    125: ['numResources', 'uint'],\n    126: ['originalResolution'],\n    127: ['zeroGutter'],\n    128: ['zeroMargin'],\n    129: ['coverURI'],\n    132: ['regionMagnification'],\n    201: ['coverOffset', 'uint'],\n    202: ['thumbnailOffset', 'uint'],\n    503: ['title'],\n    524: ['language', 'string', true],\n    527: ['pageProgressionDirection'],\n}\n\nconst MOBI_LANG = {\n    1: ['ar', 'ar-SA', 'ar-IQ', 'ar-EG', 'ar-LY', 'ar-DZ', 'ar-MA', 'ar-TN', 'ar-OM',\n        'ar-YE', 'ar-SY', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-AE', 'ar-BH', 'ar-QA'],\n    2: ['bg'], 3: ['ca'], 4: ['zh', 'zh-TW', 'zh-CN', 'zh-HK', 'zh-SG'], 5: ['cs'],\n    6: ['da'], 7: ['de', 'de-DE', 'de-CH', 'de-AT', 'de-LU', 'de-LI'], 8: ['el'],\n    9: ['en', 'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',\n        'en-JM', null, 'en-BZ', 'en-TT', 'en-ZW', 'en-PH'],\n    10: ['es', 'es-ES', 'es-MX', null, 'es-GT', 'es-CR', 'es-PA', 'es-DO',\n        'es-VE', 'es-CO', 'es-PE', 'es-AR', 'es-EC', 'es-CL', 'es-UY', 'es-PY',\n        'es-BO', 'es-SV', 'es-HN', 'es-NI', 'es-PR'],\n    11: ['fi'], 12: ['fr', 'fr-FR', 'fr-BE', 'fr-CA', 'fr-CH', 'fr-LU', 'fr-MC'],\n    13: ['he'], 14: ['hu'], 15: ['is'], 16: ['it', 'it-IT', 'it-CH'],\n    17: ['ja'], 18: ['ko'], 19: ['nl', 'nl-NL', 'nl-BE'], 20: ['no', 'nb', 'nn'],\n    21: ['pl'], 22: ['pt', 'pt-BR', 'pt-PT'], 23: ['rm'], 24: ['ro'], 25: ['ru'],\n    26: ['hr', null, 'sr'], 27: ['sk'], 28: ['sq'], 29: ['sv', 'sv-SE', 'sv-FI'],\n    30: ['th'], 31: ['tr'], 32: ['ur'], 33: ['id'], 34: ['uk'], 35: ['be'],\n    36: ['sl'], 37: ['et'], 38: ['lv'], 39: ['lt'], 41: ['fa'], 42: ['vi'],\n    43: ['hy'], 44: ['az'], 45: ['eu'], 46: ['hsb'], 47: ['mk'], 48: ['st'],\n    49: ['ts'], 50: ['tn'], 52: ['xh'], 53: ['zu'], 54: ['af'], 55: ['ka'],\n    56: ['fo'], 57: ['hi'], 58: ['mt'], 59: ['se'], 62: ['ms'], 63: ['kk'],\n    65: ['sw'], 67: ['uz', null, 'uz-UZ'], 68: ['tt'], 69: ['bn'], 70: ['pa'],\n    71: ['gu'], 72: ['or'], 73: ['ta'], 74: ['te'], 75: ['kn'], 76: ['ml'],\n    77: ['as'], 78: ['mr'], 79: ['sa'], 82: ['cy', 'cy-GB'], 83: ['gl', 'gl-ES'],\n    87: ['kok'], 97: ['ne'], 98: ['fy'],\n}\n\nconst concatTypedArray = (a, b) => {\n    const result = new a.constructor(a.length + b.length)\n    result.set(a)\n    result.set(b, a.length)\n    return result\n}\nconst concatTypedArray3 = (a, b, c) => {\n    const result = new a.constructor(a.length + b.length + c.length)\n    result.set(a)\n    result.set(b, a.length)\n    result.set(c, a.length + b.length)\n    return result\n}\n\nconst decoder = new TextDecoder()\nconst getString = buffer => decoder.decode(buffer)\nconst getUint = buffer => {\n    if (!buffer) return\n    const l = buffer.byteLength\n    const func = l === 4 ? 'getUint32' : l === 2 ? 'getUint16' : 'getUint8'\n    return new DataView(buffer)[func](0)\n}\nconst getStruct = (def, buffer) => Object.fromEntries(Array.from(Object.entries(def))\n    .map(([key, [start, len, type]]) => [key,\n        (type === 'string' ? getString : getUint)(buffer.slice(start, start + len))]))\n\nconst getDecoder = x => new TextDecoder(MOBI_ENCODING[x])\n\nconst getVarLen = (byteArray, i = 0) => {\n    let value = 0, length = 0\n    for (const byte of byteArray.subarray(i, i + 4)) {\n        value = (value << 7) | (byte & 0b111_1111) >>> 0\n        length++\n        if (byte & 0b1000_0000) break\n    }\n    return { value, length }\n}\n\n// variable-length quantity, but read from the end of data\nconst getVarLenFromEnd = byteArray => {\n    let value = 0\n    for (const byte of byteArray.subarray(-4)) {\n        // `byte & 0b1000_0000` indicates the start of value\n        if (byte & 0b1000_0000) value = 0\n        value = (value << 7) | (byte & 0b111_1111)\n    }\n    return value\n}\n\nconst countBitsSet = x => {\n    let count = 0\n    for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++\n    return count\n}\n\nconst countUnsetEnd = x => {\n    let count = 0\n    while ((x & 1) === 0) x = x >> 1, count++\n    return count\n}\n\nconst decompressPalmDOC = array => {\n    let output = []\n    for (let i = 0; i < array.length; i++) {\n        const byte = array[i]\n        if (byte === 0) output.push(0) // uncompressed literal, just copy it\n        else if (byte <= 8) // copy next 1-8 bytes\n            for (const x of array.subarray(i + 1, (i += byte) + 1))\n                output.push(x)\n        else if (byte <= 0b0111_1111) output.push(byte) // uncompressed literal\n        else if (byte <= 0b1011_1111) {\n            // 1st and 2nd bits are 10, meaning this is a length-distance pair\n            // read next byte and combine it with current byte\n            const bytes = (byte << 8) | array[i++ + 1]\n            // the 3rd to 13th bits encode distance\n            const distance = (bytes & 0b0011_1111_1111_1111) >>> 3\n            // the last 3 bits, plus 3, is the length to copy\n            const length = (bytes & 0b111) + 3\n            for (let j = 0; j < length; j++)\n                output.push(output[output.length - distance])\n        }\n        // compressed from space plus char\n        else output.push(32, byte ^ 0b1000_0000)\n    }\n    return Uint8Array.from(output)\n}\n\nconst read32Bits = (byteArray, from) => {\n    const startByte = from >> 3\n    const end = from + 32\n    const endByte = end >> 3\n    let bits = 0n\n    for (let i = startByte; i <= endByte; i++)\n        bits = bits << 8n | BigInt(byteArray[i] ?? 0)\n    return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn\n}\n\nconst huffcdic = async (mobi, loadRecord) => {\n    const huffRecord = await loadRecord(mobi.huffcdic)\n    const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord)\n    if (magic !== 'HUFF') throw new Error('Invalid HUFF record')\n\n    // table1 is indexed by byte value\n    const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)\n        .map(offset => getUint(huffRecord.slice(offset, offset + 4)))\n        .map(x => [x & 0b1000_0000, x & 0b1_1111, x >>> 8])\n\n    // table2 is indexed by code length\n    const table2 = [null].concat(Array.from({ length: 32 }, (_, i) => offset2 + i * 8)\n        .map(offset => [\n            getUint(huffRecord.slice(offset, offset + 4)),\n            getUint(huffRecord.slice(offset + 4, offset + 8))]))\n\n    const dictionary = []\n    for (let i = 1; i < mobi.numHuffcdic; i++) {\n        const record = await loadRecord(mobi.huffcdic + i)\n        const cdic = getStruct(CDIC_HEADER, record)\n        if (cdic.magic !== 'CDIC') throw new Error('Invalid CDIC record')\n        // `numEntries` is the total number of dictionary data across CDIC records\n        // so `n` here is the number of entries in *this* record\n        const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length)\n        const buffer = record.slice(cdic.length)\n        for (let i = 0; i < n; i++) {\n            const offset = getUint(buffer.slice(i * 2, i * 2 + 2))\n            const x = getUint(buffer.slice(offset, offset + 2))\n            const length = x & 0x7fff\n            const decompressed = x & 0x8000\n            const value = new Uint8Array(\n                buffer.slice(offset + 2, offset + 2 + length))\n            dictionary.push([value, decompressed])\n        }\n    }\n\n    const decompress = byteArray => {\n        let output = new Uint8Array()\n        const bitLength = byteArray.byteLength * 8\n        for (let i = 0; i < bitLength;) {\n            const bits = Number(read32Bits(byteArray, i))\n            let [found, codeLength, value] = table1[bits >>> 24]\n            if (!found) {\n                while (bits >>> (32 - codeLength) < table2[codeLength][0])\n                    codeLength += 1\n                value = table2[codeLength][1]\n            }\n            if ((i += codeLength) > bitLength) break\n\n            const code = value - (bits >>> (32 - codeLength))\n            let [result, decompressed] = dictionary[code]\n            if (!decompressed) {\n                // the result is itself compressed\n                result = decompress(result)\n                // cache the result for next time\n                dictionary[code] = [result, true]\n            }\n            output = concatTypedArray(output, result)\n        }\n        return output\n    }\n    return decompress\n}\n\nconst getIndexData = async (indxIndex, loadRecord) => {\n    const indxRecord = await loadRecord(indxIndex)\n    const indx = getStruct(INDX_HEADER, indxRecord)\n    if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n    const decoder = getDecoder(indx.encoding)\n\n    const tagxBuffer = indxRecord.slice(indx.length)\n    const tagx = getStruct(TAGX_HEADER, tagxBuffer)\n    if (tagx.magic !== 'TAGX') throw new Error('Invalid TAGX section')\n    const numTags = (tagx.length - 12) / 4\n    const tagTable = Array.from({ length: numTags }, (_, i) =>\n        new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4)))\n\n    const cncx = {}\n    let cncxRecordOffset = 0\n    for (let i = 0; i < indx.numCncx; i++) {\n        const record = await loadRecord(indxIndex + indx.numRecords + i + 1)\n        const array = new Uint8Array(record)\n        for (let pos = 0; pos < array.byteLength;) {\n            const index = pos\n            const { value, length } = getVarLen(array, pos)\n            pos += length\n            const result = record.slice(pos, pos + value)\n            pos += value\n            cncx[cncxRecordOffset + index] = decoder.decode(result)\n        }\n        cncxRecordOffset += 0x10000\n    }\n\n    const table = []\n    for (let i = 0; i < indx.numRecords; i++) {\n        const record = await loadRecord(indxIndex + 1 + i)\n        const array = new Uint8Array(record)\n        const indx = getStruct(INDX_HEADER, record)\n        if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n        for (let j = 0; j < indx.numRecords; j++) {\n            const offsetOffset = indx.idxt + 4 + 2 * j\n            const offset = getUint(record.slice(offsetOffset, offsetOffset + 2))\n\n            const length = getUint(record.slice(offset, offset + 1))\n            const name = getString(record.slice(offset + 1, offset + 1 + length))\n\n            const tags = []\n            const startPos = offset + 1 + length\n            let controlByteIndex = 0\n            let pos = startPos + tagx.numControlBytes\n            for (const [tag, numValues, mask, end] of tagTable) {\n                if (end & 1) {\n                    controlByteIndex++\n                    continue\n                }\n                const offset = startPos + controlByteIndex\n                const value = getUint(record.slice(offset, offset + 1)) & mask\n                if (value === mask) {\n                    if (countBitsSet(mask) > 1) {\n                        const { value, length } = getVarLen(array, pos)\n                        tags.push([tag, null, value, numValues])\n                        pos += length\n                    } else tags.push([tag, 1, null, numValues])\n                } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues])\n            }\n\n            const tagMap = {}\n            for (const [tag, valueCount, valueBytes, numValues] of tags) {\n                const values = []\n                if (valueCount != null) {\n                    for (let i = 0; i < valueCount * numValues; i++) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                    }\n                } else {\n                    let count = 0\n                    while (count < valueBytes) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                        count += length\n                    }\n                }\n                tagMap[tag] = values\n            }\n            table.push({ name, tagMap })\n        }\n    }\n    return { table, cncx }\n}\n\nconst getNCX = async (indxIndex, loadRecord) => {\n    const { table, cncx } = await getIndexData(indxIndex, loadRecord)\n    const items = table.map(({ tagMap }, index) => ({\n        index,\n        offset: tagMap[1]?.[0],\n        size: tagMap[2]?.[0],\n        label: cncx[tagMap[3]] ?? '',\n        headingLevel: tagMap[4]?.[0],\n        pos: tagMap[6],\n        parent: tagMap[21]?.[0],\n        firstChild: tagMap[22]?.[0],\n        lastChild: tagMap[23]?.[0],\n    }))\n    const getChildren = item => {\n        if (item.firstChild == null) return item\n        item.children = items.filter(x => x.parent === item.index).map(getChildren)\n        return item\n    }\n    return items.filter(item => item.headingLevel === 0).map(getChildren)\n}\n\nconst getEXTH = (buf, encoding) => {\n    const { magic, count } = getStruct(EXTH_HEADER, buf)\n    if (magic !== 'EXTH') throw new Error('Invalid EXTH header')\n    const decoder = getDecoder(encoding)\n    const results = {}\n    let offset = 12\n    for (let i = 0; i < count; i++) {\n        const type = getUint(buf.slice(offset, offset + 4))\n        const length = getUint(buf.slice(offset + 4, offset + 8))\n        if (type in EXTH_RECORD_TYPE) {\n            const [name, typ, many] = EXTH_RECORD_TYPE[type]\n            const data = buf.slice(offset + 8, offset + length)\n            const value = typ === 'uint' ? getUint(data) : decoder.decode(data)\n            if (many) {\n                results[name] ??= []\n                results[name].push(value)\n            } else results[name] = value\n        }\n        offset += length\n    }\n    return results\n}\n\nconst getFont = async (buf, unzlib) => {\n    const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf)\n    const array = new Uint8Array(buf.slice(dataStart))\n    // deobfuscate font\n    if (flags & 0b10) {\n        const bytes = keyLength === 16 ? 1024 : 1040\n        const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength))\n        const length = Math.min(bytes, array.length)\n        for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    }\n    // decompress font\n    if (flags & 1) try {\n        return await unzlib(array)\n    } catch (e) {\n        console.warn(e)\n        console.warn('Failed to decompress font')\n    }\n    return array\n}\n\nexport const isMOBI = async file => {\n    const magic = getString(await file.slice(60, 68).arrayBuffer())\n    return magic === 'BOOKMOBI'// || magic === 'TEXtREAd'\n}\n\nclass PDB {\n    #file\n    #offsets\n    pdb\n    async open(file) {\n        this.#file = file\n        const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer())\n        this.pdb = pdb\n        const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer()\n        // get start and end offsets for each record\n        this.#offsets = Array.from({ length: pdb.numRecords },\n            (_, i) => getUint(buffer.slice(i * 8, i * 8 + 4)))\n            .map((x, i, a) => [x, a[i + 1]])\n    }\n    loadRecord(index) {\n        const offsets = this.#offsets[index]\n        if (!offsets) throw new RangeError('Record index out of bounds')\n        return this.#file.slice(...offsets).arrayBuffer()\n    }\n    async loadMagic(index) {\n        const start = this.#offsets[index][0]\n        return getString(await this.#file.slice(start, start + 4).arrayBuffer())\n    }\n}\n\nexport class MOBI extends PDB {\n    #start = 0\n    #resourceStart\n    #decoder\n    #encoder\n    #decompress\n    #removeTrailingEntries\n    constructor({ unzlib }) {\n        super()\n        this.unzlib = unzlib\n    }\n    async open(file) {\n        await super.open(file)\n        // TODO: if (this.pdb.type === 'TEXt')\n        this.headers = this.#getHeaders(await super.loadRecord(0))\n        this.#resourceStart = this.headers.mobi.resourceStart\n        let isKF8 = this.headers.mobi.version >= 8\n        if (!isKF8) {\n            const boundary = this.headers.exth?.boundary\n            if (boundary < 0xffffffff) try {\n                // it's a \"combo\" MOBI/KF8 file; try to open the KF8 part\n                this.headers = this.#getHeaders(await super.loadRecord(boundary))\n                this.#start = boundary\n                isKF8 = true\n            } catch (e) {\n                console.warn(e)\n                console.warn('Failed to open KF8; falling back to MOBI')\n            }\n        }\n        await this.#setup()\n        return isKF8 ? new KF8(this).init() : new MOBI6(this).init()\n    }\n    #getHeaders(buf) {\n        const palmdoc = getStruct(PALMDOC_HEADER, buf)\n        const mobi = getStruct(MOBI_HEADER, buf)\n        if (mobi.magic !== 'MOBI') throw new Error('Missing MOBI header')\n\n        const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi\n        mobi.title = buf.slice(titleOffset, titleOffset + titleLength)\n        const lang = MOBI_LANG[localeLanguage]\n        mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0]\n\n        const exth = mobi.exthFlag & 0b100_0000\n            ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null\n        const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null\n        return { palmdoc, mobi, exth, kf8 }\n    }\n    async #setup() {\n        const { palmdoc, mobi } = this.headers\n        this.#decoder = getDecoder(mobi.encoding)\n        // `TextEncoder` only supports UTF-8\n        // we are only encoding ASCII anyway, so I think it's fine\n        this.#encoder = new TextEncoder()\n\n        // set up decompressor\n        const { compression } = palmdoc\n        this.#decompress = compression === 1 ? f => f\n            : compression === 2 ? decompressPalmDOC\n            : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this))\n            : null\n        if (!this.#decompress) throw new Error('Unknown compression type')\n\n        // set up function for removing trailing bytes\n        const { trailingFlags } = mobi\n        const multibyte = trailingFlags & 1\n        const numTrailingEntries = countBitsSet(trailingFlags >>> 1)\n        this.#removeTrailingEntries = array => {\n            for (let i = 0; i < numTrailingEntries; i++) {\n                const length = getVarLenFromEnd(array)\n                array = array.subarray(0, -length)\n            }\n            if (multibyte) {\n                const length = (array[array.length - 1] & 0b11) + 1\n                array = array.subarray(0, -length)\n            }\n            return array\n        }\n    }\n    decode(...args) {\n        return this.#decoder.decode(...args)\n    }\n    encode(...args) {\n        return this.#encoder.encode(...args)\n    }\n    loadRecord(index) {\n        return super.loadRecord(this.#start + index)\n    }\n    loadMagic(index) {\n        return super.loadMagic(this.#start + index)\n    }\n    loadText(index) {\n        return this.loadRecord(index + 1)\n            .then(buf => new Uint8Array(buf))\n            .then(this.#removeTrailingEntries)\n            .then(this.#decompress)\n    }\n    async loadResource(index) {\n        const buf = await super.loadRecord(this.#resourceStart + index)\n        const magic = getString(buf.slice(0, 4))\n        if (magic === 'FONT') return getFont(buf, this.unzlib)\n        if (magic === 'VIDE' || magic === 'AUDI') return buf.slice(12)\n        return buf\n    }\n    getNCX() {\n        const index = this.headers.mobi.indx\n        if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this))\n    }\n    getMetadata() {\n        const { mobi, exth } = this.headers\n        return {\n            identifier: mobi.uid.toString(),\n            title: unescapeHTML(exth?.title || this.decode(mobi.title)),\n            author: exth?.creator?.map(unescapeHTML),\n            publisher: unescapeHTML(exth?.publisher),\n            language: exth?.language ?? mobi.language,\n            published: exth?.date,\n            description: unescapeHTML(exth?.description),\n            subject: exth?.subject?.map(unescapeHTML),\n            rights: unescapeHTML(exth?.rights),\n            contributor: exth?.contributor,\n        }\n    }\n    async getCover() {\n        const { exth } = this.headers\n        const offset = exth?.coverOffset < 0xffffffff ? exth?.coverOffset\n            : exth?.thumbnailOffset < 0xffffffff ? exth?.thumbnailOffset : null\n        if (offset != null) {\n            const buf = await this.loadResource(offset)\n            return new Blob([buf])\n        }\n    }\n}\n\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi\nconst fileposRegex = /<[^<>]+filepos=['\"]{0,1}(\\d+)[^<>]*>/gi\n\nconst getIndent = el => {\n    let x = 0\n    while (el) {\n        const parent = el.parentElement\n        if (parent) {\n            const tag = parent.tagName.toLowerCase()\n            if (tag === 'p') x += 1.5\n            else if (tag === 'blockquote') x += 2\n        }\n        el = parent\n    }\n    return x\n}\n\nfunction rawBytesToString(uint8Array) {\n    const chunkSize = 0x8000\n    let result = ''\n    for (let i = 0; i < uint8Array.length; i += chunkSize) {\n        result += String.fromCharCode.apply(null, uint8Array.subarray(i, i + chunkSize))\n    }\n    return result\n}\n\nclass MOBI6 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #resourceCache = new Map()\n    #textCache = new Map()\n    #cache = new Map()\n    #sections\n    #fileposList = []\n    #type = MIME.HTML\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const recordBuffers = []\n        for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++) {\n            const buf = await this.mobi.loadText(i)\n            recordBuffers.push(buf)\n        }\n        const totalLength = recordBuffers.reduce((sum, buf) => sum + buf.byteLength, 0)\n        // load all text records in an array\n        const array = new Uint8Array(totalLength)\n        recordBuffers.reduce((offset, buf) => {\n            array.set(new Uint8Array(buf), offset)\n            return offset + buf.byteLength\n        }, 0)\n        // convert to string so we can use regex\n        // note that `filepos` are byte offsets\n        // so it needs to preserve each byte as a separate character\n        // (see https://stackoverflow.com/q/50198017)\n        const str = rawBytesToString(array)\n\n        // split content into sections at each `<mbp:pagebreak>`\n        this.#sections = [0]\n            .concat(Array.from(str.matchAll(mbpPagebreakRegex), m => m.index))\n            .map((start, i, a) => {\n                const end = a[i + 1] ?? array.length\n                return { book: this, raw: array.subarray(start, end) }\n            })\n            // get start and end filepos for each section\n            .map((section, i, arr) => {\n                section.start = arr[i - 1]?.end ?? 0\n                section.end = section.start + section.raw.byteLength\n                return section\n            })\n\n        this.sections = this.#sections.map((section, index) => ({\n            id: index,\n            load: () => this.loadSection(section),\n            createDocument: () => this.createDocument(section),\n            size: section.end - section.start,\n        }))\n\n        try {\n            this.landmarks = await this.getGuide()\n            const tocHref = this.landmarks\n                .find(({ type }) => type?.includes('toc'))?.href\n            if (tocHref) {\n                const { index } = this.resolveHref(tocHref)\n                const doc = await this.sections[index].createDocument()\n                let lastItem\n                let lastLevel = 0\n                let lastIndent = 0\n                const lastLevelOfIndent = new Map()\n                const lastParentOfLevel = new Map()\n                this.toc = Array.from(doc.querySelectorAll('a[filepos]'))\n                    .reduce((arr, a) => {\n                        const indent = getIndent(a)\n                        const item = {\n                            label: a.innerText?.trim() ?? '',\n                            href: `filepos:${a.getAttribute('filepos')}`,\n                        }\n                        const level = indent > lastIndent ? lastLevel + 1\n                            : indent === lastIndent ? lastLevel\n                            : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1)\n                        if (level > lastLevel) {\n                            if (lastItem) {\n                                lastItem.subitems ??= []\n                                lastItem.subitems.push(item)\n                                lastParentOfLevel.set(level, lastItem)\n                            }\n                            else arr.push(item)\n                        }\n                        else {\n                            const parent = lastParentOfLevel.get(level)\n                            if (parent) parent.subitems.push(item)\n                            else arr.push(item)\n                        }\n                        lastItem = item\n                        lastLevel = level\n                        lastIndent = indent\n                        lastLevelOfIndent.set(indent, level)\n                        return arr\n                    }, [])\n            }\n        } catch(e) {\n            console.warn(e)\n        }\n\n        // get list of all `filepos` references in the book,\n        // which will be used to insert anchor elements\n        // because only then can they be referenced in the DOM\n        this.#fileposList = [...new Set(\n            Array.from(str.matchAll(fileposRegex), m => m[1]))]\n            .map(filepos => ({ filepos, number: Number(filepos) }))\n            .sort((a, b) => a.number - b.number)\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    async getGuide() {\n        const doc = await this.createDocument(this.#sections[0])\n        return Array.from(doc.getElementsByTagName('reference'), ref => ({\n            label: ref.getAttribute('title'),\n            type: ref.getAttribute('type')?.split(/\\s/),\n            href: `filepos:${ref.getAttribute('filepos')}`,\n        }))\n    }\n    async loadResource(index) {\n        if (this.#resourceCache.has(index)) return this.#resourceCache.get(index)\n        const raw = await this.mobi.loadResource(index)\n        const url = URL.createObjectURL(new Blob([raw]))\n        this.#resourceCache.set(index, url)\n        return url\n    }\n    async loadRecindex(recindex) {\n        return this.loadResource(Number(recindex) - 1)\n    }\n    async replaceResources(doc) {\n        for (const img of doc.querySelectorAll('img[recindex]')) {\n            const recindex = img.getAttribute('recindex')\n            try {\n                img.src = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load image ${recindex}`)\n            }\n        }\n        for (const media of doc.querySelectorAll('[mediarecindex]')) {\n            const mediarecindex = media.getAttribute('mediarecindex')\n            const recindex = media.getAttribute('recindex')\n            try {\n                media.src = await this.loadRecindex(mediarecindex)\n                if (recindex) media.poster = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load media ${mediarecindex}`)\n            }\n        }\n        for (const a of doc.querySelectorAll('[filepos]')) {\n            const filepos = a.getAttribute('filepos')\n            a.href = `filepos:${filepos}`\n        }\n    }\n    async loadText(section) {\n        if (this.#textCache.has(section)) return this.#textCache.get(section)\n        const { raw } = section\n\n        // insert anchor elements for each `filepos`\n        const fileposList = this.#fileposList\n            .filter(({ number }) => number >= section.start && number < section.end)\n            .map(obj => ({ ...obj, offset: obj.number - section.start }))\n        let arr = raw\n        if (fileposList.length) {\n            arr = raw.subarray(0, fileposList[0].offset)\n            fileposList.forEach(({ filepos, offset }, i) => {\n                const next = fileposList[i + 1]\n                const a = this.mobi.encode(`<a id=\"filepos${filepos}\"></a>`)\n                arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset))\n            })\n        }\n        const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, '')\n        this.#textCache.set(section, str)\n        return str\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const doc = await this.createDocument(section)\n\n        // inject default stylesheet\n        const style = doc.createElement('style')\n        doc.head.append(style)\n        // blockquotes in MOBI seem to have only a small left margin by default\n        // many books seem to rely on this, as it's the only way to set margin\n        // (since there's no CSS)\n        style.append(doc.createTextNode(`blockquote {\n            margin-block-start: 0;\n            margin-block-end: 0;\n            margin-inline-start: 1em;\n            margin-inline-end: 0;\n        }`))\n\n        await this.replaceResources(doc)\n        const result = this.serializer.serializeToString(doc)\n        const url = URL.createObjectURL(new Blob([result], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    resolveHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        const anchor = doc => doc.getElementById(`filepos${filepos}`)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        return [index, `filepos${filepos}`]\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n    }\n    isExternal(uri) {\n        return /^(?!blob|filepos)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url)\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\n// handlers for `kindle:` uris\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/\nconst parseResourceURI = str => {\n    const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1)\n    return { resourceType, id: parseInt(id, 32), type }\n}\nconst parsePosURI = str => {\n    const [fid, off] = str.match(kindlePosRegex).slice(1)\n    return { fid: parseInt(fid, 32), off: parseInt(off, 32) }\n}\nconst makePosURI = (fid = 0, off = 0) =>\n    `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, '0')\n    }:off:${off.toString(32).toUpperCase().padStart(10, '0')}`\n\n// `kindle:pos:` links are originally links that contain fragments identifiers\n// so there should exist an element with `id` or `name`\n// otherwise try to find one with an `aid` attribute\nconst getFragmentSelector = str => {\n    const match = str.match(/\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i)\n    if (!match) return\n    const [, attr, value] = match\n    return `[${attr}=\"${CSS.escape(value)}\"]`\n}\n\n// replace asynchronously and sequentially\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nclass KF8 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    transformTarget = new EventTarget()\n    #cache = new Map()\n    #fragmentOffsets = new Map()\n    #fragmentSelectors = new Map()\n    #tables = {}\n    #sections\n    #fullRawLength\n    #rawHead = new Uint8Array()\n    #rawTail = new Uint8Array()\n    #lastLoadedHead = -1\n    #lastLoadedTail = -1\n    #type = MIME.XHTML\n    #inlineMap = new Map()\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n        const { kf8 } = this.mobi.headers\n\n        try {\n            const fdstBuffer = await loadRecord(kf8.fdst)\n            const fdst = getStruct(FDST_HEADER, fdstBuffer)\n            if (fdst.magic !== 'FDST') throw new Error('Missing FDST record')\n            const fdstTable = Array.from({ length: fdst.numEntries },\n                (_, i) => 12 + i * 8)\n                .map(offset => [\n                    getUint(fdstBuffer.slice(offset, offset + 4)),\n                    getUint(fdstBuffer.slice(offset + 4, offset + 8))])\n            this.#tables.fdstTable = fdstTable\n            this.#fullRawLength = fdstTable[fdstTable.length - 1][1]\n        } catch {}\n\n        const skelTable = (await getIndexData(kf8.skel, loadRecord)).table\n            .map(({ name, tagMap }, index) => ({\n                index, name,\n                numFrag: tagMap[1][0],\n                offset: tagMap[6][0],\n                length: tagMap[6][1],\n            }))\n        const fragData = await getIndexData(kf8.frag, loadRecord)\n        const fragTable = fragData.table.map(({ name, tagMap }) => ({\n            insertOffset: parseInt(name),\n            selector: fragData.cncx[tagMap[2][0]],\n            index: tagMap[4][0],\n            offset: tagMap[6][0],\n            length: tagMap[6][1],\n        }))\n        this.#tables.skelTable = skelTable\n        this.#tables.fragTable = fragTable\n\n        this.#sections = skelTable.reduce((arr, skel) => {\n            const last = arr[arr.length - 1]\n            const fragStart = last?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag\n            const frags = fragTable.slice(fragStart, fragEnd)\n            const length = skel.length + frags.map(f => f.length).reduce((a, b) => a + b, 0)\n            const totalLength = (last?.totalLength ?? 0) + length\n            return arr.concat({ skel, frags, fragEnd, length, totalLength })\n        }, [])\n\n        const resources = await this.getResourcesByMagic(['RESC', 'PAGE'])\n        const pageSpreads = new Map()\n        if (resources.RESC) {\n            const buf = await this.mobi.loadRecord(resources.RESC)\n            const str = this.mobi.decode(buf.slice(16)).replace(/\\0/g, '')\n            // the RESC record lacks the root `<package>` element\n            // but seem to be otherwise valid XML\n            const index = str.search(/\\?>/)\n            const xmlStr = `<package>${str.slice(index)}</package>`\n            const opf = this.parser.parseFromString(xmlStr, MIME.XML)\n            for (const $itemref of opf.querySelectorAll('spine > itemref')) {\n                const i = parseInt($itemref.getAttribute('skelid'))\n                pageSpreads.set(i, getPageSpread(\n                    $itemref.getAttribute('properties')?.split(' ') ?? []))\n            }\n        }\n\n        this.sections = this.#sections.map((section, index) =>\n            section.frags.length ? ({\n                id: index,\n                load: () => this.loadSection(section),\n                createDocument: () => this.createDocument(section),\n                size: section.length,\n                pageSpread: pageSpreads.get(index),\n            }) : ({ linear: 'no' }))\n\n        try {\n            const ncx = await this.mobi.getNCX()\n            const map = ({ label, pos, children }) => {\n                const [fid, off] = pos\n                const href = makePosURI(fid, off)\n                const arr = this.#fragmentOffsets.get(fid)\n                if (arr) arr.push(off)\n                else this.#fragmentOffsets.set(fid, [off])\n                return { label: unescapeHTML(label), href, subitems: children?.map(map) }\n            }\n            this.toc = ncx?.map(map)\n            this.landmarks = await this.getGuide()\n        } catch(e) {\n            console.warn(e)\n        }\n\n        const { exth } = this.mobi.headers\n        this.dir = exth.pageProgressionDirection\n        this.rendition = {\n            layout: exth.fixedLayout === 'true' ? 'pre-paginated' : 'reflowable',\n            viewport: Object.fromEntries(exth.originalResolution\n                ?.split('x')?.slice(0, 2)\n                ?.map((x, i) => [i ? 'height' : 'width', x]) ?? []),\n        }\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    // is this really the only way of getting to RESC, PAGE, etc.?\n    async getResourcesByMagic(keys) {\n        const results = {}\n        const start = this.mobi.headers.kf8.resourceStart\n        const end = this.mobi.pdb.numRecords\n        for (let i = start; i < end; i++) {\n            try {\n                const magic = await this.mobi.loadMagic(i)\n                const match = keys.find(key => key === magic)\n                if (match) results[match] = i\n            } catch {}\n        }\n        return results\n    }\n    async getGuide() {\n        const index = this.mobi.headers.kf8.guide\n        if (index < 0xffffffff) {\n            const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n            const { table, cncx } = await getIndexData(index, loadRecord)\n            return table.map(({ name, tagMap }) => ({\n                label: cncx[tagMap[1][0]] ?? '',\n                type: name?.split(/\\s/),\n                href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),\n            }))\n        }\n    }\n    async loadResourceBlob(str) {\n        const { resourceType, id, type } = parseResourceURI(str)\n        const raw = resourceType === 'flow' ? await this.loadFlow(id)\n            : await this.mobi.loadResource(id - 1)\n        const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type)\n            ? await this.replaceResources(this.mobi.decode(raw)) : raw\n        const detail = { data: result, type }\n        const event = new CustomEvent('data', { detail })\n        this.transformTarget.dispatchEvent(event)\n        const newData = await event.detail.data\n        const newType = await event.detail.type\n        const doc = newType === MIME.SVG ? this.parser.parseFromString(newData, newType) : null\n        return [new Blob([newData], { newType }),\n            // SVG wrappers need to be inlined\n            // as browsers don't allow external resources when loading SVG as an image\n            doc?.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')?.length\n                ? doc.documentElement : null]\n    }\n    async loadResource(str) {\n        if (this.#cache.has(str)) return this.#cache.get(str)\n        const [blob, inline] = await this.loadResourceBlob(str)\n        const url = inline ? str : URL.createObjectURL(blob)\n        if (inline) this.#inlineMap.set(url, inline)\n        this.#cache.set(str, url)\n        return url\n    }\n    replaceResources(str) {\n        const regex = new RegExp(kindleResourceRegex, 'g')\n        return replaceSeries(str, regex, this.loadResource.bind(this))\n    }\n    // NOTE: there doesn't seem to be a way to access text randomly?\n    // how to know the decompressed size of the records without decompressing?\n    // 4096 is just the maximum size\n    async loadRaw(start, end) {\n        // here we load either from the front or back until we have reached the\n        // required offsets; at worst you'd have to load half the book at once\n        const distanceHead = end - this.#rawHead.length\n        const distanceEnd = this.#fullRawLength == null ? Infinity\n            : (this.#fullRawLength - this.#rawTail.length) - start\n        // load from the start\n        if (distanceHead < 0 || distanceHead < distanceEnd) {\n            while (this.#rawHead.length < end) {\n                const index = ++this.#lastLoadedHead\n                const data = await this.mobi.loadText(index)\n                this.#rawHead = concatTypedArray(this.#rawHead, data)\n            }\n            return this.#rawHead.slice(start, end)\n        }\n        // load from the end\n        while (this.#fullRawLength - this.#rawTail.length > start) {\n            const index = this.mobi.headers.palmdoc.numTextRecords - 1\n                - (++this.#lastLoadedTail)\n            const data = await this.mobi.loadText(index)\n            this.#rawTail = concatTypedArray(data, this.#rawTail)\n        }\n        const rawTailStart = this.#fullRawLength - this.#rawTail.length\n        return this.#rawTail.slice(start - rawTailStart, end - rawTailStart)\n    }\n    loadFlow(index) {\n        if (index < 0xffffffff)\n            return this.loadRaw(...this.#tables.fdstTable[index])\n    }\n    async loadText(section) {\n        const { skel, frags, length } = section\n        const raw = await this.loadRaw(skel.offset, skel.offset + length)\n        let skeleton = raw.slice(0, skel.length)\n        for (const frag of frags) {\n            const insertOffset = frag.insertOffset - skel.offset\n            const offset = skel.length + frag.offset\n            const fragRaw = raw.slice(offset, offset + frag.length)\n            skeleton = concatTypedArray3(\n                skeleton.slice(0, insertOffset), fragRaw,\n                skeleton.slice(insertOffset))\n\n            const offsets = this.#fragmentOffsets.get(frag.index)\n            if (offsets) for (const offset of offsets) {\n                const str = this.mobi.decode(fragRaw.slice(offset))\n                const selector = getFragmentSelector(str)\n                this.#setFragmentSelector(frag.index, offset, selector)\n            }\n        }\n        return this.mobi.decode(skeleton)\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const str = await this.loadText(section)\n        const replaced = await this.replaceResources(str)\n\n        // by default, type is XHTML; change to HTML if it's not valid XHTML\n        let doc = this.parser.parseFromString(replaced, this.#type)\n        if (doc.querySelector('parsererror') || !doc.documentElement?.namespaceURI) {\n            this.#type = MIME.HTML\n            doc = this.parser.parseFromString(replaced, this.#type)\n        }\n        for (const [url, node] of this.#inlineMap) {\n            for (const el of doc.querySelectorAll(`img[src=\"${url}\"]`))\n                el.replaceWith(node)\n        }\n        const url = URL.createObjectURL(\n            new Blob([this.serializer.serializeToString(doc)], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    getIndexByFID(fid) {\n        return this.#sections.findIndex(section =>\n            section.frags.some(frag => frag.index === fid))\n    }\n    #setFragmentSelector(id, offset, selector) {\n        const map = this.#fragmentSelectors.get(id)\n        if (map) map.set(offset, selector)\n        else {\n            const map = new Map()\n            this.#fragmentSelectors.set(id, map)\n            map.set(offset, selector)\n        }\n    }\n    async resolveHref(href) {\n        const { fid, off } = parsePosURI(href)\n        const index = this.getIndexByFID(fid)\n        if (index < 0) return\n\n        const saved = this.#fragmentSelectors.get(fid)?.get(off)\n        if (saved) return { index, anchor: doc => doc.querySelector(saved) }\n\n        const { skel, frags } = this.#sections[index]\n        const frag = frags.find(frag => frag.index === fid)\n        const offset = skel.offset + skel.length + frag.offset\n        const fragRaw = await this.loadRaw(offset, offset + frag.length)\n        const str = this.mobi.decode(fragRaw.slice(off))\n        const selector = getFragmentSelector(str)\n        this.#setFragmentSelector(fid, off, selector)\n        const anchor = doc => doc.querySelector(selector)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const pos = parsePosURI(href)\n        const index = this.getIndexByFID(pos.fid)\n        return [index, pos]\n    }\n    getTOCFragment(doc, { fid, off }) {\n        const selector = this.#fragmentSelectors.get(fid)?.get(off)\n        return doc.querySelector(selector)\n    }\n    isExternal(uri) {\n        return /^(?!blob|kindle)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
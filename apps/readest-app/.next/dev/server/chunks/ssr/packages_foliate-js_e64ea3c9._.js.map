{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/epubcfi.js"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAM,cAAc,CAAC,KAAK,IAAM,IAC3B,GAAG,CAAC,CAAC,GAAG,GAAG,IAAM,EAAE,GAAG,GAAG,KAAK,IAAI,MAAM,MAAM,CAAC,CAAA,IAAK,KAAK;AAC9D,MAAM,UAAU,CAAC,KAAK,KAAO;QAAC,CAAC;WAAM;QAAI,IAAI,MAAM;KAAC,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,IACpE,CAAC;YAAE,IAAI,IAAI,OAAO;gBAAC,IAAI,KAAK,CAAC,IAAI,GAAG;aAAG,KAAK,EAAE;YAAE,GAAG;QAAE,CAAC,GAAG,CAAC,GAAG,EAAE;AACnE,MAAM,eAAe,CAAC,GAAG,IACrB,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;QAAC,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;KAAE,EAAE,MAAM,CAAC,EAAE,KAAK,CAAC;AAEzE,MAAM,WAAW;AACV,MAAM,QAAQ;AACrB,MAAM,YAAY,CAAA,MAAO,IAAI,OAAO,CAAC,iBAAiB;AAEtD,MAAM,OAAO,CAAA,IAAK,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;AACrD,MAAM,SAAS,CAAA,IAAK,EAAE,KAAK,CAAC,QAAQ,CAAC,EAAE,IAAI;AAC3C,MAAM,OAAO,CAAA,IAAK,CAAC,GAAG,KAClB,CAAC,QAAQ,EAAE,KAAK,GAAG,GAAG,CAAC,CAAA,IAAK,EAAE,KAAK,CAAC,QAAQ,CAAC,EAAE,IAAI,IAAI,CAAC,CAAC;AACtD,MAAM,YAAY,KAAK,CAAC,GAAG,KAAO,GAAG,IAAI,CAAC;AAEjD,MAAM,YAAY,CAAA;IACd,MAAM,SAAS,EAAE;IACjB,IAAI,OAAO,QAAQ,QAAQ;IAC3B,MAAM,OAAO,CAAA,IAAK,CAAC,OAAO,IAAI,CAAC,IAAI,QAAQ,MAAM,QAAQ,EAAE;IAC3D,MAAM,MAAM,CAAA,IAAK,CAAC,SAAS,GAAG,SAAS,KAAK;IAC5C,KAAK,MAAM,QAAQ,MAAM,IAAI,CAAC,IAAI,IAAI,IAAI,MAAM,CAAC,IAAK;QAClD,IAAI,SAAS,OAAO,CAAC,QAAQ;YACzB,SAAS;YACT;QACJ;QACA,IAAI,UAAU,KAAK,KAAK;YAAC;SAAI;aACxB,IAAI,UAAU,KAAK,KAAK;YAAC;SAAI;aAC7B,IAAI,UAAU,OAAO,UAAU,KAAK;YACrC,IAAI,SAAS,IAAI,CAAC,OAAO;gBACrB,IAAI;gBACJ;YACJ,OAAO,KAAK;gBAAC;gBAAO,SAAS;aAAO;QACxC,OAAO,IAAI,UAAU,KAAK;YACtB,IAAI,SAAS,IAAI,CAAC,SAAS,SAAS,KAAK;gBACrC,IAAI;gBACJ;YACJ,OAAO,KAAK;gBAAC;gBAAK,WAAW;aAAO;QACxC,OAAO,IAAI,UAAU,KAAK;YACtB,IAAI,SAAS,KAAK;gBACd,KAAK;oBAAC;oBAAK,WAAW;iBAAO;gBAC7B,QAAQ;gBACR;YACJ;YACA,IAAI,SAAS,IAAI,CAAC,SAAS,SAAS,KAAK;gBACrC,IAAI;gBACJ;YACJ,OAAO,KAAK;gBAAC;gBAAK,WAAW;aAAO;QACxC,OAAO,IAAI,UAAU,KAAK;YACtB,IAAI,SAAS,OAAO,CAAC,QAAQ;gBACzB,KAAK;oBAAC;oBAAK;iBAAM;gBACjB,QAAQ;YACZ,OAAO,IAAI,SAAS,OAAO,CAAC,QAAQ;gBAChC,KAAK;oBAAC;oBAAK;iBAAM;gBACjB,QAAQ;YACZ,OAAO,IAAI,SAAS,OAAO,CAAC,QAAQ,KAAK;gBAAC;gBAAK;aAAM;iBAChD,IAAI;YACT;QACJ,OAAO,IAAI,OAAO,WAAW,MAAM;YAC/B,IAAI,SAAS,OAAO,CAAC,QAAQ;gBACzB,QAAQ,CAAC,CAAC,EAAE,OAAO;gBACnB,QAAQ;YACZ,OAAO,IAAI,SAAS,OAAO,CAAC,QAAQ;gBAChC,KAAK;oBAAC;oBAAO;iBAAM;gBACnB,QAAQ;YACZ,OAAO,IAAI,SAAS,OAAO,CAAC,QAAQ,KAAK;gBAAC;gBAAO;aAAM;iBAClD,IAAI;YACT;QACJ;QACA,IAAI,SAAS,OAAO,SAAS,OAAO,SAAS,OAAO,SAAS,OAC1D,SAAS,OAAO,SAAS,OAAO,SAAS,KAAK,QAAQ;IAC7D;IACA,OAAO;AACX;AAEA,MAAM,aAAa,CAAC,QAAQ,IAAM,YAAY,QAAQ,CAAC,CAAC,EAAE,GAAK,MAAM;AAErE,MAAM,SAAS,CAAA;IACX,MAAM,QAAQ,EAAE;IAChB,IAAI;IACJ,KAAK,MAAM,CAAC,MAAM,IAAI,IAAI,OAAQ;QAC9B,IAAI,SAAS,KAAK,MAAM,IAAI,CAAC;YAAE,OAAO;QAAI;aACrC;YACD,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;YACpC,IAAI,SAAS,KAAK,KAAK,MAAM,GAAG;iBAC3B,IAAI,SAAS,KAAK,KAAK,QAAQ,GAAG;iBAClC,IAAI,SAAS,KAAK,KAAK,OAAO,GAAG,CAAC,KAAK,OAAO,IAAI,EAAE,EAAE,MAAM,CAAC;iBAC7D,IAAI,SAAS,MAAM,KAAK,IAAI,GAAG;iBAC/B,IAAI,SAAS,KAAK;gBACnB,IAAI,UAAU,OAAO,KAAK,KAAK,EAAE,GAAG;qBAC/B;oBACD,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,IAAI,EAAE,EAAE,MAAM,CAAC;oBACrC;gBACJ;YACJ;QACJ;QACA,QAAQ;IACZ;IACA,OAAO;AACX;AAEA,mDAAmD;AACnD,MAAM,cAAc,CAAA,SAChB,QAAQ,QAAQ,WAAW,QAAQ,MAAM,GAAG,CAAC;AAE1C,MAAM,QAAQ,CAAA;IACjB,MAAM,SAAS,UAAU,OAAO;IAChC,MAAM,SAAS,WAAW,QAAQ;IAClC,IAAI,CAAC,OAAO,MAAM,EAAE,OAAO,YAAY;IACvC,MAAM,CAAC,QAAQ,OAAO,IAAI,GAAG,QAAQ,QAAQ,QAAQ,GAAG,CAAC;IACzD,OAAO;QAAE;QAAQ;QAAO;IAAI;AAChC;AAEA,MAAM,eAAe,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACtE,MAAM,QAAQ,OAAO,CAAC,GAAG,EAAE,MAAM,GAAG;IACpC,OAAO,CAAC,CAAC,EAAE,OAAO,GACZ,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,MAAM,MAAM,CAAC,CAAC,GAAG,EAAE,IAEvC,CAAC,UAAU,QAAQ,QAAQ,IAAI,CAAC,CAAC,EAAE,QAAQ,GAAG,EAAE,IAChD,CAAC,WAAW,CAAC,CAAC,EAAE,UAAU,GAAG,EAAE,IAC/B,CAAC,UAAU,CAAC,CAAC,EAAE,QAAQ,IAAI,CAAC,MAAM,GAAG,EAAE,IACvC,CAAC,QAAS,CAAC,MAAM,OAAQ,MACrB,CAAC,MAAM,IAAI,YAAY,KAAK,QAAQ,EAAE,IACtC,QAAQ,MAAM,EAAE;AAC9B;AAEA,MAAM,gBAAgB,CAAA,SAAU,OAAO,MAAM,GACvC;QAAC,OAAO,MAAM;QAAE,OAAO,KAAK;QAAE,OAAO,GAAG;KAAC,CAAC,GAAG,CAAC,eAAe,IAAI,CAAC,OAClE,OAAO,GAAG,CAAC,CAAA,QAAS,MAAM,GAAG,CAAC,cAAc,IAAI,CAAC,KAAK,IAAI,CAAC;AAEjE,MAAM,WAAW,CAAA,SAAU,KAAK,cAAc;AAEvC,MAAM,WAAW,CAAC,GAAG,QAAU,OAAO,MAAM,WAC7C,SAAS,SAAS,MAAM,IAAI,UAC5B,EAAE,MAAM,GAAG,aAAa,EAAE,MAAM,EAAE,CAAC,CAAC,QAAQ,QAAQ,QAAQ,IAAI;AAEtE,iCAAiC;AACjC,MAAM,aAAa,CAAC,MAAM;IACtB,IAAI,OAAO,SAAS,UAAU,OAAO,MAAM;IAC3C,IAAI,OAAO,OAAO,UAAU,KAAK,MAAM;IACvC,OAAO,SAAS;IAChB,KAAK,SAAS,IAAI;IAClB,4EAA4E;IAC5E,MAAM,YAAY,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,EAAE,UAAU,EAAE,CAAC,GAAG,MAAM,GAAG,EAAE;IACpE,MAAM,cAAc,EAAE,EAAE,aAAa,EAAE,EAAE,WAAW,EAAE;IACtD,IAAI,eAAe;IACnB,MAAM,MAAM,KAAK,GAAG,CAAC,UAAU,MAAM,EAAE,QAAQ,MAAM;IACrD,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC1B,MAAM,IAAI,SAAS,CAAC,EAAE,EAAE,IAAI,OAAO,CAAC,EAAE;QACtC,iBAAiB,GAAG,UAAU,GAAG,SAAS,CAAC,GAAG,UAAU,CAAC,GAAG;QAC5D,IAAI,cAAc,YAAY,IAAI,CAAC;aAC9B;YACD,IAAI,GAAG,WAAW,IAAI,CAAC;YACvB,IAAI,GAAG,SAAS,IAAI,CAAC;QACzB;IACJ;IACA,mCAAmC;IACnC,MAAM,SAAS,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;QAAC;KAAY;IACrD,OAAO,SAAS;QAAE;QAAQ,OAAO;YAAC;SAAW;QAAE,KAAK;YAAC;SAAS;IAAC;AACnE;AAEO,MAAM,UAAU,CAAC,GAAG;IACvB,IAAI,OAAO,MAAM,UAAU,IAAI,MAAM;IACrC,IAAI,OAAO,MAAM,UAAU,IAAI,MAAM;IACrC,IAAI,EAAE,KAAK,IAAI,EAAE,KAAK,EAAE,OAAO,QAAQ,SAAS,IAAI,SAAS,OACtD,QAAQ,SAAS,GAAG,OAAO,SAAS,GAAG;IAE9C,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,GAAG,IAAK;QACnD,MAAM,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,EAAE;QACpC,MAAM,WAAW,KAAK,GAAG,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,IAAI;QAChD,IAAK,IAAI,IAAI,GAAG,KAAK,UAAU,IAAK;YAChC,MAAM,IAAI,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,EAAE;YACxB,IAAI,CAAC,GAAG,OAAO,CAAC;YAChB,IAAI,CAAC,GAAG,OAAO;YACf,IAAI,EAAE,KAAK,GAAG,EAAE,KAAK,EAAE,OAAO;YAC9B,IAAI,EAAE,KAAK,GAAG,EAAE,KAAK,EAAE,OAAO,CAAC;YAC/B,IAAI,MAAM,UAAU;gBAChB,2CAA2C;gBAC3C,IAAI,EAAE,MAAM,GAAG,EAAE,MAAM,EAAE,OAAO;gBAChC,IAAI,EAAE,MAAM,GAAG,EAAE,MAAM,EAAE,OAAO,CAAC;YACrC;QACJ;IACJ;IACA,OAAO;AACX;AAEA,MAAM,aAAa,CAAC,EAAE,QAAQ,EAAE,GAAK,aAAa,KAAK,aAAa;AACpE,MAAM,gBAAgB,CAAC,EAAE,QAAQ,EAAE,GAAK,aAAa;AAErD,MAAM,gBAAgB,CAAC,MAAM;IACzB,MAAM,QAAQ,MAAM,IAAI,CAAC,KAAK,UAAU,CACpC,6DAA6D;KAC5D,MAAM,CAAC,CAAA,OAAQ,WAAW,SAAS,cAAc;IACtD,OAAO,SAAS,MAAM,GAAG,CAAC,CAAA;QACtB,MAAM,SAAS,OAAO;QACtB,IAAI,WAAW,WAAW,aAAa,EAAE,OAAO;aAC3C,IAAI,WAAW,WAAW,WAAW,EAAE,OAAO,cAAc,MAAM;aAClE,OAAO;IAChB,GAAG,IAAI,GAAG,MAAM,CAAC,CAAA,IAAK,KAAK;AAC/B;AAEA,2DAA2D;AAC3D,oDAAoD;AACpD,sDAAsD;AACtD,4EAA4E;AAC5E,+EAA+E;AAC/E,MAAM,kBAAkB,CAAC,MAAM;IAC3B,MAAM,QAAQ,cAAc,MAAM,QAC7B,MAAM,CAAC,CAAC,KAAK;QACV,IAAI,OAAO,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE;QAC9B,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC;aAEf,IAAI,WAAW,OAAO;YACvB,IAAI,MAAM,OAAO,CAAC,OAAO,KAAK,IAAI,CAAC;iBAC9B,IAAI,WAAW,OAAO,GAAG,CAAC,IAAI,MAAM,GAAG,EAAE,GAAG;gBAAC;gBAAM;aAAK;iBACxD,IAAI,IAAI,CAAC;QAClB,OAAO;YACH,IAAI,cAAc,OAAO,IAAI,IAAI,CAAC,MAAM;iBACnC,IAAI,IAAI,CAAC;QAClB;QACA,OAAO;IACX,GAAG,EAAE;IACT,8DAA8D;IAC9D,IAAI,cAAc,KAAK,CAAC,EAAE,GAAG,MAAM,OAAO,CAAC;IAC3C,2DAA2D;IAC3D,IAAI,cAAc,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,GAAG,MAAM,IAAI,CAAC;IACvD,uBAAuB;IACvB,MAAM,OAAO,CAAC,WAAU,uBAAuB;IAC/C,MAAM,IAAI,CAAC,UAAS,yBAAyB;IAC7C,OAAO;AACX;AAEA,MAAM,cAAc,CAAC,MAAM,OAAO;IAC9B,MAAM,EAAE,EAAE,EAAE,GAAG,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;IACtC,IAAI,IAAI;QACJ,MAAM,KAAK,KAAK,aAAa,CAAC,cAAc,CAAC;QAC7C,IAAI,IAAI,OAAO;YAAE,MAAM;YAAI,QAAQ;QAAE;IACzC;IACA,KAAK,MAAM,EAAE,KAAK,EAAE,IAAI,MAAO;QAC3B,MAAM,UAAU,OAAO,gBAAgB,MAAM,OAAO,CAAC,MAAM,GAAG;QAC9D,4BAA4B;QAC5B,IAAI,YAAY,SAAS,OAAO;YAAE,MAAM,KAAK,UAAU,IAAI;QAAK;QAChE,IAAI,YAAY,QAAQ,OAAO;YAAE,MAAM,KAAK,SAAS,IAAI;QAAK;QAC9D,IAAI,YAAY,UAAU,OAAO;YAAE;YAAM,QAAQ;QAAK;QACtD,IAAI,YAAY,SAAS,OAAO;YAAE;YAAM,OAAO;QAAK;QACpD,OAAO;IACX;IACA,MAAM,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;IAC1C,IAAI,CAAC,MAAM,OAAO,CAAC,OAAO,OAAO;QAAE;QAAM;IAAO;IAChD,qDAAqD;IACrD,IAAI,MAAM;IACV,KAAK,MAAM,KAAK,KAAM;QAClB,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS;QAC9B,IAAI,MAAM,UAAU,QAAQ,OAAO;YAAE,MAAM;YAAG,QAAQ,SAAS;QAAI;QACnE,OAAO;IACX;AACJ;AAEA,MAAM,cAAc,CAAC,MAAM,QAAQ;IAC/B,MAAM,EAAE,UAAU,EAAE,EAAE,EAAE,GAAG;IAC3B,MAAM,UAAU,gBAAgB,YAAY;IAC5C,MAAM,QAAQ,QAAQ,SAAS,CAAC,CAAA,IAC5B,MAAM,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA,IAAK,MAAM,QAAQ,MAAM;IACvD,0DAA0D;IAC1D,MAAM,QAAQ,OAAO,CAAC,MAAM;IAC5B,IAAI,MAAM,OAAO,CAAC,QAAQ;QACtB,IAAI,MAAM;QACV,KAAK,MAAM,KAAK,MAAO;YACnB,IAAI,MAAM,MAAM;gBACZ,OAAO;gBACP;YACJ,OAAO,OAAO,EAAE,SAAS,CAAC,MAAM;QACpC;QACA,SAAS;IACb;IACA,MAAM,OAAO;QAAE;QAAI;QAAO;IAAO;IACjC,OAAO,CAAC,eAAe,KAAK,aAAa,CAAC,eAAe,GACnD,YAAY,YAAY,MAAM,QAAQ,MAAM,CAAC,QAAQ;QAAC;KAAK,CAC7D,uBAAuB;KACtB,MAAM,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK,CAAC;AAClC;AAEO,MAAM,YAAY,CAAC,OAAO;IAC7B,MAAM,EAAE,cAAc,EAAE,WAAW,EAAE,YAAY,EAAE,SAAS,EAAE,GAAG;IACjE,MAAM,QAAQ,YAAY,gBAAgB,aAAa;IACvD,IAAI,MAAM,SAAS,EAAE,OAAO,SAAS;QAAC;KAAM;IAC5C,MAAM,MAAM,YAAY,cAAc,WAAW;IACjD,OAAO,WAAW;QAAC;KAAM,EAAE;QAAC;KAAI;AACpC;AAEO,MAAM,UAAU,CAAC,KAAK,OAAO;IAChC,MAAM,aAAa,SAAS;IAC5B,MAAM,WAAW,SAAS,OAAO;IAEjC,MAAM,OAAO,IAAI,eAAe;IAChC,MAAM,QAAQ,YAAY,MAAM,UAAU,CAAC,EAAE,EAAE;IAC/C,MAAM,MAAM,YAAY,MAAM,QAAQ,CAAC,EAAE,EAAE;IAE3C,MAAM,QAAQ,IAAI,WAAW;IAE7B,IAAI,MAAM,MAAM,EAAE,MAAM,cAAc,CAAC,MAAM,IAAI;SAC5C,IAAI,MAAM,KAAK,EAAE,MAAM,aAAa,CAAC,MAAM,IAAI;SAC/C,MAAM,QAAQ,CAAC,MAAM,IAAI,EAAE,MAAM,MAAM;IAE5C,IAAI,IAAI,MAAM,EAAE,MAAM,YAAY,CAAC,IAAI,IAAI;SACtC,IAAI,IAAI,KAAK,EAAE,MAAM,WAAW,CAAC,IAAI,IAAI;SACzC,MAAM,MAAM,CAAC,IAAI,IAAI,EAAE,IAAI,MAAM;IACtC,OAAO;AACX;AAGO,MAAM,eAAe,CAAA;IACxB,MAAM,UAAU,EAAE;IAClB,MAAM,EAAE,UAAU,EAAE,GAAG,QAAQ,CAAC,EAAE;IAClC,MAAM,QAAQ,YAAY;IAC1B,KAAK,MAAM,CAAC,OAAO,KAAK,IAAI,gBAAgB,YAAY,OAAO,GAAI;QAC/D,MAAM,KAAK,QAAQ,CAAC,QAAQ,MAAM,CAAC;QACnC,IAAI,SAAS,IACT,QAAQ,IAAI,CAAC,SAAS;YAAC,MAAM,MAAM,CAAC;gBAAE,IAAI,GAAG,EAAE;gBAAE;YAAM;SAAG;IAClE;IACA,OAAO;AACX;AAEO,MAAM,YAAY,CAAC,KAAK,QAC3B,YAAY,IAAI,eAAe,EAAE,SAAS,QAAQ,IAAI;AAGnD,MAAM,OAAO;IAChB,WAAW,CAAA,QAAS,KAAK,CAAC,GAAG,EAAE,CAAC,QAAQ,CAAC,IAAI,GAAG;IAChD,SAAS,CAAA,QAAS,OAAO,GAAG,CAAC,GAAG,QAAQ,IAAI;AAChD;AAIO,MAAM,iBAAiB,CAAA;IAC1B,MAAM,CAAC,MAAM,GAAG,MAAM;IACtB,MAAM,OAAO,MAAM,KAAK;IACxB,MAAM,KAAK;IACX,OAAO,SAAS;QAAC;YAAC;gBAAE,OAAO;YAAE;YAAG;SAAK;QAAE;KAAM;AACjD;AACO,MAAM,uBAAuB,CAAC,EAAE,WAAW,EAAE,SAAS,EAAE,OAAO,EAAE;IACpE,MAAM,MAAM,KAAK,SAAS,CAAC,eAAe;IAC1C,OAAO,WAAW,MAAM,UAAU,KAAK,CAAC,IAAI,MAAM,QAAQ,KAAK,CAAC;AACpE"}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/opds.js"],"sourcesContent":["const NS = {\n    ATOM: 'http://www.w3.org/2005/Atom',\n    OPDS: 'http://opds-spec.org/2010/catalog',\n    THR: 'http://purl.org/syndication/thread/1.0',\n    DC: 'http://purl.org/dc/elements/1.1/',\n    DCTERMS: 'http://purl.org/dc/terms/',\n}\n\nconst MIME = {\n    ATOM: 'application/atom+xml',\n    OPDS2: 'application/opds+json',\n}\n\nexport const REL = {\n    ACQ: 'http://opds-spec.org/acquisition',\n    FACET: 'http://opds-spec.org/facet',\n    GROUP: 'http://opds-spec.org/group',\n    COVER: [\n        'http://opds-spec.org/image',\n        'http://opds-spec.org/cover',\n    ],\n    THUMBNAIL: [\n        'http://opds-spec.org/image/thumbnail',\n        'http://opds-spec.org/thumbnail',\n    ],\n}\n\nexport const SYMBOL = {\n    SUMMARY: Symbol('summary'),\n    CONTENT: Symbol('content'),\n}\n\nconst FACET_GROUP = Symbol('facetGroup')\n\nconst groupByArray = (arr, f) => {\n    const map = new Map()\n    if (arr) for (const el of arr) {\n        const keys = f(el)\n        for (const key of [keys].flat()) {\n            const group = map.get(key)\n            if (group) group.push(el)\n            else map.set(key, [el])\n        }\n    }\n    return map\n}\n\n// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1\nconst parseMediaType = str => {\n    if (!str) return null\n    const [mediaType, ...ps] = str.split(/ *; */)\n    return {\n        mediaType: mediaType.toLowerCase(),\n        parameters: Object.fromEntries(ps.map(p => {\n            const [name, val] = p.split('=')\n            return [name.toLowerCase(), val?.replace(/(^\"|\"$)/g, '')]\n        })),\n    }\n}\n\nexport const isOPDSCatalog = str => {\n    const parsed = parseMediaType(str)\n    if (!parsed) return false\n    const { mediaType, parameters } = parsed\n    if (mediaType === MIME.OPDS2) return true\n    return mediaType === MIME.ATOM && parameters.profile?.toLowerCase() === 'opds-catalog'\n}\n\nexport const isOPDSSearch = str => {\n    const parsed = parseMediaType(str)\n    if (!parsed) return false\n    const { mediaType } = parsed\n    return mediaType === MIME.ATOM\n}\n\n// ignore the namespace if it doesn't appear in document at all\nconst useNS = (doc, ns) =>\n    doc.lookupNamespaceURI(null) === ns || doc.lookupPrefix(ns) ? ns : null\n\nconst filterNS = ns => ns\n    ? name => el => el.namespaceURI === ns && el.localName === name\n    : name => el => el.localName === name\n\nconst getContent = el => {\n    if (!el) return\n    const type = el.getAttribute('type') ?? 'text'\n    const value = type === 'xhtml' ? el.innerHTML\n        : type === 'html' ? el.textContent\n            .replaceAll('&lt;', '<')\n            .replaceAll('&gt;', '>')\n            .replaceAll('&amp;', '&')\n        : el.textContent\n    return { value, type }\n}\n\nconst getTextContent = el => {\n    const content = getContent(el)\n    if (content?.type === 'text') return content?.value\n}\n\nconst getSummary = (a, b) => getTextContent(a) ?? getTextContent(b)\n\nconst getPrice = link => {\n    const price = link.getElementsByTagNameNS(NS.OPDS, 'price')[0]\n    return price ? {\n        currency: price.getAttribute('currencycode'),\n        value: price.textContent,\n    } : null\n}\n\nconst getIndirectAcquisition = el => {\n    const ia = el.getElementsByTagNameNS(NS.OPDS, 'indirectAcquisition')[0]\n    if (!ia) return []\n    return [{ type: ia.getAttribute('type') }, ...getIndirectAcquisition(ia)]\n}\n\nconst getLink = link => {\n    const obj = {\n        rel: link.getAttribute('rel')?.split(/ +/),\n        href: link.getAttribute('href'),\n        type: link.getAttribute('type'),\n        title: link.getAttribute('title'),\n        properties: {\n            price: getPrice(link),\n            indirectAcquisition: getIndirectAcquisition(link),\n            numberOfItems: link.getAttributeNS(NS.THR, 'count'),\n        },\n        [FACET_GROUP]: link.getAttributeNS(NS.OPDS, 'facetGroup'),\n    }\n    if (link.getAttributeNS(NS.OPDS, 'activeFacet') === 'true')\n        obj.rel = [obj.rel ?? []].flat().concat('self')\n    return obj\n}\n\nconst getPerson = person => {\n    const NS = person.namespaceURI\n    const uri = person.getElementsByTagNameNS(NS, 'uri')[0]?.textContent\n    return {\n        name: person.getElementsByTagNameNS(NS, 'name')[0]?.textContent ?? '',\n        links: uri ? [{ href: uri }] : [],\n    }\n}\n\nexport const getPublication = entry => {\n    const filter = filterNS(useNS(entry.ownerDocument, NS.ATOM))\n    const children = Array.from(entry.children)\n    const filterDCEL = filterNS(NS.DC)\n    const filterDCTERMS = filterNS(NS.DCTERMS)\n    const filterDC = x => {\n        const a = filterDCEL(x), b = filterDCTERMS(x)\n        return y => a(y) || b(y)\n    }\n    const links = children.filter(filter('link')).map(getLink)\n    const linksByRel = groupByArray(links, link => link.rel)\n    return {\n        metadata: {\n            title: children.find(filter('title'))?.textContent ?? '',\n            author: children.filter(filter('author')).map(getPerson),\n            contributor: children.filter(filter('contributor')).map(getPerson),\n            publisher: children.find(filterDC('publisher'))?.textContent,\n            published: (children.find(filterDCTERMS('issued'))\n                ?? children.find(filterDC('date')))?.textContent,\n            language: children.find(filterDC('language'))?.textContent,\n            identifier: children.find(filterDC('identifier'))?.textContent,\n            subject: children.filter(filter('category')).map(category => ({\n                name: category.getAttribute('label'),\n                code: category.getAttribute('term'),\n                scheme: category.getAttribute('scheme'),\n            })),\n            rights: children.find(filter('rights'))?.textContent ?? '',\n            [SYMBOL.CONTENT]: getContent(children.find(filter('content'))\n                ?? children.find(filter('summary'))),\n        },\n        links,\n        images: REL.COVER.concat(REL.THUMBNAIL)\n            .map(R => linksByRel.get(R)?.[0]).filter(x => x),\n    }\n}\n\nexport const getFeed = doc => {\n    const ns = useNS(doc, NS.ATOM)\n    const filter = filterNS(ns)\n    const children = Array.from(doc.documentElement.children)\n    const entries = children.filter(filter('entry'))\n    const links = children.filter(filter('link')).map(getLink)\n    const linksByRel = groupByArray(links, link => link.rel)\n\n    const groupedItems = new Map([[null, []]])\n    const groupLinkMap = new Map()\n    for (const entry of entries) {\n        const children = Array.from(entry.children)\n        const links = children.filter(filter('link')).map(getLink)\n        const linksByRel = groupByArray(links, link => link.rel)\n        const isPub = [...linksByRel.keys()]\n            .some(rel => rel?.startsWith(REL.ACQ) || rel === 'preview')\n\n        const groupLinks = linksByRel.get(REL.GROUP) ?? linksByRel.get('collection')\n        const groupLink = groupLinks?.length\n            ? groupLinks.find(link => groupedItems.has(link.href)) ?? groupLinks[0] : null\n        if (groupLink && !groupLinkMap.has(groupLink.href))\n            groupLinkMap.set(groupLink.href, groupLink)\n\n        const item = isPub\n            ? getPublication(entry)\n            : Object.assign(links.find(link => isOPDSCatalog(link.type)) ?? links[0] ?? {}, {\n                title: children.find(filter('title'))?.textContent,\n                [SYMBOL.SUMMARY]: getSummary(children.find(filter('summary')),\n                    children.find(filter('content'))),\n            })\n\n        const arr = groupedItems.get(groupLink?.href ?? null)\n        if (arr) arr.push(item)\n        else groupedItems.set(groupLink.href, [item])\n    }\n    const [items, ...groups] = Array.from(groupedItems, ([key, items]) => {\n        const itemsKey = items[0]?.metadata ? 'publications' : 'navigation'\n        if (key == null) return { [itemsKey]: items }\n        const link = groupLinkMap.get(key)\n        return {\n            metadata: {\n                title: link.title,\n                numberOfItems: link.properties.numberOfItems,\n            },\n            links: [{ rel: 'self', href: link.href, type: link.type }],\n            [itemsKey]: items,\n        }\n    })\n    return {\n        metadata: {\n            title: children.find(filter('title'))?.textContent,\n            subtitle: children.find(filter('subtitle'))?.textContent,\n        },\n        links,\n        ...items,\n        groups,\n        facets: Array.from(\n            groupByArray(linksByRel.get(REL.FACET) ?? [], link => link[FACET_GROUP]),\n            ([facet, links]) => ({ metadata: { title: facet }, links })),\n    }\n}\n\nexport const getSearch = async link => {\n    const { replace, getVariables } = await import('./uri-template.js')\n    return {\n        metadata: {\n            title: link.title,\n        },\n        search: map => replace(link.href, map.get(null)),\n        params: Array.from(getVariables(link.href), name => ({ name })),\n    }\n}\n\nexport const getOpenSearch = doc => {\n    const defaultNS = doc.documentElement.namespaceURI\n    const filter = filterNS(defaultNS)\n    const children = Array.from(doc.documentElement.children)\n\n    const $$urls = children.filter(filter('Url'))\n    const $url = $$urls.find(url => isOPDSCatalog(url.getAttribute('type'))) ?? $$urls.find(url => isOPDSSearch(url.getAttribute('type'))) ?? $$urls[0]\n    if (!$url) throw new Error('document must contain at least one Url element')\n\n    const regex = /{(?:([^}]+?):)?(.+?)(\\?)?}/g\n    const defaultMap = new Map([\n        ['count', '100'],\n        ['startIndex', $url.getAttribute('indexOffset') ?? '0'],\n        ['startPage', $url.getAttribute('pageOffset') ?? '0'],\n        ['language', '*'],\n        ['inputEncoding', 'UTF-8'],\n        ['outputEncoding', 'UTF-8'],\n    ])\n\n    const template = $url.getAttribute('template')\n    return {\n        metadata: {\n            title: (children.find(filter('LongName')) ?? children.find(filter('ShortName')))?.textContent,\n            description: children.find(filter('Description'))?.textContent,\n        },\n        search: map => template.replace(regex, (_, prefix, param) => {\n            const namespace = prefix ? $url.lookupNamespaceURI(prefix) : null\n            const ns = namespace === defaultNS ? null : namespace\n            const val = map.get(ns)?.get(param)\n            return encodeURIComponent(val ? val : (!ns ? defaultMap.get(param) ?? '' : ''))\n        }),\n        params: Array.from(template.matchAll(regex), ([, prefix, param, optional]) => {\n            const namespace = prefix ? $url.lookupNamespaceURI(prefix) : null\n            const ns = namespace === defaultNS ? null : namespace\n            return {\n                ns, name: param,\n                required: !optional,\n                value: ns && ns !== defaultNS ? '' : defaultMap.get(param) ?? '',\n            }\n        }),\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
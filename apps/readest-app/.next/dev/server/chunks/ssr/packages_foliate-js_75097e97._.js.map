{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/epubcfi.js"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/overlayer.js"],"sourcesContent":["const createSVGElement = tag =>\n    document.createElementNS('http://www.w3.org/2000/svg', tag)\n\nexport class Overlayer {\n    #svg = createSVGElement('svg')\n    #map = new Map()\n    #doc = null\n    constructor(doc) {\n        this.#doc = doc\n        Object.assign(this.#svg.style, {\n            position: 'absolute', top: '0', left: '0',\n            width: '100%', height: '100%',\n            pointerEvents: 'none',\n        })\n    }\n    get element() {\n        return this.#svg\n    }\n    get #zoom() {\n        // Safari does not zoom the client rects, while Chrome, Edge and Firefox does\n        if (/^((?!chrome|android).)*AppleWebKit/i.test(navigator.userAgent) && !window.chrome) {\n            return window.getComputedStyle(this.#doc.body).zoom || 1.0\n        }\n        return 1.0\n    }\n    #splitRangeByParagraph(range) {\n        const ancestor = range.commonAncestorContainer\n        const paragraphs = Array.from(ancestor.querySelectorAll?.('p, h1, h2, h3, h4') || [])\n\n        const splitRanges = []\n        paragraphs.forEach((p) => {\n            const pRange = document.createRange()\n            if (range.intersectsNode(p)) {\n                pRange.selectNodeContents(p)\n                if (pRange.compareBoundaryPoints(Range.START_TO_START, range) < 0) {\n                    pRange.setStart(range.startContainer, range.startOffset)\n                }\n                if (pRange.compareBoundaryPoints(Range.END_TO_END, range) > 0) {\n                    pRange.setEnd(range.endContainer, range.endOffset)\n                }\n                splitRanges.push(pRange)\n            }\n        })\n        return splitRanges.length === 0 ? [range] : splitRanges\n    }\n    add(key, range, draw, options) {\n        if (this.#map.has(key)) this.remove(key)\n        if (typeof range === 'function') range = range(this.#svg.getRootNode())\n        const zoom = this.#zoom\n        let rects = []\n        this.#splitRangeByParagraph(range).forEach((pRange) => {\n            const pRects = Array.from(pRange.getClientRects()).map(rect => ({\n                left: rect.left * zoom,\n                top: rect.top * zoom,\n                right: rect.right * zoom,\n                bottom: rect.bottom * zoom,\n                width: rect.width * zoom,\n                height: rect.height * zoom,\n            }))\n            rects = rects.concat(pRects)\n        })\n        const element = draw(rects, options)\n        this.#svg.append(element)\n        this.#map.set(key, { range, draw, options, element, rects })\n    }\n    remove(key) {\n        if (!this.#map.has(key)) return\n        this.#svg.removeChild(this.#map.get(key).element)\n        this.#map.delete(key)\n    }\n    redraw() {\n        for (const obj of this.#map.values()) {\n            const { range, draw, options, element } = obj\n            this.#svg.removeChild(element)\n            const zoom = this.#zoom\n            let rects = []\n            this.#splitRangeByParagraph(range).forEach((pRange) => {\n                const pRects = Array.from(pRange.getClientRects()).map(rect => ({\n                    left: rect.left * zoom,\n                    top: rect.top * zoom,\n                    right: rect.right * zoom,\n                    bottom: rect.bottom * zoom,\n                    width: rect.width * zoom,\n                    height: rect.height * zoom,\n                }))\n                rects = rects.concat(pRects)\n            })\n            const el = draw(rects, options)\n            this.#svg.append(el)\n            obj.element = el\n            obj.rects = rects\n        }\n    }\n    hitTest({ x, y }) {\n        const arr = Array.from(this.#map.entries())\n        // loop in reverse to hit more recently added items first\n        for (let i = arr.length - 1; i >= 0; i--) {\n            const tolerance = 5\n            const [key, obj] = arr[i]\n            for (const { left, top, right, bottom } of obj.rects) {\n                if (\n                    top <= y + tolerance &&\n                    left <= x + tolerance &&\n                    bottom > y - tolerance &&\n                    right > x - tolerance\n                ) {\n                    return [key, obj.range, { left, top, right, bottom }]\n                }\n            }\n        }\n        return []\n    }\n    static underline(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, padding = 0, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, top, height } of rects) {\n                const el = createSVGElement('rect')\n                el.setAttribute('x', right - strokeWidth / 2 + padding)\n                el.setAttribute('y', top)\n                el.setAttribute('height', height)\n                el.setAttribute('width', strokeWidth)\n                g.append(el)\n            }\n        else for (const { left, bottom, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left)\n            el.setAttribute('y', bottom - strokeWidth / 2 + padding)\n            el.setAttribute('height', strokeWidth)\n            el.setAttribute('width', width)\n            g.append(el)\n        }\n        return g\n    }\n    static strikethrough(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, left, top, height } of rects) {\n                const el = createSVGElement('rect')\n                el.setAttribute('x', (right + left) / 2)\n                el.setAttribute('y', top)\n                el.setAttribute('height', height)\n                el.setAttribute('width', strokeWidth)\n                g.append(el)\n            }\n        else for (const { left, top, bottom, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left)\n            el.setAttribute('y', (top + bottom) / 2)\n            el.setAttribute('height', strokeWidth)\n            el.setAttribute('width', width)\n            g.append(el)\n        }\n        return g\n    }\n    static squiggly(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 2, padding = 0, writingMode } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', 'none')\n        g.setAttribute('stroke', color)\n        g.setAttribute('stroke-width', strokeWidth)\n        const block = strokeWidth * 1.5\n        if (writingMode === 'vertical-rl' || writingMode === 'vertical-lr')\n            for (const { right, top, height } of rects) {\n                const el = createSVGElement('path')\n                const n = Math.round(height / block / 1.5)\n                const inline = height / n\n                const ls = Array.from({ length: n },\n                    (_, i) => `l${i % 2 ? -block : block} ${inline}`).join('')\n                el.setAttribute('d', `M${right - strokeWidth / 2 + padding} ${top}${ls}`)\n                g.append(el)\n            }\n        else for (const { left, bottom, width } of rects) {\n            const el = createSVGElement('path')\n            const n = Math.round(width / block / 1.5)\n            const inline = width / n\n            const ls = Array.from({ length: n },\n                (_, i) => `l${inline} ${i % 2 ? block : -block}`).join('')\n            el.setAttribute('d', `M${left} ${bottom + strokeWidth / 2 + padding}${ls}`)\n            g.append(el)\n        }\n        return g\n    }\n    static highlight(rects, options = {}) {\n        const { color = 'red', padding = 0 } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', color)\n        g.style.opacity = 'var(--overlayer-highlight-opacity, .3)'\n        g.style.mixBlendMode = 'var(--overlayer-highlight-blend-mode, normal)'\n        for (const { left, top, height, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left - padding)\n            el.setAttribute('y', top - padding)\n            el.setAttribute('height', height + padding * 2)\n            el.setAttribute('width', width + padding * 2)\n            g.append(el)\n        }\n        return g\n    }\n    static outline(rects, options = {}) {\n        const { color = 'red', width: strokeWidth = 3, padding = 0, radius = 3 } = options\n        const g = createSVGElement('g')\n        g.setAttribute('fill', 'none')\n        g.setAttribute('stroke', color)\n        g.setAttribute('stroke-width', strokeWidth)\n        for (const { left, top, height, width } of rects) {\n            const el = createSVGElement('rect')\n            el.setAttribute('x', left - padding)\n            el.setAttribute('y', top - padding)\n            el.setAttribute('height', height + padding * 2)\n            el.setAttribute('width', width + padding * 2)\n            el.setAttribute('rx', radius)\n            g.append(el)\n        }\n        return g\n    }\n    static bubble(rects, options = {}) {\n        const { color = '#fbbf24', writingMode, opacity = 0.85, size = 20, padding = 10 } = options\n        const isVertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr'\n        const g = createSVGElement('g')\n        g.style.opacity = opacity\n        if (rects.length === 0) return g\n        rects.splice(1)\n        const firstRect = rects[0]\n        const x = isVertical ? firstRect.right - size + padding : firstRect.right - size + padding\n        const y = isVertical ? firstRect.bottom - size + padding : firstRect.top - size + padding\n        firstRect.top = y - padding\n        firstRect.right = x + size + padding\n        firstRect.bottom = y + size + padding\n        firstRect.left = x - padding\n        const bubble = createSVGElement('path')\n        const s = size\n        const r = s * 0.15\n        // Speech bubble shape with a small tail\n        // Main rounded rectangle body\n        const d = `\n            M ${x + r} ${y}\n            h ${s - 2 * r}\n            a ${r} ${r} 0 0 1 ${r} ${r}\n            v ${s * 0.65 - 2 * r}\n            a ${r} ${r} 0 0 1 ${-r} ${r}\n            h ${-s * 0.3}\n            l ${-s * 0.15} ${s * 0.2}\n            l ${s * 0.05} ${-s * 0.2}\n            h ${-s * 0.6 + 2 * r}\n            a ${r} ${r} 0 0 1 ${-r} ${-r}\n            v ${-s * 0.65 + 2 * r}\n            a ${r} ${r} 0 0 1 ${r} ${-r}\n            z\n        `.replace(/\\s+/g, ' ').trim()\n\n        bubble.setAttribute('d', d)\n        bubble.setAttribute('fill', color)\n        bubble.setAttribute('stroke', 'rgba(0, 0, 0, 0.2)')\n        bubble.setAttribute('stroke-width', '1')\n        // Add horizontal lines inside to represent text\n        const lineGroup = createSVGElement('g')\n        lineGroup.setAttribute('stroke', 'rgba(0, 0, 0, 0.3)')\n        lineGroup.setAttribute('stroke-width', '1.5')\n        lineGroup.setAttribute('stroke-linecap', 'round')\n        const lineY1 = y + s * 0.18\n        const lineY2 = y + s * 0.33\n        const lineY3 = y + s * 0.48\n        const lineX1 = x + s * 0.2\n        const lineX2 = x + s * 0.8\n        const line1 = createSVGElement('line')\n        line1.setAttribute('x1', lineX1)\n        line1.setAttribute('y1', lineY1)\n        line1.setAttribute('x2', lineX2)\n        line1.setAttribute('y2', lineY1)\n        const line2 = createSVGElement('line')\n        line2.setAttribute('x1', lineX1)\n        line2.setAttribute('y1', lineY2)\n        line2.setAttribute('x2', lineX2)\n        line2.setAttribute('y2', lineY2)\n        const line3 = createSVGElement('line')\n        line3.setAttribute('x1', lineX1)\n        line3.setAttribute('y1', lineY3)\n        line3.setAttribute('x2', x + s * 0.6)\n        line3.setAttribute('y2', lineY3)\n        lineGroup.append(line1, line2, line3)\n\n        if (isVertical) {\n            const centerX = x + s / 2\n            const centerY = y + s / 2\n            bubble.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`)\n            lineGroup.setAttribute('transform', `rotate(90 ${centerX} ${centerY})`)\n        }\n\n        g.append(bubble)\n        g.append(lineGroup)\n        return g\n    }\n    // make an exact copy of an image in the overlay\n    // one can then apply filters to the entire element, without affecting them;\n    // it's a bit silly and probably better to just invert images twice\n    // (though the color will be off in that case if you do heu-rotate)\n    static copyImage([rect], options = {}) {\n        const { src } = options\n        const image = createSVGElement('image')\n        const { left, top, height, width } = rect\n        image.setAttribute('href', src)\n        image.setAttribute('x', left)\n        image.setAttribute('y', top)\n        image.setAttribute('height', height)\n        image.setAttribute('width', width)\n        return image\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 756, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/footnotes.js"],"sourcesContent":["const getTypes = el => new Set([\n    ...(el?.getAttributeNS?.('http://www.idpf.org/2007/ops', 'type')?.split(' ') ?? []),\n    ...(el?.attributes?.getNamedItem?.('epub:type')?.value?.split(' ') ?? []),\n])\nconst getRoles = el => new Set(el?.getAttribute?.('role')?.split(' '))\n\nconst isSuper = el => {\n    if (el.matches('sup')) return true\n    const { verticalAlign } = getComputedStyle(el)\n    return verticalAlign === 'super'\n        || verticalAlign === 'top'\n        || verticalAlign === 'text-top'\n        || /^\\d/.test(verticalAlign)\n}\n\nconst refTypes = ['biblioref', 'glossref', 'noteref']\nconst refRoles = ['doc-biblioref', 'doc-glossref', 'doc-noteref']\nconst isFootnoteReference = a => {\n    const types = getTypes(a)\n    const roles = getRoles(a)\n    return {\n        yes: refRoles.some(r => roles.has(r)) || refTypes.some(t => types.has(t)),\n        maybe: () => !types.has('backlink') && !roles.has('doc-backlink')\n            && (isSuper(a) || a.children.length === 1 && isSuper(a.children[0])\n            || isSuper(a.parentElement)),\n    }\n}\n\nconst getReferencedType = el => {\n    const types = getTypes(el)\n    const roles = getRoles(el)\n    return roles.has('doc-biblioentry') || types.has('biblioentry') ? 'biblioentry'\n        : roles.has('definition') || types.has('glossdef') ? 'definition'\n        : roles.has('doc-endnote') || types.has('endnote') || types.has('rearnote') ? 'endnote'\n        : roles.has('doc-footnote') || types.has('footnote') ? 'footnote'\n        : roles.has('note') || types.has('note') ? 'note' : null\n}\n\nconst isInline = 'a, span, sup, sub, em, strong, i, b, small, big'\nconst extractFootnote = (doc, anchor) => {\n    let el = anchor(doc)\n    const target = el\n    while (el.matches(isInline)) {\n        const parent = el.parentElement\n        if (!parent) break\n        el = parent\n    }\n    if (el === doc.body) {\n        const sibling = target.nextElementSibling\n        if (sibling && !sibling.matches(isInline)) return sibling\n        throw new Error('Failed to extract footnote')\n    }\n    return el\n}\n\nexport class FootnoteHandler extends EventTarget {\n    detectFootnotes = true\n    #showFragment(book, { index, anchor }, href) {\n        const view = document.createElement('foliate-view')\n        return new Promise((resolve, reject) => {\n            view.addEventListener('load', e => {\n                try {\n                    const { doc } = e.detail\n                    const el = anchor(doc)\n                    const type = getReferencedType(el)\n                    const hidden = el?.matches?.('aside') && type === 'footnote'\n                    if (el) {\n                        let range\n                        if (el.startContainer) {\n                            range = el\n                        } else if (el.matches('li, aside')) {\n                            range = doc.createRange()\n                            range.selectNodeContents(el)\n                        } else if (el.matches('dt')) {\n                            range = doc.createRange()\n                            range.setStartBefore(el)\n                            let sibling = el.nextElementSibling\n                            let lastDD = null\n                            while (sibling && sibling.matches('dd')) {\n                                lastDD = sibling\n                                sibling = sibling.nextElementSibling\n                            }\n                            range.setEndAfter(lastDD || el)\n                        } else if (el.closest('li')) {\n                            range = doc.createRange()\n                            range.selectNodeContents(el.closest('li'))\n                        } else if (el.closest('.note')) {\n                            range = doc.createRange()\n                            range.selectNodeContents(el.closest('.note'))\n                        } else if (el.querySelector('a')) {\n                            range = doc.createRange()\n                            range.setStartBefore(el)\n                            let next = el.nextElementSibling\n                            while (next) {\n                                if (next.querySelector('a')) break\n                                next = next.nextElementSibling\n                            }\n                            if (next) {\n                                range.setEndBefore(next)\n                            } else {\n                                range.setEndAfter(el.parentNode.lastChild)\n                            }\n                        } else {\n                            range = doc.createRange()\n                            const hasContent = el.textContent?.trim() || el.children.length > 0\n                            if (!hasContent && el.parentElement) {\n                                range.selectNodeContents(el.parentElement)\n                            } else {\n                                range.selectNode(el)\n                            }\n                        }\n                        const frag = range.extractContents()\n                        doc.body.replaceChildren()\n                        doc.body.appendChild(frag)\n                    }\n                    const detail = { view, href, type, hidden, target: el }\n                    this.dispatchEvent(new CustomEvent('render', { detail }))\n                    resolve()\n                } catch (e) {\n                    reject(e)\n                }\n            })\n            view.open(book)\n                .then(() => this.dispatchEvent(new CustomEvent('before-render', { detail: { view } })))\n                .then(() => view.goTo(index))\n                .catch(reject)\n        })\n    }\n    handle(book, e) {\n        const { a, href, follow } = e.detail\n        const { yes, maybe } = isFootnoteReference(a)\n        if (yes || follow) {\n            e.preventDefault()\n            return Promise.resolve(book.resolveHref(href)).then(target =>\n                this.#showFragment(book, target, href))\n        }\n        else if (this.detectFootnotes && maybe()) {\n            e.preventDefault()\n            return Promise.resolve(book.resolveHref(href)).then(({ index, anchor }) => {\n                const target = { index, anchor: doc => extractFootnote(doc, anchor) }\n                return this.#showFragment(book, target, href)\n            })\n        }\n    }\n}\n"],"names":[],"mappings":"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"}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/file.ts"],"sourcesContent":["import { FileHandle, open, BaseDirectory, SeekMode } from '@tauri-apps/plugin-fs';\nimport { getOSPlatform } from './misc';\n\nclass DeferredBlob extends Blob {\n  #dataPromise: Promise<ArrayBuffer>;\n  #type: string;\n\n  constructor(dataPromise: Promise<ArrayBuffer>, type: string) {\n    super();\n    this.#dataPromise = dataPromise;\n    this.#type = type;\n  }\n\n  override async arrayBuffer() {\n    const data = await this.#dataPromise;\n    return data;\n  }\n\n  override async text() {\n    const data = await this.#dataPromise;\n    return new TextDecoder().decode(data);\n  }\n\n  override stream() {\n    return new ReadableStream({\n      start: async (controller) => {\n        const data = await this.#dataPromise;\n        const reader = new ReadableStream({\n          start(controller) {\n            controller.enqueue(new Uint8Array(data));\n            controller.close();\n          },\n        }).getReader();\n        const pump = () =>\n          reader.read().then(({ done, value }): Promise<void> => {\n            if (done) {\n              controller.close();\n              return Promise.resolve();\n            }\n            controller.enqueue(value);\n            return pump();\n          });\n        return pump();\n      },\n    });\n  }\n\n  override get type() {\n    return this.#type;\n  }\n}\n\nexport interface ClosableFile extends File {\n  open(): Promise<this>;\n  close(): Promise<void>;\n}\n\nexport class NativeFile extends File implements ClosableFile {\n  #handle: FileHandle | null = null;\n  #fp: string;\n  #name: string;\n  #baseDir: BaseDirectory | null;\n  #lastModified: number = 0;\n  #size: number = -1;\n  #type: string = '';\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 1024;\n  static MAX_CACHE_ITEMS_SIZE = 50;\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map();\n  #pendingReads: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  constructor(fp: string, name?: string, baseDir: BaseDirectory | null = null, type = '') {\n    super([], name || fp, { type });\n    this.#fp = fp;\n    this.#baseDir = baseDir;\n    this.#name = name || fp;\n  }\n\n  async open() {\n    this.#handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    const stats = await this.#handle.stat();\n    this.#size = stats.size;\n    this.#lastModified = stats.mtime ? stats.mtime.getTime() : Date.now();\n    return this;\n  }\n\n  async close() {\n    if (this.#handle) {\n      await this.#handle.close();\n      this.#handle = null;\n    }\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async stat() {\n    return this.#handle?.stat();\n  }\n\n  async seek(offset: number, whence: SeekMode): Promise<number> {\n    if (!this.#handle) {\n      throw new Error('File handle is not open');\n    }\n    return this.#handle.seek(offset, whence);\n  }\n\n  // exclusive reading of the end: [start, end)\n  async readData(start: number, end: number): Promise<ArrayBuffer> {\n    start = Math.max(0, start);\n    end = Math.max(start, Math.min(this.size, end));\n    const size = end - start;\n\n    if (size > NativeFile.MAX_CACHE_CHUNK_SIZE) {\n      const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n      try {\n        await handle.seek(start, SeekMode.Start);\n        const buffer = new Uint8Array(size);\n        await handle.read(buffer);\n        return buffer.buffer;\n      } finally {\n        await handle.close();\n      }\n    }\n\n    const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n      const buffer = this.#cache.get(chunkStart)!;\n      return start >= chunkStart && end <= chunkStart + buffer.byteLength;\n    });\n\n    if (cachedChunkStart !== undefined) {\n      this.#updateAccessOrder(cachedChunkStart);\n      const buffer = this.#cache.get(cachedChunkStart)!;\n      const offset = start - cachedChunkStart;\n      return buffer.slice(offset, offset + size);\n    }\n\n    const readKey = `${start}-${end}`;\n    const pendingRead = this.#pendingReads.get(readKey);\n\n    if (pendingRead) {\n      return pendingRead;\n    }\n\n    const readPromise = this.#readAndCacheChunkSafe(start, size);\n    this.#pendingReads.set(readKey, readPromise);\n\n    try {\n      return await readPromise;\n    } finally {\n      this.#pendingReads.delete(readKey);\n    }\n  }\n\n  async #readAndCacheChunkSafe(start: number, size: number): Promise<ArrayBuffer> {\n    const handle = await open(this.#fp, this.#baseDir ? { baseDir: this.#baseDir } : undefined);\n    try {\n      const chunkStart = Math.max(0, start - 1024);\n      const chunkEnd = Math.min(this.size, start + NativeFile.MAX_CACHE_CHUNK_SIZE);\n      const chunkSize = chunkEnd - chunkStart;\n\n      await handle.seek(chunkStart, SeekMode.Start);\n      const buffer = new Uint8Array(chunkSize);\n      await handle.read(buffer);\n\n      // Only one thread reaches here per unique range\n      this.#cache.set(chunkStart, buffer.buffer);\n      this.#updateAccessOrder(chunkStart);\n      this.#ensureCacheSize();\n\n      const offset = start - chunkStart;\n      return buffer.buffer.slice(offset, offset + size);\n    } finally {\n      await handle.close();\n    }\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > NativeFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.readData(start, end);\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override stream(): ReadableStream<Uint8Array<ArrayBuffer>> {\n    const CHUNK_SIZE = 1024 * 1024;\n    let offset = 0;\n\n    return new ReadableStream<Uint8Array<ArrayBuffer>>({\n      pull: async (controller) => {\n        if (!this.#handle) {\n          controller.error(new Error('File handle is not open'));\n          return;\n        }\n\n        if (offset >= this.size) {\n          controller.close();\n          return;\n        }\n\n        const end = Math.min(offset + CHUNK_SIZE, this.size);\n        const buffer = new Uint8Array(end - offset);\n\n        await this.#handle.seek(offset, SeekMode.Start);\n        const bytesRead = await this.#handle.read(buffer);\n\n        if (bytesRead === null || bytesRead === 0) {\n          controller.close();\n          return;\n        }\n\n        controller.enqueue(buffer.subarray(0, bytesRead));\n        offset += bytesRead;\n      },\n\n      cancel: async () => {\n        await this.#handle?.close();\n      },\n    });\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n\nexport class RemoteFile extends File implements ClosableFile {\n  url: string;\n  #name: string;\n  #lastModified: number;\n  #size: number = -1;\n  #type: string = '';\n  #order: number[] = [];\n  #cache: Map<number, ArrayBuffer> = new Map(); // LRU cache\n  #pendingFetches: Map<string, Promise<ArrayBuffer>> = new Map();\n\n  static MAX_CACHE_CHUNK_SIZE = 1024 * 128;\n  static MAX_CACHE_ITEMS_SIZE: number = 128;\n\n  constructor(url: string, name?: string, type = '', lastModified = Date.now()) {\n    const basename = url.split('/').pop() || 'remote-file';\n    super([], name || basename, { type, lastModified });\n    this.url = url;\n    this.#name = name || basename;\n    this.#type = type;\n    this.#lastModified = lastModified;\n  }\n\n  override get name() {\n    return this.#name;\n  }\n\n  override get type() {\n    return this.#type;\n  }\n\n  override get size() {\n    return this.#size;\n  }\n\n  override get lastModified() {\n    return this.#lastModified;\n  }\n\n  async _open_with_head() {\n    const response = await fetch(this.url, { method: 'HEAD' });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-length'));\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async _open_with_range() {\n    const response = await fetch(this.url, { headers: { Range: `bytes=${0}-${1023}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch file size: ${response.status}`);\n    }\n    this.#size = Number(response.headers.get('content-range')?.split('/')[1]);\n    this.#type = response.headers.get('content-type') || '';\n    return this;\n  }\n\n  async open() {\n    // FIXME: currently HEAD request in asset protocol is not supported on Android\n    if (getOSPlatform() === 'android') {\n      return this._open_with_range();\n    } else {\n      return this._open_with_head();\n    }\n  }\n\n  async close(): Promise<void> {\n    this.#cache.clear();\n    this.#order = [];\n  }\n\n  async fetchRangePart(start: number, end: number) {\n    start = Math.max(0, start);\n    end = Math.min(this.size - 1, end);\n    // console.log(`Fetching range: ${start}-${end}, size: ${end - start + 1}`);\n    const response = await fetch(this.url, { headers: { Range: `bytes=${start}-${end}` } });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch range: ${response.status}`);\n    }\n    return response.arrayBuffer();\n  }\n\n  // inclusive reading of the end: [start, end]\n  async fetchRange(start: number, end: number): Promise<ArrayBuffer> {\n    const rangeSize = end - start + 1;\n    const MAX_RANGE_LEN = 1024 * 1000;\n\n    if (rangeSize > MAX_RANGE_LEN) {\n      const buffers: ArrayBuffer[] = [];\n      for (let currentStart = start; currentStart <= end; currentStart += MAX_RANGE_LEN) {\n        const currentEnd = Math.min(currentStart + MAX_RANGE_LEN - 1, end);\n        buffers.push(await this.fetchRangePart(currentStart, currentEnd));\n      }\n      const totalSize = buffers.reduce((sum, buffer) => sum + buffer.byteLength, 0);\n      const combinedBuffer = new Uint8Array(totalSize);\n      let offset = 0;\n      for (const buffer of buffers) {\n        combinedBuffer.set(new Uint8Array(buffer), offset);\n        offset += buffer.byteLength;\n      }\n      return combinedBuffer.buffer;\n    } else if (rangeSize > RemoteFile.MAX_CACHE_CHUNK_SIZE) {\n      return this.fetchRangePart(start, end);\n    } else {\n      const cachedChunkStart = Array.from(this.#cache.keys()).find((chunkStart) => {\n        const buffer = this.#cache.get(chunkStart)!;\n        const bufferSize = buffer.byteLength;\n        return start >= chunkStart && end <= chunkStart + bufferSize;\n      });\n      if (cachedChunkStart !== undefined) {\n        this.#updateAccessOrder(cachedChunkStart);\n        const buffer = this.#cache.get(cachedChunkStart)!;\n        const offset = start - cachedChunkStart;\n        return buffer.slice(offset, offset + rangeSize);\n      }\n\n      const fetchKey = `${start}-${end}`;\n      const pendingFetch = this.#pendingFetches.get(fetchKey);\n\n      if (pendingFetch) {\n        return pendingFetch;\n      }\n\n      const fetchPromise = this.#fetchAndCacheChunkSafe(start, end, rangeSize);\n      this.#pendingFetches.set(fetchKey, fetchPromise);\n      try {\n        return await fetchPromise;\n      } finally {\n        this.#pendingFetches.delete(fetchKey);\n      }\n    }\n  }\n\n  async #fetchAndCacheChunkSafe(\n    start: number,\n    end: number,\n    rangeSize: number,\n  ): Promise<ArrayBuffer> {\n    const chunkStart = Math.max(0, start - 1024);\n    const chunkEnd = Math.max(end, start + RemoteFile.MAX_CACHE_CHUNK_SIZE - 1024 - 1);\n    const buffer = await this.fetchRangePart(chunkStart, chunkEnd);\n\n    // Only one thread reaches here per unique range\n    this.#cache.set(chunkStart, buffer);\n    this.#updateAccessOrder(chunkStart);\n    this.#ensureCacheSize();\n\n    const offset = start - chunkStart;\n    return buffer.slice(offset, offset + rangeSize);\n  }\n\n  #updateAccessOrder(chunkStart: number) {\n    const index = this.#order.indexOf(chunkStart);\n    if (index > -1) {\n      this.#order.splice(index, 1);\n    }\n    this.#order.unshift(chunkStart);\n  }\n\n  #ensureCacheSize() {\n    while (this.#cache.size > RemoteFile.MAX_CACHE_ITEMS_SIZE) {\n      const oldestKey = this.#order.pop();\n      if (oldestKey !== undefined) {\n        this.#cache.delete(oldestKey);\n      }\n    }\n  }\n\n  override slice(start = 0, end = this.size, contentType = this.type): Blob {\n    // console.log(`Slicing: ${start}-${end}, size: ${end - start}`);\n    const dataPromise = this.fetchRange(start, end - 1);\n\n    return new DeferredBlob(dataPromise, contentType);\n  }\n\n  override async text() {\n    const blob = this.slice(0, this.size);\n    return blob.text();\n  }\n\n  override async arrayBuffer() {\n    const blob = this.slice(0, this.size);\n    return blob.arrayBuffer();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 436, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/types/book.ts"],"sourcesContent":["import { BookMetadata } from '@/libs/document';\nimport { TTSHighlightOptions } from '@/services/tts/types';\nimport { AnnotationToolType } from './annotator';\n\nexport type BookFormat =\n  | 'EPUB'\n  | 'PDF'\n  | 'MOBI'\n  | 'AZW'\n  | 'AZW3'\n  | 'CBZ'\n  | 'FB2'\n  | 'FBZ'\n  | 'TXT'\n  | 'MD';\nexport type BookNoteType = 'bookmark' | 'annotation' | 'excerpt';\nexport type HighlightStyle = 'highlight' | 'underline' | 'squiggly';\nexport type HighlightColor = 'red' | 'yellow' | 'green' | 'blue' | 'violet';\n\nexport const FIXED_LAYOUT_FORMATS: Set<BookFormat> = new Set(['PDF', 'CBZ']);\n\nexport interface Book {\n  // if Book is a remote book we just lazy load the book content via url\n  url?: string;\n  // if Book is a transient local book we can load the book content via filePath\n  filePath?: string;\n  // For local storage mode: relative path from storage root (e.g., \"fiction/book.epub\")\n  relativePath?: string;\n  // Absolute file path in the file system (for path reconciliation)\n  absolutePath?: string;\n  // Partial md5 hash of the book file, used as the unique identifier\n  hash: string;\n  // Metadata md5 hash, used to aggregate different versions of the same book\n  metaHash?: string;\n  format: BookFormat;\n  title: string; // editable title from metadata\n  sourceTitle?: string; // parsed when the book is imported and used to locate the file\n  author: string;\n  group?: string; // deprecated in favor of groupId and groupName\n  groupId?: string;\n  groupName?: string;\n  tags?: string[];\n  coverImageUrl?: string | null;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n\n  uploadedAt?: number | null;\n  downloadedAt?: number | null;\n  coverDownloadedAt?: number | null;\n  syncedAt?: number | null;\n\n  lastUpdated?: number; // deprecated in favor of updatedAt\n  progress?: [number, number]; // Add progress field: [current, total], 1-based page number\n  primaryLanguage?: string;\n\n  metadata?: BookMetadata;\n}\n\nexport interface BookGroupType {\n  id: string;\n  name: string;\n}\n\nexport interface PageInfo {\n  current: number;\n  next?: number;\n  total: number;\n}\n\n// Remaining time of the book in minutes\nexport interface TimeInfo {\n  section: number;\n  total: number;\n}\n\nexport interface BookNote {\n  bookHash?: string;\n  metaHash?: string;\n  id: string;\n  type: BookNoteType;\n  cfi: string;\n  text?: string;\n  style?: HighlightStyle;\n  color?: HighlightColor;\n  note: string;\n\n  createdAt: number;\n  updatedAt: number;\n  deletedAt?: number | null;\n}\n\nexport interface BooknoteGroup {\n  id: number;\n  href: string;\n  label: string;\n  booknotes: BookNote[];\n}\n\nexport type WritingMode = 'auto' | 'horizontal-tb' | 'horizontal-rl' | 'vertical-rl';\n\nexport interface BookLayout {\n  marginTopPx: number;\n  marginBottomPx: number;\n  marginLeftPx: number;\n  marginRightPx: number;\n  marginPx?: number; // deprecated\n  compactMarginTopPx: number;\n  compactMarginBottomPx: number;\n  compactMarginLeftPx: number;\n  compactMarginRightPx: number;\n  compactMarginPx?: number; // deprecated\n  gapPercent: number;\n  scrolled: boolean;\n  disableClick: boolean;\n  fullscreenClickArea: boolean;\n  swapClickArea: boolean;\n  disableDoubleClick: boolean;\n  volumeKeysToFlip: boolean;\n  continuousScroll: boolean;\n  maxColumnCount: number;\n  maxInlineSize: number;\n  maxBlockSize: number;\n  animated: boolean;\n  isEink: boolean;\n  writingMode: WritingMode;\n  vertical: boolean;\n  rtl: boolean;\n  scrollingOverlap: number;\n  allowScript: boolean;\n}\n\nexport interface BookStyle {\n  zoomLevel: number;\n  paragraphMargin: number;\n  lineHeight: number;\n  wordSpacing: number;\n  letterSpacing: number;\n  textIndent: number;\n  fullJustification: boolean;\n  hyphenation: boolean;\n  invertImgColorInDark: boolean;\n  theme: string;\n  overrideFont: boolean;\n  overrideLayout: boolean;\n  overrideColor: boolean;\n  backgroundTextureId: string;\n  backgroundOpacity: number;\n  backgroundSize: string;\n  codeHighlighting: boolean;\n  codeLanguage: string;\n  userStylesheet: string;\n  userUIStylesheet: string;\n\n  // fixed-layout specific\n  zoomMode: 'fit-page' | 'fit-width' | 'original-size' | 'custom';\n  spreadMode: 'auto' | 'none';\n  keepCoverSpread: boolean;\n}\n\nexport interface BookFont {\n  serifFont: string;\n  sansSerifFont: string;\n  monospaceFont: string;\n  defaultFont: string;\n  defaultCJKFont: string;\n  defaultFontSize: number;\n  minimumFontSize: number;\n  fontWeight: number;\n}\n\nexport type ConvertChineseVariant =\n  | 'none'\n  | 's2t'\n  | 't2s'\n  | 's2tw'\n  | 's2hk'\n  | 's2twp'\n  | 'tw2s'\n  | 'hk2s'\n  | 'tw2sp';\n\nexport interface BookLanguage {\n  replaceQuotationMarks: boolean;\n  convertChineseVariant: ConvertChineseVariant;\n}\n\nexport interface ViewConfig {\n  sideBarTab: string;\n  uiLanguage: string;\n  sortedTOC: boolean;\n\n  doubleBorder: boolean;\n  borderColor: string;\n\n  showHeader: boolean;\n  showFooter: boolean;\n  showRemainingTime: boolean;\n  showRemainingPages: boolean;\n  showProgressInfo: boolean;\n  tapToToggleFooter: boolean;\n  showBarsOnScroll: boolean;\n  showMarginsOnScroll: boolean;\n  progressStyle: 'percentage' | 'fraction';\n  progressInfoMode: 'remaining' | 'progress' | 'all' | 'none';\n}\n\nexport interface TTSConfig {\n  ttsRate: number;\n  ttsVoice: string;\n  ttsLocation: string;\n  showTTSBar: boolean;\n  ttsHighlightOptions: TTSHighlightOptions;\n}\n\nexport interface TranslatorConfig {\n  translationEnabled: boolean;\n  translationProvider: string;\n  translateTargetLang: string;\n  showTranslateSource: boolean;\n  ttsReadAloudText: string;\n}\n\nexport interface NoteExportConfig {\n  includeTitle: boolean;\n  includeAuthor: boolean;\n  includeDate: boolean;\n  includeChapterTitles: boolean;\n  includeQuotes: boolean;\n  includeNotes: boolean;\n  includeTimestamp: boolean;\n  includeChapterSeparator: boolean;\n  noteSeparator: string;\n  useCustomTemplate: boolean;\n  customTemplate: string;\n}\n\nexport interface AnnotatorConfig {\n  enableAnnotationQuickActions: boolean;\n  annotationQuickAction: AnnotationToolType | null;\n  copyToNotebook: boolean;\n  noteExportConfig: NoteExportConfig;\n}\n\nexport interface ScreenConfig {\n  screenOrientation: 'auto' | 'portrait' | 'landscape';\n}\n\nexport type ProofreadScope = 'selection' | 'book' | 'library';\n\nexport interface ProofreadRule {\n  id: string;\n  scope: ProofreadScope;\n  pattern: string;\n  replacement: string;\n  cfi?: string;\n  sectionHref?: string;\n  enabled: boolean;\n  isRegex: boolean;\n  order: number; // Lower numbers apply first\n  wholeWord?: boolean; // Match whole words only (uses \\b word boundaries)\n  caseSensitive?: boolean; // Case-sensitive matching (default true)\n  onlyForTTS?: boolean; // Only replace text for TTS, not in the book display (only for book/library scope)\n}\n\nexport interface ProofreadRulesConfig {\n  proofreadRules?: ProofreadRule[];\n}\n\nexport interface ViewSettings\n  extends BookLayout,\n  BookStyle,\n  BookFont,\n  BookLanguage,\n  ViewConfig,\n  TTSConfig,\n  TranslatorConfig,\n  ScreenConfig,\n  ProofreadRulesConfig,\n  AnnotatorConfig { }\n\nexport interface BookProgress {\n  location: string;\n  sectionId: number;\n  sectionHref: string;\n  sectionLabel: string;\n  section: PageInfo;\n  pageinfo: PageInfo;\n  timeinfo: TimeInfo;\n  range: Range;\n}\n\nexport interface BookSearchConfig {\n  scope: 'book' | 'section';\n  matchCase: boolean;\n  matchWholeWords: boolean;\n  matchDiacritics: boolean;\n  index?: number;\n  query?: string;\n  acceptNode?: (node: Node) => number;\n\n  // pre-cached search results\n  results?: BookSearchResult[] | BookSearchMatch[] | null;\n}\n\nexport interface SearchExcerpt {\n  pre: string;\n  match: string;\n  post: string;\n}\n\nexport interface BookSearchMatch {\n  cfi: string;\n  excerpt: SearchExcerpt;\n}\n\nexport interface BookSearchResult {\n  index?: number;\n  label: string;\n  subitems: BookSearchMatch[];\n  progress?: number;\n}\n\nexport interface BookConfig {\n  bookHash?: string;\n  metaHash?: string;\n  progress?: [number, number]; // [current pagenum, total pagenum], 1-based page number\n  location?: string; // CFI of the current location\n  xpointer?: string; // XPointer of the current location (for Koreader interoperability)\n  booknotes?: BookNote[];\n  searchConfig?: Partial<BookSearchConfig>;\n  viewSettings?: Partial<ViewSettings>;\n\n  lastSyncedAtConfig?: number;\n  lastSyncedAtNotes?: number;\n\n  updatedAt: number;\n}\n\nexport interface BookDataRecord {\n  id: string;\n  book_hash: string;\n  meta_hash?: string;\n  user_id: string;\n  updated_at: number | null;\n  deleted_at: number | null;\n}\n\nexport interface BooksGroup {\n  id: string;\n  name: string;\n  displayName: string;\n  books: Book[];\n\n  updatedAt: number;\n}\nexport interface BookContent {\n  book: Book;\n  file: File;\n}\n"],"names":[],"mappings":";;;;AAmBO,MAAM,uBAAwC,IAAI,IAAI;IAAC;IAAO;CAAM"}},
    {"offset": {"line": 448, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/packages/foliate-js/epubcfi.js"],"sourcesContent":["const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i] ?? [], q = b[i] ?? []\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 872, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/libs/document.ts"],"sourcesContent":["import { BookFormat } from '@/types/book';\nimport { Contributor, Identifier, LanguageMap } from '@/utils/book';\nimport * as epubcfi from 'foliate-js/epubcfi.js';\n\nexport const CFI = epubcfi;\n\nexport type DocumentFile = File;\n\nexport type Location = {\n  current: number;\n  next: number;\n  total: number;\n};\n\nexport interface TOCItem {\n  id: number;\n  label: string;\n  href: string;\n  cfi?: string;\n  location?: Location;\n  subitems?: TOCItem[];\n}\n\nexport interface SectionItem {\n  id: string;\n  cfi: string;\n  size: number;\n  linear: string;\n  location?: Location;\n  pageSpread?: 'left' | 'right' | 'center' | '';\n\n  createDocument: () => Promise<Document>;\n}\n\nexport type BookMetadata = {\n  // NOTE: the title and author fields should be formatted\n  title: string | LanguageMap;\n  author: string | Contributor;\n  language: string | string[];\n  editor?: string;\n  publisher?: string;\n  published?: string;\n  description?: string;\n  subject?: string | string[] | Contributor;\n  identifier?: string;\n  altIdentifier?: string | string[] | Identifier;\n\n  subtitle?: string;\n  series?: string;\n  seriesIndex?: number;\n  seriesTotal?: number;\n\n  coverImageFile?: string;\n  coverImageUrl?: string;\n  coverImageBlobUrl?: string;\n};\n\nexport interface BookDoc {\n  metadata: BookMetadata;\n  rendition?: {\n    layout?: 'pre-paginated' | 'reflowable';\n    spread?: 'auto' | 'none';\n    viewport?: { width: number; height: number };\n  };\n  dir: string;\n  toc?: Array<TOCItem>;\n  sections?: Array<SectionItem>;\n  transformTarget?: EventTarget;\n  splitTOCHref(href: string): Array<string | number>;\n  getCover(): Promise<Blob | null>;\n}\n\nexport const EXTS: Record<BookFormat, string> = {\n  EPUB: 'epub',\n  PDF: 'pdf',\n  MOBI: 'mobi',\n  AZW: 'azw',\n  AZW3: 'azw3',\n  CBZ: 'cbz',\n  FB2: 'fb2',\n  FBZ: 'fbz',\n  TXT: 'txt',\n  MD: 'md',\n};\n\nexport const MIMETYPES: Record<BookFormat, string[]> = {\n  EPUB: ['application/epub+zip'],\n  PDF: ['application/pdf'],\n  MOBI: ['application/x-mobipocket-ebook'],\n  AZW: ['application/vnd.amazon.ebook'],\n  AZW3: ['application/vnd.amazon.mobi8-ebook', 'application/x-mobi8-ebook'],\n  CBZ: ['application/vnd.comicbook+zip', 'application/zip', 'application/x-cbz'],\n  FB2: ['application/x-fictionbook+xml', 'text/xml', 'application/xml'],\n  FBZ: ['application/x-zip-compressed-fb2', 'application/zip'],\n  TXT: ['text/plain'],\n  MD: ['text/markdown', 'text/x-markdown'],\n};\n\nexport class DocumentLoader {\n  private file: File;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  private async isZip(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 4).arrayBuffer());\n    return arr[0] === 0x50 && arr[1] === 0x4b && arr[2] === 0x03 && arr[3] === 0x04;\n  }\n\n  private async isPDF(): Promise<boolean> {\n    const arr = new Uint8Array(await this.file.slice(0, 5).arrayBuffer());\n    return (\n      arr[0] === 0x25 && arr[1] === 0x50 && arr[2] === 0x44 && arr[3] === 0x46 && arr[4] === 0x2d\n    );\n  }\n\n  private async makeZipLoader() {\n    const getComment = async (): Promise<string | null> => {\n      const EOCD_SIGNATURE = [0x50, 0x4b, 0x05, 0x06];\n      const maxEOCDSearch = 1024 * 64;\n\n      const sliceSize = Math.min(maxEOCDSearch, this.file.size);\n      const tail = await this.file.slice(this.file.size - sliceSize, this.file.size).arrayBuffer();\n      const bytes = new Uint8Array(tail);\n\n      for (let i = bytes.length - 22; i >= 0; i--) {\n        if (\n          bytes[i] === EOCD_SIGNATURE[0] &&\n          bytes[i + 1] === EOCD_SIGNATURE[1] &&\n          bytes[i + 2] === EOCD_SIGNATURE[2] &&\n          bytes[i + 3] === EOCD_SIGNATURE[3]\n        ) {\n          const commentLength = bytes[i + 20]! + (bytes[i + 21]! << 8);\n          const commentStart = i + 22;\n          const commentBytes = bytes.slice(commentStart, commentStart + commentLength);\n          return new TextDecoder().decode(commentBytes);\n        }\n      }\n\n      return null;\n    };\n\n    const { configure, ZipReader, BlobReader, TextWriter, BlobWriter } = await import(\n      '@zip.js/zip.js'\n    );\n    type Entry = import('@zip.js/zip.js').Entry;\n    configure({ useWebWorkers: false });\n    const reader = new ZipReader(new BlobReader(this.file));\n    const entries = await reader.getEntries();\n    const map = new Map(entries.map((entry) => [entry.filename, entry]));\n    const load =\n      (f: (entry: Entry, type?: string) => Promise<string | Blob> | null) =>\n      (name: string, ...args: [string?]) =>\n        map.has(name) ? f(map.get(name)!, ...args) : null;\n\n    const loadText = load((entry: Entry) =>\n      entry.getData ? entry.getData(new TextWriter()) : null,\n    );\n    const loadBlob = load((entry: Entry, type?: string) =>\n      entry.getData ? entry.getData(new BlobWriter(type!)) : null,\n    );\n    const getSize = (name: string) => map.get(name)?.uncompressedSize ?? 0;\n\n    return { entries, loadText, loadBlob, getSize, getComment, sha1: undefined };\n  }\n\n  private isCBZ(): boolean {\n    return (\n      this.file.type === 'application/vnd.comicbook+zip' || this.file.name.endsWith(`.${EXTS.CBZ}`)\n    );\n  }\n\n  private isFB2(): boolean {\n    return (\n      this.file.type === 'application/x-fictionbook+xml' || this.file.name.endsWith(`.${EXTS.FB2}`)\n    );\n  }\n\n  private isFBZ(): boolean {\n    return (\n      this.file.type === 'application/x-zip-compressed-fb2' ||\n      this.file.name.endsWith('.fb.zip') ||\n      this.file.name.endsWith('.fb2.zip') ||\n      this.file.name.endsWith(`.${EXTS.FBZ}`)\n    );\n  }\n\n  public async open(): Promise<{ book: BookDoc; format: BookFormat }> {\n    let book = null;\n    let format: BookFormat = 'EPUB';\n    if (!this.file.size) {\n      throw new Error('File is empty');\n    }\n    try {\n      if (await this.isZip()) {\n        const loader = await this.makeZipLoader();\n        const { entries } = loader;\n\n        if (this.isCBZ()) {\n          const { makeComicBook } = await import('foliate-js/comic-book.js');\n          book = await makeComicBook(loader, this.file);\n          format = 'CBZ';\n        } else if (this.isFBZ()) {\n          const entry = entries.find((entry) => entry.filename.endsWith(`.${EXTS.FB2}`));\n          const blob = await loader.loadBlob((entry ?? entries[0]!).filename);\n          const { makeFB2 } = await import('foliate-js/fb2.js');\n          book = await makeFB2(blob);\n          format = 'FBZ';\n        } else {\n          const { EPUB } = await import('foliate-js/epub.js');\n          book = await new EPUB(loader).init();\n          format = 'EPUB';\n        }\n      } else if (await this.isPDF()) {\n        const { makePDF } = await import('foliate-js/pdf.js');\n        book = await makePDF(this.file);\n        format = 'PDF';\n      } else if (await (await import('foliate-js/mobi.js')).isMOBI(this.file)) {\n        const fflate = await import('foliate-js/vendor/fflate.js');\n        const { MOBI } = await import('foliate-js/mobi.js');\n        book = await new MOBI({ unzlib: fflate.unzlibSync }).open(this.file);\n        const ext = this.file.name.split('.').pop()?.toLowerCase();\n        switch (ext) {\n          case 'azw':\n            format = 'AZW';\n            break;\n          case 'azw3':\n            format = 'AZW3';\n            break;\n          default:\n            format = 'MOBI';\n        }\n      } else if (this.isFB2()) {\n        const { makeFB2 } = await import('foliate-js/fb2.js');\n        book = await makeFB2(this.file);\n        format = 'FB2';\n      }\n    } catch (e: unknown) {\n      console.error('Failed to open document:', e);\n      if (e instanceof Error && e.message?.includes('not a valid zip')) {\n        throw new Error('Unsupported or corrupted book file');\n      }\n      throw e;\n    }\n    return { book, format } as { book: BookDoc; format: BookFormat };\n  }\n}\n\nexport const getDirection = (doc: Document) => {\n  const { defaultView } = doc;\n  const { writingMode, direction } = defaultView!.getComputedStyle(doc.body);\n  const vertical = writingMode === 'vertical-rl' || writingMode === 'vertical-lr';\n  const rtl = doc.body.dir === 'rtl' || direction === 'rtl' || doc.documentElement.dir === 'rtl';\n  return { vertical, rtl };\n};\n\nexport const getFileExtFromMimeType = (mimeType?: string): string => {\n  if (!mimeType) return '';\n\n  for (const format in MIMETYPES) {\n    const list = MIMETYPES[format as BookFormat];\n    if (list.includes(mimeType)) {\n      return EXTS[format as BookFormat];\n    }\n  }\n  return '';\n};\n\nexport const getMimeTypeFromFileExt = (ext: string): string => {\n  ext = ext.toLowerCase();\n  for (const format in EXTS) {\n    if (EXTS[format as BookFormat] === ext) {\n      const mimeTypes = MIMETYPES[format as BookFormat];\n      return mimeTypes[0] || 'application/octet-stream';\n    }\n  }\n  return 'application/octet-stream';\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1139, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/lang.ts"],"sourcesContent":["import { LocaleWithTextInfo } from '@/types/misc';\nimport { franc } from 'franc-min';\nimport { iso6392 } from 'iso-639-2';\nimport { iso6393To1 } from 'iso-639-3';\n\nexport const isCJKStr = (str: string) => {\n  return /[\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}]/u.test(str ?? '');\n};\n\nexport const isCJKLang = (lang: string | null | undefined): boolean => {\n  if (!lang) return false;\n  const normalizedLang = normalizedLangCode(lang);\n  return ['zh', 'ja', 'ko', 'zho', 'jpn', 'kor'].includes(normalizedLang);\n};\n\nconst ZH_SCRIPTS_MAPPING: Record<string, string> = {\n  zh: 'zh-Hans',\n  'zh-cn': 'zh-Hans',\n  'zh-hk': 'zh-Hant',\n  'zh-tw': 'zh-Hant',\n  'zh-mo': 'zh-Hant',\n  'zh-hans': 'zh-Hans',\n  'zh-hant': 'zh-Hant',\n};\n\nexport const normalizeToFullLang = (langCode: string): string => {\n  try {\n    const locale = new Intl.Locale(langCode.toLowerCase());\n    const maximized = locale.maximize();\n\n    if (maximized.language === 'zh') {\n      return maximized.script === 'Hant' ? 'zh-Hant' : 'zh-Hans';\n    }\n\n    return maximized.region ? `${maximized.language}-${maximized.region}` : langCode;\n  } catch {\n    return ZH_SCRIPTS_MAPPING[langCode.toLowerCase()] || langCode;\n  }\n};\n\nexport const normalizeToShortLang = (langCode: string): string => {\n  const lang = langCode.toLowerCase();\n  if (lang.startsWith('zh')) {\n    return ZH_SCRIPTS_MAPPING[lang] || 'zh-Hans';\n  }\n  return lang.split('-')[0]!;\n};\n\nexport const normalizedLangCode = (lang: string | null | undefined): string => {\n  if (!lang) return '';\n  return lang.split('-')[0]!.toLowerCase();\n};\n\nexport const isSameLang = (lang1?: string | null, lang2?: string | null): boolean => {\n  if (!lang1 || !lang2) return false;\n  const normalizedLang1 = normalizedLangCode(lang1);\n  const normalizedLang2 = normalizedLangCode(lang2);\n  return normalizedLang1 === normalizedLang2;\n};\n\nexport const isValidLang = (lang?: string) => {\n  if (!lang) return false;\n  if (typeof lang !== 'string') return false;\n  if (['und', 'mul', 'mis', 'zxx'].includes(lang)) return false;\n  const code = normalizedLangCode(lang);\n  return iso6392.some((l) => l.iso6391 === code || l.iso6392B === code);\n};\n\nexport const code6392to6391 = (code: string): string => {\n  const lang = iso6392.find((l) => l.iso6392B === code);\n  return lang?.iso6391 || '';\n};\n\nconst commonIndivToMacro: Record<string, string> = {\n  cmn: 'zho',\n  arb: 'ara',\n  arz: 'ara',\n  ind: 'msa',\n  zsm: 'msa',\n  nob: 'nor',\n  nno: 'nor',\n  pes: 'fas',\n  quy: 'que',\n};\n\nexport const code6393to6391 = (code: string): string => {\n  const macro = commonIndivToMacro[code] || code;\n  return iso6393To1[macro] || '';\n};\n\nexport const getLanguageName = (code: string): string => {\n  const lang = normalizedLangCode(code);\n  const language = iso6392.find((l) => l.iso6391 === lang || l.iso6392B === lang);\n  return language ? language.name : lang;\n};\n\nexport const inferLangFromScript = (text: string, lang: string): string => {\n  if (!lang || lang === 'en') {\n    if (/[\\p{Script=Hangul}]/u.test(text)) {\n      return 'ko';\n    } else if (/[\\p{Script=Hiragana}\\p{Script=Katakana}]/u.test(text)) {\n      return 'ja';\n    } else if (/[\\p{Script=Han}]/u.test(text)) {\n      return 'zh';\n    }\n  }\n  return lang;\n};\n\nexport const detectLanguage = (content: string): string => {\n  try {\n    const iso6393Lang = franc(content.substring(0, 1000));\n    const iso6391Lang = code6393to6391(iso6393Lang) || 'en';\n    return iso6391Lang;\n  } catch {\n    console.warn('Language detection failed, defaulting to en.');\n    return 'en';\n  }\n};\n\nexport const getLanguageInfo = (lang: string) => {\n  if (!lang) return {};\n  try {\n    const canonical = Intl.getCanonicalLocales(lang)[0]!;\n    const locale = new Intl.Locale(canonical) as LocaleWithTextInfo;\n    const isCJK = ['zh', 'ja', 'kr'].includes(locale.language);\n    const direction = (locale.getTextInfo?.() ?? locale.textInfo)?.direction;\n    return { canonical, locale, isCJK, direction };\n  } catch (e) {\n    console.warn(e);\n    return {};\n  }\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;;;;;;;;;;AAEO,MAAM,WAAW,CAAC;IACvB,OAAO,2EAA2E,IAAI,CAAC,OAAO;AAChG;AAEO,MAAM,YAAY,CAAC;IACxB,IAAI,CAAC,MAAM,OAAO;IAClB,MAAM,iBAAiB,mBAAmB;IAC1C,OAAO;QAAC;QAAM;QAAM;QAAM;QAAO;QAAO;KAAM,CAAC,QAAQ,CAAC;AAC1D;AAEA,MAAM,qBAA6C;IACjD,IAAI;IACJ,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;AACb;AAEO,MAAM,sBAAsB,CAAC;IAClC,IAAI;QACF,MAAM,SAAS,IAAI,KAAK,MAAM,CAAC,SAAS,WAAW;QACnD,MAAM,YAAY,OAAO,QAAQ;QAEjC,IAAI,UAAU,QAAQ,KAAK,MAAM;YAC/B,OAAO,UAAU,MAAM,KAAK,SAAS,YAAY;QACnD;QAEA,OAAO,UAAU,MAAM,GAAG,GAAG,UAAU,QAAQ,CAAC,CAAC,EAAE,UAAU,MAAM,EAAE,GAAG;IAC1E,EAAE,OAAM;QACN,OAAO,kBAAkB,CAAC,SAAS,WAAW,GAAG,IAAI;IACvD;AACF;AAEO,MAAM,uBAAuB,CAAC;IACnC,MAAM,OAAO,SAAS,WAAW;IACjC,IAAI,KAAK,UAAU,CAAC,OAAO;QACzB,OAAO,kBAAkB,CAAC,KAAK,IAAI;IACrC;IACA,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;AAC3B;AAEO,MAAM,qBAAqB,CAAC;IACjC,IAAI,CAAC,MAAM,OAAO;IAClB,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE,CAAE,WAAW;AACxC;AAEO,MAAM,aAAa,CAAC,OAAuB;IAChD,IAAI,CAAC,SAAS,CAAC,OAAO,OAAO;IAC7B,MAAM,kBAAkB,mBAAmB;IAC3C,MAAM,kBAAkB,mBAAmB;IAC3C,OAAO,oBAAoB;AAC7B;AAEO,MAAM,cAAc,CAAC;IAC1B,IAAI,CAAC,MAAM,OAAO;IAClB,IAAI,OAAO,SAAS,UAAU,OAAO;IACrC,IAAI;QAAC;QAAO;QAAO;QAAO;KAAM,CAAC,QAAQ,CAAC,OAAO,OAAO;IACxD,MAAM,OAAO,mBAAmB;IAChC,OAAO,yIAAO,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK,QAAQ,EAAE,QAAQ,KAAK;AAClE;AAEO,MAAM,iBAAiB,CAAC;IAC7B,MAAM,OAAO,yIAAO,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;IAChD,OAAO,MAAM,WAAW;AAC1B;AAEA,MAAM,qBAA6C;IACjD,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACP;AAEO,MAAM,iBAAiB,CAAC;IAC7B,MAAM,QAAQ,kBAAkB,CAAC,KAAK,IAAI;IAC1C,OAAO,4IAAU,CAAC,MAAM,IAAI;AAC9B;AAEO,MAAM,kBAAkB,CAAC;IAC9B,MAAM,OAAO,mBAAmB;IAChC,MAAM,WAAW,yIAAO,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK,QAAQ,EAAE,QAAQ,KAAK;IAC1E,OAAO,WAAW,SAAS,IAAI,GAAG;AACpC;AAEO,MAAM,sBAAsB,CAAC,MAAc;IAChD,IAAI,CAAC,QAAQ,SAAS,MAAM;QAC1B,IAAI,uBAAuB,IAAI,CAAC,OAAO;YACrC,OAAO;QACT,OAAO,IAAI,4CAA4C,IAAI,CAAC,OAAO;YACjE,OAAO;QACT,OAAO,IAAI,oBAAoB,IAAI,CAAC,OAAO;YACzC,OAAO;QACT;IACF;IACA,OAAO;AACT;AAEO,MAAM,iBAAiB,CAAC;IAC7B,IAAI;QACF,MAAM,cAAc,IAAA,iIAAK,EAAC,QAAQ,SAAS,CAAC,GAAG;QAC/C,MAAM,cAAc,eAAe,gBAAgB;QACnD,OAAO;IACT,EAAE,OAAM;QACN,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;AACF;AAEO,MAAM,kBAAkB,CAAC;IAC9B,IAAI,CAAC,MAAM,OAAO,CAAC;IACnB,IAAI;QACF,MAAM,YAAY,KAAK,mBAAmB,CAAC,KAAK,CAAC,EAAE;QACnD,MAAM,SAAS,IAAI,KAAK,MAAM,CAAC;QAC/B,MAAM,QAAQ;YAAC;YAAM;YAAM;SAAK,CAAC,QAAQ,CAAC,OAAO,QAAQ;QACzD,MAAM,YAAY,CAAC,OAAO,WAAW,QAAQ,OAAO,QAAQ,GAAG;QAC/D,OAAO;YAAE;YAAW;YAAQ;YAAO;QAAU;IAC/C,EAAE,OAAO,GAAG;QACV,QAAQ,IAAI,CAAC;QACb,OAAO,CAAC;IACV;AACF"}},
    {"offset": {"line": 1319, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/book.ts"],"sourcesContent":["import { BookMetadata, EXTS } from '@/libs/document';\nimport { Book, BookConfig, BookProgress, WritingMode } from '@/types/book';\nimport { SUPPORTED_LANGS } from '@/services/constants';\nimport { getUserLang } from './misc';\nimport { getDirFromLanguage } from './rtl';\nimport { code6392to6391, isValidLang, normalizedLangCode } from './lang';\nimport { md5 } from './md5';\n\nexport const getDir = (book: Book) => {\n  // In local storage mode, return the folder name (same as book name without extension)\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath.replace(/\\.[^.]+$/, '');\n};\nexport const getLibraryFilename = () => {\n  return 'library.json';\n};\nexport const getLibraryBackupFilename = () => {\n  return 'library_backup.json';\n};\nexport const getLocalBookFilename = (book: Book) => {\n  // In local storage mode, books are stored in their original relative paths\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  return book.relativePath;\n};\nexport const getCoverFilename = (book: Book) => {\n  // In local storage mode, covers are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  const result = `${pathWithoutExt}/cover.png`;\n  console.log('[getCoverFilename]  Using relativePath:', book.relativePath);\n  console.log('[getCoverFilename]  Cover path result:', result);\n  return result;\n};\nexport const getConfigFilename = (book: Book) => {\n  // In local storage mode, configs are stored in a folder next to the book with the same name\n  if (!book.relativePath) {\n    throw new Error(`Book ${book.title} (${book.hash}) is missing relativePath. Please re-import the book.`);\n  }\n  // Remove extension from book path to get folder name\n  const pathWithoutExt = book.relativePath.replace(/\\.[^.]+$/, '');\n  return `${pathWithoutExt}/config.json`;\n};\nexport const isBookFile = (filename: string) => {\n  return Object.values(EXTS).includes(filename.split('.').pop()!);\n};\n\nexport const INIT_BOOK_CONFIG: BookConfig = {\n  updatedAt: 0,\n};\n\nexport interface LanguageMap {\n  [key: string]: string;\n}\n\nexport interface Identifier {\n  scheme: string;\n  value: string;\n}\n\nexport interface Contributor {\n  name: LanguageMap;\n}\n\nconst formatLanguageMap = (x: string | LanguageMap, defaultLang = false): string => {\n  const userLang = getUserLang();\n  if (!x) return '';\n  if (typeof x === 'string') return x;\n  const keys = Object.keys(x);\n  return defaultLang ? x[keys[0]!]! : x[userLang] || x[keys[0]!]!;\n};\n\nexport const listFormater = (narrow = false, lang = '') => {\n  lang = lang ? lang : getUserLang();\n  if (narrow) {\n    return new Intl.ListFormat('en', { style: 'narrow', type: 'unit' });\n  } else {\n    return new Intl.ListFormat(lang, { style: 'long', type: 'conjunction' });\n  }\n};\n\nexport const getBookLangCode = (lang: string | string[] | undefined) => {\n  try {\n    const bookLang = typeof lang === 'string' ? lang : lang?.[0];\n    return bookLang ? bookLang.split('-')[0]! : '';\n  } catch {\n    return '';\n  }\n};\n\nexport const flattenContributors = (\n  contributors: string | string[] | Contributor | Contributor[],\n) => {\n  if (!contributors) return '';\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string' ? contributor : formatLanguageMap(contributor?.name),\n      )\n      .join(', ')\n    : typeof contributors === 'string'\n      ? contributors\n      : formatLanguageMap(contributors?.name);\n};\n\n// prettier-ignore\nconst LASTNAME_AUTHOR_SORT_LANGS = ['ar', 'bo', 'de', 'en', 'es', 'fr', 'hi', 'it', 'nl', 'pl', 'pt', 'ru', 'th', 'tr', 'uk'];\n\nconst formatAuthorName = (name: string, lastNameFirst: boolean) => {\n  if (!name) return '';\n  const parts = name.split(' ');\n  if (lastNameFirst && parts.length > 1) {\n    return `${parts[parts.length - 1]}, ${parts.slice(0, -1).join(' ')}`;\n  }\n  return name;\n};\n\nexport const formatAuthors = (\n  contributors: string | string[] | Contributor | Contributor[],\n  bookLang?: string | string[],\n  sortAs?: boolean,\n) => {\n  const langCode = getBookLangCode(bookLang) || 'en';\n  const lastNameFirst = !!sortAs && LASTNAME_AUTHOR_SORT_LANGS.includes(langCode);\n  return Array.isArray(contributors)\n    ? listFormater(langCode === 'zh', langCode).format(\n      contributors.map((contributor) =>\n        typeof contributor === 'string'\n          ? formatAuthorName(contributor, lastNameFirst)\n          : formatAuthorName(formatLanguageMap(contributor?.name), lastNameFirst),\n      ),\n    )\n    : typeof contributors === 'string'\n      ? formatAuthorName(contributors, lastNameFirst)\n      : formatAuthorName(formatLanguageMap(contributors?.name), lastNameFirst);\n};\n\nexport const formatTitle = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title);\n};\n\nexport const formatDescription = (description?: string | LanguageMap) => {\n  if (!description) return '';\n  const text = typeof description === 'string' ? description : formatLanguageMap(description);\n  return text\n    .replace(/<\\/?[^>]+(>|$)/g, '')\n    .replace(/&#\\d+;/g, '')\n    .trim();\n};\n\nexport const formatPublisher = (publisher: string | LanguageMap) => {\n  return typeof publisher === 'string' ? publisher : formatLanguageMap(publisher);\n};\n\nconst langCodeToLangName = (langCode: string) => {\n  return SUPPORTED_LANGS[langCode] || langCode.toUpperCase();\n};\n\nexport const formatLanguage = (lang: string | string[] | undefined): string => {\n  return Array.isArray(lang)\n    ? lang.map(langCodeToLangName).join(', ')\n    : langCodeToLangName(lang || '');\n};\n\n// Should return valid ISO-639-1 language code, fallback to 'en' if not valid\nexport const getPrimaryLanguage = (lang: string | string[] | undefined) => {\n  const primaryLang = Array.isArray(lang) ? lang[0] : lang;\n  if (isValidLang(primaryLang)) {\n    const normalizedLang = normalizedLangCode(primaryLang);\n    return code6392to6391(normalizedLang) || normalizedLang;\n  }\n  return 'en';\n};\n\nexport const formatDate = (date: string | number | Date | null | undefined, isUTC = false) => {\n  if (!date) return;\n  const userLang = getUserLang();\n  try {\n    return new Date(date).toLocaleDateString(userLang, {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      timeZone: isUTC ? 'UTC' : undefined,\n    });\n  } catch {\n    return;\n  }\n};\n\nexport const formatBytes = (bytes?: number | null, locale = 'en-US') => {\n  if (!bytes) return '';\n  const units = ['byte', 'kilobyte', 'megabyte', 'gigabyte', 'terabyte'];\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  const value = bytes / Math.pow(1024, i);\n  const formatter = new Intl.NumberFormat(locale, {\n    style: 'unit',\n    unit: units[i],\n    unitDisplay: 'short',\n    maximumFractionDigits: 2,\n  });\n  return formatter.format(value);\n};\n\nexport const getCurrentPage = (book: Book, progress: BookProgress) => {\n  const bookFormat = book.format;\n  const { section, pageinfo } = progress;\n  return bookFormat === 'PDF'\n    ? section\n      ? section.current + 1\n      : 0\n    : pageinfo\n      ? pageinfo.current + 1\n      : 0;\n};\n\nexport const getBookDirFromWritingMode = (writingMode: WritingMode) => {\n  switch (writingMode) {\n    case 'horizontal-tb':\n      return 'ltr';\n    case 'horizontal-rl':\n    case 'vertical-rl':\n      return 'rtl';\n    default:\n      return 'auto';\n  }\n};\n\nexport const getBookDirFromLanguage = (language: string | string[] | undefined) => {\n  const lang = getPrimaryLanguage(language) || '';\n  return getDirFromLanguage(lang);\n};\n\nconst getTitleForHash = (title: string | LanguageMap) => {\n  return typeof title === 'string' ? title : formatLanguageMap(title, true);\n};\n\nconst getAuthorsList = (contributors: string | string[] | Contributor | Contributor[]) => {\n  if (!contributors) return [];\n  return Array.isArray(contributors)\n    ? contributors\n      .map((contributor) =>\n        typeof contributor === 'string'\n          ? contributor\n          : formatLanguageMap(contributor?.name, true),\n      )\n      .filter(Boolean)\n    : [\n      typeof contributors === 'string'\n        ? contributors\n        : formatLanguageMap(contributors?.name, true),\n    ];\n};\n\nconst normalizeIdentifier = (identifier: string) => {\n  try {\n    if (identifier.includes('urn:')) {\n      // Slice after the last ':'\n      return identifier.match(/[^:]+$/)?.[0] || '';\n    } else if (identifier.includes(':')) {\n      // Slice after the first ':'\n      return identifier.match(/^[^:]+:(.+)$/)?.[1] || '';\n    }\n  } catch {\n    return identifier;\n  }\n  return identifier;\n};\n\nconst getPreferredIdentifier = (identifiers: string[] | Identifier[]) => {\n  for (const scheme of ['uuid', 'calibre', 'isbn']) {\n    const found = identifiers.find((identifier) =>\n      typeof identifier === 'string'\n        ? identifier.toLowerCase().includes(scheme)\n        : identifier.scheme.toLowerCase() === scheme,\n    );\n    if (found) {\n      return typeof found === 'string' ? normalizeIdentifier(found) : found.value;\n    }\n  }\n  return;\n};\n\nconst getIdentifiersList = (\n  identifiers: undefined | string | string[] | Identifier | Identifier[],\n) => {\n  if (!identifiers) return [];\n  if (Array.isArray(identifiers)) {\n    const preferred = getPreferredIdentifier(identifiers);\n    if (preferred) {\n      return [preferred];\n    }\n  }\n  return Array.isArray(identifiers)\n    ? identifiers\n      .map((identifier) =>\n        typeof identifier === 'string' ? normalizeIdentifier(identifier) : identifier.value,\n      )\n      .filter(Boolean)\n    : typeof identifiers === 'string'\n      ? [normalizeIdentifier(identifiers)]\n      : [identifiers.value];\n};\n\nexport const getMetadataHash = (metadata: BookMetadata) => {\n  try {\n    const title = getTitleForHash(metadata.title);\n    const authors = getAuthorsList(metadata.author).join(',');\n    const identifiers = getIdentifiersList(metadata.altIdentifier || metadata.identifier).join(',');\n    const hashSource = `${title}|${authors}|${identifiers}`;\n    const metaHash = md5(hashSource.normalize('NFC'));\n    return metaHash;\n  } catch (error) {\n    console.error('Error generating metadata hash:', error);\n  }\n  return;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1643, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/indexedDBCache.ts"],"sourcesContent":["/**\n * IndexedDB \n * \n */\n\nconst DB_NAME = 'readest-cache';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'files';\n\nexport interface CacheEntry {\n    key: string; //  URL\n    data: ArrayBuffer;\n    etag?: string;\n    mimeType: string;\n    timestamp: number;\n    expiresAt?: number; // \n}\n\nclass IndexedDBCache {\n    private db: IDBDatabase | null = null;\n    private initPromise: Promise<void> | null = null;\n\n    async init(): Promise<void> {\n        if (this.db) return;\n        if (this.initPromise) return this.initPromise;\n\n        this.initPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n            request.onerror = () => {\n                console.error('[IndexedDBCache] Failed to open database:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                console.log('[IndexedDBCache]  Database opened successfully');\n                resolve();\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = (event.target as IDBOpenDBRequest).result;\n                if (!db.objectStoreNames.contains(STORE_NAME)) {\n                    const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });\n                    store.createIndex('expiresAt', 'expiresAt', { unique: false });\n                    console.log('[IndexedDBCache]  Object store created');\n                }\n            };\n        });\n\n        return this.initPromise;\n    }\n\n    /**\n     * \n     */\n    async get(key: string): Promise<CacheEntry | null> {\n        await this.init();\n        if (!this.db) return null;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.get(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entry = request.result as CacheEntry | undefined;\n\n                // \n                if (entry && entry.expiresAt && Date.now() > entry.expiresAt) {\n                    console.log('[IndexedDBCache] Cache expired for:', key);\n                    // \n                    this.delete(key).catch(e => console.error('Failed to delete expired cache:', e));\n                    resolve(null);\n                } else {\n                    if (entry) {\n                        console.log('[IndexedDBCache]  Cache hit for:', key);\n                    }\n                    resolve(entry || null);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async set(\n        key: string,\n        data: ArrayBuffer,\n        mimeType: string,\n        options?: {\n            etag?: string;\n            ttl?: number; // \n        },\n    ): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        const entry: CacheEntry = {\n            key,\n            data,\n            mimeType,\n            etag: options?.etag,\n            timestamp: Date.now(),\n            expiresAt: options?.ttl ? Date.now() + options.ttl : undefined,\n        };\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.put(entry);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache saved for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async delete(key: string): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.delete(key);\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  Cache deleted for:', key);\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clear(): Promise<void> {\n        await this.init();\n        if (!this.db) return;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.clear();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                console.log('[IndexedDBCache]  All caches cleared');\n                resolve();\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async clearExpired(): Promise<number> {\n        await this.init();\n        if (!this.db) return 0;\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(STORE_NAME);\n            const index = store.index('expiresAt');\n            const range = IDBKeyRange.upperBound(Date.now());\n            const request = index.openCursor(range);\n\n            let deletedCount = 0;\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = (event) => {\n                const cursor = (event.target as IDBRequest).result;\n                if (cursor) {\n                    console.log('[IndexedDBCache] Deleting expired cache:', cursor.key);\n                    store.delete(cursor.primaryKey);\n                    deletedCount++;\n                    cursor.continue();\n                } else {\n                    console.log('[IndexedDBCache]  Cleared', deletedCount, 'expired caches');\n                    resolve(deletedCount);\n                }\n            };\n        });\n    }\n\n    /**\n     * \n     */\n    async getStats(): Promise<{\n        totalEntries: number;\n        totalSize: number; // \n        oldestEntry?: { key: string; timestamp: number };\n        newestEntry?: { key: string; timestamp: number };\n    }> {\n        await this.init();\n        if (!this.db) {\n            return { totalEntries: 0, totalSize: 0 };\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db!.transaction(STORE_NAME, 'readonly');\n            const store = transaction.objectStore(STORE_NAME);\n            const request = store.getAll();\n\n            request.onerror = () => reject(request.error);\n            request.onsuccess = () => {\n                const entries = request.result as CacheEntry[];\n                let totalSize = 0;\n                let oldestEntry: { key: string; timestamp: number } | undefined;\n                let newestEntry: { key: string; timestamp: number } | undefined;\n\n                entries.forEach((entry) => {\n                    totalSize += entry.data.byteLength;\n                    if (!oldestEntry || entry.timestamp < oldestEntry.timestamp) {\n                        oldestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                    if (!newestEntry || entry.timestamp > newestEntry.timestamp) {\n                        newestEntry = { key: entry.key, timestamp: entry.timestamp };\n                    }\n                });\n\n                console.log('[IndexedDBCache] Stats:', {\n                    entries: entries.length,\n                    size: (totalSize / 1024 / 1024).toFixed(2) + ' MB',\n                });\n\n                resolve({\n                    totalEntries: entries.length,\n                    totalSize,\n                    oldestEntry,\n                    newestEntry,\n                });\n            };\n        });\n    }\n}\n\nexport const indexedDBCache = new IndexedDBCache();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/cachedFetch.ts"],"sourcesContent":["/**\n * \n * HTTP   IndexedDB  \n */\n\nimport { indexedDBCache } from './indexedDBCache';\n\nexport type FetchOptions = {\n    /**  */\n    cacheStrategy?: 'network-first' | 'cache-first' | 'stale-while-revalidate';\n    /** 0  */\n    cacheTTL?: number;\n    /**  */\n    bypassCache?: boolean;\n    /**  HTTP  */\n    headers?: Record<string, string>;\n    /**  */\n    onProgress?: (progress: number) => void;\n};\n\nconst DEFAULT_OPTIONS: FetchOptions = {\n    cacheStrategy: 'cache-first',\n    cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n};\n\n/**\n * \n */\nfunction generateCacheKey(url: string): string {\n    return `file_${url}`;\n}\n\n/**\n *  fetch \n */\nexport async function cachedFetch(\n    url: string,\n    options: FetchOptions = {},\n): Promise<{ data: ArrayBuffer; headers: Headers; fromCache: boolean }> {\n    const finalOptions = { ...DEFAULT_OPTIONS, ...options };\n    const cacheKey = generateCacheKey(url);\n\n    console.log(`[cachedFetch] Fetching: ${url}, strategy: ${finalOptions.cacheStrategy}`);\n\n    try {\n        //  1: cache-first - \n        if (\n            finalOptions.cacheStrategy === 'cache-first' &&\n            !finalOptions.bypassCache\n        ) {\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                console.log(`[cachedFetch]  Using cached data for: ${url}`);\n                // \n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    ...(cached.etag && { 'ETag': cached.etag }),\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        // \n        const fetchHeaders = new Headers(finalOptions.headers || {});\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: fetchHeaders,\n            signal: AbortSignal.timeout(30000), // 30\n        });\n\n        //  304 Not Modified\n        if (response.status === 304) {\n            console.log(`[cachedFetch] 304 Not Modified for: ${url}`);\n            const cached = await indexedDBCache.get(cacheKey);\n            if (cached) {\n                const headers = new Headers({\n                    'Content-Type': cached.mimeType,\n                    'Content-Length': cached.data.byteLength.toString(),\n                    'ETag': response.headers.get('ETag') || cached.etag || '',\n                });\n                return { data: cached.data, headers, fromCache: true };\n            }\n        }\n\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // \n        const contentLength = parseInt(response.headers.get('Content-Length') || '0', 10);\n        const reader = response.body?.getReader();\n        const chunks: Uint8Array[] = [];\n        let receivedLength = 0;\n\n        if (reader) {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n\n                chunks.push(value);\n                receivedLength += value.length;\n\n                // \n                if (contentLength > 0 && finalOptions.onProgress) {\n                    const progress = Math.round((receivedLength / contentLength) * 100);\n                    finalOptions.onProgress(progress);\n                }\n            }\n        } else {\n            // Fallback  ReadableStream \n            chunks.push(new Uint8Array(await response.arrayBuffer()));\n        }\n\n        // \n        const data = new ArrayBuffer(receivedLength);\n        const dataView = new Uint8Array(data);\n        let offset = 0;\n        for (const chunk of chunks) {\n            dataView.set(chunk, offset);\n            offset += chunk.length;\n        }\n\n        // \n        const mimeType = response.headers.get('Content-Type') || 'application/octet-stream';\n        const etag = response.headers.get('ETag');\n\n        // \n        if (!finalOptions.bypassCache && response.status === 200) {\n            indexedDBCache\n                .set(cacheKey, data, mimeType, {\n                    etag: etag || undefined,\n                    ttl: finalOptions.cacheTTL,\n                })\n                .catch((error) => {\n                    console.warn(`[cachedFetch] Failed to cache ${url}:`, error);\n                });\n        }\n\n        console.log(`[cachedFetch]  Fetched ${(data.byteLength / 1024 / 1024).toFixed(2)} MB from network`);\n\n        return { data, headers: response.headers, fromCache: false };\n    } catch (error) {\n        //  network-first \n        console.warn(`[cachedFetch] Network error for ${url}:`, error);\n        const cached = await indexedDBCache.get(cacheKey);\n        if (cached) {\n            console.log(`[cachedFetch]  Using stale cache due to network error: ${url}`);\n            const headers = new Headers({\n                'Content-Type': cached.mimeType,\n                'Content-Length': cached.data.byteLength.toString(),\n                'Warning': '199 - \"Stale cache used due to network error\"',\n            });\n            return { data: cached.data, headers, fromCache: true };\n        }\n\n        throw error;\n    }\n}\n\n/**\n *  Blob URL\n */\nexport async function cachedFetchAsUrl(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data, headers } = await cachedFetch(url, options);\n    const mimeType = headers.get('Content-Type') || 'application/octet-stream';\n    const blob = new Blob([data], { type: mimeType });\n    return URL.createObjectURL(blob);\n}\n\n/**\n *  Base64\n */\nexport async function cachedFetchAsBase64(\n    url: string,\n    options: FetchOptions = {},\n): Promise<string> {\n    const { data } = await cachedFetch(url, options);\n    const bytes = new Uint8Array(data);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]!);\n    }\n    return btoa(binary);\n}\n\n/**\n * \n */\nexport async function clearFileCache(url?: string): Promise<void> {\n    if (url) {\n        const cacheKey = generateCacheKey(url);\n        await indexedDBCache.delete(cacheKey);\n        console.log(`[cachedFetch] Cleared cache for: ${url}`);\n    } else {\n        await indexedDBCache.clear();\n        console.log('[cachedFetch] Cleared all file caches');\n    }\n}\n\n/**\n * \n */\nexport async function clearExpiredFileCache(): Promise<number> {\n    return await indexedDBCache.clearExpired();\n}\n\n/**\n * \n */\nexport async function getFileCacheStats() {\n    return await indexedDBCache.getStats();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/serializer.ts"],"sourcesContent":["import { BookConfig, BookSearchConfig, ViewSettings } from '@/types/book';\n\nexport const serializeConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  config = JSON.parse(JSON.stringify(config));\n  const viewSettings = config.viewSettings as Partial<ViewSettings>;\n  const searchConfig = config.searchConfig as Partial<BookSearchConfig>;\n  config.viewSettings = Object.entries(viewSettings).reduce(\n    (acc: Partial<Record<keyof ViewSettings, unknown>>, [key, value]) => {\n      if (globalViewSettings[key as keyof ViewSettings] !== value) {\n        acc[key as keyof ViewSettings] = value;\n      }\n      return acc;\n    },\n    {} as Partial<Record<keyof ViewSettings, unknown>>,\n  ) as Partial<ViewSettings>;\n  config.searchConfig = Object.entries(searchConfig).reduce(\n    (acc: Partial<Record<keyof BookSearchConfig, unknown>>, [key, value]) => {\n      if (defaultSearchConfig[key as keyof BookSearchConfig] !== value) {\n        acc[key as keyof BookSearchConfig] = value;\n      }\n      return acc;\n    },\n    {} as Partial<BookSearchConfig>,\n  ) as Partial<BookSearchConfig>;\n\n  return JSON.stringify(config);\n};\n\nexport const deserializeConfig = (\n  str: string,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): BookConfig => {\n  const config = JSON.parse(str) as BookConfig;\n  const { viewSettings, searchConfig } = config;\n  config.viewSettings = { ...globalViewSettings, ...viewSettings };\n  config.searchConfig = { ...defaultSearchConfig, ...searchConfig };\n  config.updatedAt ??= Date.now();\n  return config;\n};\n\nexport const compressConfig = (\n  config: BookConfig,\n  globalViewSettings: ViewSettings,\n  defaultSearchConfig: BookSearchConfig,\n): string => {\n  return JSON.parse(serializeConfig(config, globalViewSettings, defaultSearchConfig));\n};\n"],"names":[],"mappings":";;;;;;;;AAEO,MAAM,kBAAkB,CAC7B,QACA,oBACA;IAEA,SAAS,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC;IACnC,MAAM,eAAe,OAAO,YAAY;IACxC,MAAM,eAAe,OAAO,YAAY;IACxC,OAAO,YAAY,GAAG,OAAO,OAAO,CAAC,cAAc,MAAM,CACvD,CAAC,KAAmD,CAAC,KAAK,MAAM;QAC9D,IAAI,kBAAkB,CAAC,IAA0B,KAAK,OAAO;YAC3D,GAAG,CAAC,IAA0B,GAAG;QACnC;QACA,OAAO;IACT,GACA,CAAC;IAEH,OAAO,YAAY,GAAG,OAAO,OAAO,CAAC,cAAc,MAAM,CACvD,CAAC,KAAuD,CAAC,KAAK,MAAM;QAClE,IAAI,mBAAmB,CAAC,IAA8B,KAAK,OAAO;YAChE,GAAG,CAAC,IAA8B,GAAG;QACvC;QACA,OAAO;IACT,GACA,CAAC;IAGH,OAAO,KAAK,SAAS,CAAC;AACxB;AAEO,MAAM,oBAAoB,CAC/B,KACA,oBACA;IAEA,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG;IACvC,OAAO,YAAY,GAAG;QAAE,GAAG,kBAAkB;QAAE,GAAG,YAAY;IAAC;IAC/D,OAAO,YAAY,GAAG;QAAE,GAAG,mBAAmB;QAAE,GAAG,YAAY;IAAC;IAChE,OAAO,SAAS,KAAK,KAAK,GAAG;IAC7B,OAAO;AACT;AAEO,MAAM,iBAAiB,CAC5B,QACA,oBACA;IAEA,OAAO,KAAK,KAAK,CAAC,gBAAgB,QAAQ,oBAAoB;AAChE"}},
    {"offset": {"line": 2097, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/txt.ts"],"sourcesContent":["import { partialMD5 } from './md5';\nimport { getBaseFilename } from './path';\nimport { detectLanguage } from './lang';\n\ninterface Metadata {\n  bookTitle: string;\n  author: string;\n  language: string;\n  identifier: string;\n}\n\ninterface Chapter {\n  title: string;\n  content: string;\n  text: string;\n  isVolume: boolean;\n}\n\ninterface Txt2EpubOptions {\n  file: File;\n  author?: string;\n  language?: string;\n}\n\ninterface ExtractChapterOptions {\n  linesBetweenSegments: number;\n  fallbackParagraphsPerChapter: number;\n}\n\ninterface ConversionResult {\n  file: File;\n  bookTitle: string;\n  chapterCount: number;\n  language: string;\n}\n\nconst zipWriteOptions = {\n  lastAccessDate: new Date(0),\n  lastModDate: new Date(0),\n};\n\nconst escapeXml = (str: string) => {\n  if (!str) return '';\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n};\n\nexport class TxtToEpubConverter {\n  public async convert(options: Txt2EpubOptions): Promise<ConversionResult> {\n    const { file: txtFile, author: providedAuthor, language: providedLanguage } = options;\n\n    const fileContent = await txtFile.arrayBuffer();\n    const detectedEncoding = this.detectEncoding(fileContent) || 'utf-8';\n    console.log(`Detected encoding: ${detectedEncoding}`);\n    const decoder = new TextDecoder(detectedEncoding);\n    const txtContent = decoder.decode(fileContent).trim();\n\n    const bookTitle = this.extractBookTitle(getBaseFilename(txtFile.name));\n    const fileName = `${bookTitle}.epub`;\n\n    const fileHeader = txtContent.slice(0, 1024);\n    const authorMatch =\n      fileHeader.match(/[\\[]?[\\]]?[:\\s]\\s*(.+)\\r?\\n/) ||\n      fileHeader.match(/[\\[]?\\s*(.+)\\s+\\s*[\\]]?\\r?\\n/);\n    let matchedAuthor = authorMatch ? authorMatch[1]!.trim() : providedAuthor || '';\n    try {\n      matchedAuthor = matchedAuthor.replace(/^[\\p{P}\\p{S}]+|[\\p{P}\\p{S}]+$/gu, '');\n    } catch {}\n    const author = matchedAuthor || providedAuthor || '';\n    const language = providedLanguage || detectLanguage(fileHeader);\n    console.log(`Detected language: ${language}`);\n    const identifier = await partialMD5(txtFile);\n    const metadata = { bookTitle, author, language, identifier };\n\n    let chapters: Chapter[] = [];\n    for (let i = 8; i >= 6; i--) {\n      chapters = this.extractChapters(txtContent, metadata, {\n        linesBetweenSegments: i,\n        fallbackParagraphsPerChapter: 100,\n      });\n\n      if (chapters.length === 0) {\n        throw new Error('No chapters detected.');\n      } else if (chapters.length > 1) {\n        break;\n      }\n    }\n\n    const blob = await this.createEpub(chapters, metadata);\n    return {\n      file: new File([blob], fileName),\n      bookTitle,\n      chapterCount: chapters.length,\n      language,\n    };\n  }\n\n  private extractChapters(\n    txtContent: string,\n    metadata: Metadata,\n    option: ExtractChapterOptions,\n  ): Chapter[] {\n    const { language } = metadata;\n    const { linesBetweenSegments, fallbackParagraphsPerChapter } = option;\n    const segmentRegex = new RegExp(`(?:\\\\r?\\\\n){${linesBetweenSegments},}|-{8,}\\r?\\n`);\n    const chapterRegexps: RegExp[] = [];\n    if (language === 'zh') {\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[0-9][0-9]*(?:[])(?:[: \\(\\)0-9]*[^\\n-]{0,24})(?!\\S)`,\n              String.raw`(?:||||||||)(?:[: ][^\\n-]{0,24})?(?!\\S)`,\n              String.raw`chapter[\\s.]*[0-9]+(?:[:. ]+[^\\n-]{0,50})?(?!\\S)`,\n            ].join('|') +\n            ')',\n          'gui',\n        ),\n      );\n      chapterRegexps.push(\n        new RegExp(\n          String.raw`(?:^|\\n)\\s*` +\n            '(' +\n            [\n              String.raw`[][]?[: ][^\\n-]{0,24}(?=\\n|$)`,\n              String.raw`[0-9]+[^\\n]{0,16}(?=\\n|$)`,\n            ].join('|') +\n            ')',\n          'gu',\n        ),\n      );\n    } else {\n      const chapterKeywords = ['Chapter', 'Part', 'Section', 'Book', 'Volume', 'Act'];\n\n      const prefaceKeywords = [\n        'Prologue',\n        'Epilogue',\n        'Introduction',\n        'Foreword',\n        'Preface',\n        'Afterword',\n      ];\n\n      const numberPattern = String.raw`(\\d+|(?:[IVXLCDM]{2,}|V|X|L|C|D|M)\\b)`;\n      const dotNumberPattern = String.raw`\\.\\d{1,4}`;\n      const titlePattern = String.raw`[^\\n]{0,50}`;\n\n      const normalChapterPattern = chapterKeywords\n        .map(\n          (k) =>\n            String.raw`${k}\\s*(?:${numberPattern}|${dotNumberPattern})(?:[:.\\-]?\\s*${titlePattern})?`,\n        )\n        .join('|');\n\n      const prefacePattern = prefaceKeywords\n        .map((k) => String.raw`${k}(?:[:.\\-]?\\s*${titlePattern})?`)\n        .join('|');\n\n      const combinedPattern = String.raw`(?:^|\\n|\\s)(?:${normalChapterPattern}|${prefacePattern})(?=\\s|$)`;\n\n      chapterRegexps.push(new RegExp(combinedPattern, 'gi'));\n    }\n\n    const formatSegment = (segment: string): string => {\n      segment = escapeXml(segment);\n      return segment\n        .replace(/-{8,}|_{8,}/g, '\\n')\n        .split(/\\n+/)\n        .map((line) => line.trim())\n        .filter((line) => line)\n        .join('</p><p>');\n    };\n\n    const joinAroundUndefined = (arr: (string | undefined)[]) =>\n      arr.reduce<string[]>((acc, curr, i, src) => {\n        if (\n          curr === undefined &&\n          i > 0 &&\n          i < src.length - 1 &&\n          src[i - 1] !== undefined &&\n          src[i + 1] !== undefined\n        ) {\n          acc[acc.length - 1] += src[i + 1]!;\n          return acc;\n        }\n        if (curr !== undefined && (i === 0 || src[i - 1] !== undefined)) {\n          acc.push(curr);\n        }\n        return acc;\n      }, []);\n\n    const isGoodMatches = (matches: string[], maxLength: number = 100000): boolean => {\n      const meaningfulParts = matches.filter((part) => part && part.trim().length > 0);\n      if (meaningfulParts.length <= 1) return false;\n\n      const hasLongParts = meaningfulParts.some((part) => part.length > maxLength);\n      return !hasLongParts;\n    };\n\n    const chapters: Chapter[] = [];\n    const segments = txtContent.split(segmentRegex);\n    for (const segment of segments) {\n      const trimmedSegment = segment.replace(/<!--.*?-->/g, '').trim();\n      if (!trimmedSegment) continue;\n\n      const segmentChapters: Chapter[] = [];\n      let matches: string[] = [];\n      for (const chapterRegex of chapterRegexps) {\n        const tryMatches = trimmedSegment.split(chapterRegex);\n        if (isGoodMatches(tryMatches)) {\n          matches = joinAroundUndefined(tryMatches);\n          break;\n        }\n      }\n\n      if (matches.length === 0 && fallbackParagraphsPerChapter > 0) {\n        const paragraphs = trimmedSegment.split(/\\n+/);\n        const totalParagraphs = paragraphs.length;\n        for (let i = 0; i < totalParagraphs; i += fallbackParagraphsPerChapter) {\n          const chunks = paragraphs.slice(i, i + fallbackParagraphsPerChapter);\n          const formattedSegment = formatSegment(chunks.join('\\n'));\n          const title = `${chapters.length + 1}`;\n          const content = `<h2>${title}</h2><p>${formattedSegment}</p>`;\n          chapters.push({ title, content, text: chunks.join('\\n'), isVolume: false });\n        }\n        continue;\n      }\n\n      for (let j = 1; j < matches.length; j += 2) {\n        const title = matches[j]?.trim() || '';\n        const content = matches[j + 1]?.trim() || '';\n\n        let isVolume = false;\n        if (language === 'zh') {\n          isVolume = /[0-9]+(|||)/.test(title);\n        } else {\n          isVolume = /\\b(Part|Volume|Book)\\b/i.test(title);\n        }\n\n        const headTitle = isVolume ? `<h1>${title}</h1>` : `<h2>${title}</h2>`;\n        const formattedSegment = formatSegment(content);\n        segmentChapters.push({\n          title: escapeXml(title),\n          content: `${headTitle}<p>${formattedSegment}</p>`,\n          text: content,\n          isVolume: isVolume,\n        });\n      }\n\n      if (matches[0] && matches[0].trim()) {\n        const initialContent = matches[0].trim();\n        const firstLine = initialContent.split('\\n')[0]!.trim();\n        const segmentTitle =\n          (firstLine.length > 16 ? initialContent.split(/[\\n\\s\\p{P}]/u)[0]!.trim() : firstLine) ||\n          initialContent.slice(0, 16);\n        const formattedSegment = formatSegment(initialContent);\n        segmentChapters.unshift({\n          title: escapeXml(segmentTitle),\n          content: `<h3></h3><p>${formattedSegment}</p>`,\n          text: initialContent,\n          isVolume: false,\n        });\n      }\n      chapters.push(...segmentChapters);\n    }\n\n    return chapters;\n  }\n\n  private async createEpub(chapters: Chapter[], metadata: Metadata): Promise<Blob> {\n    const { BlobWriter, TextReader, ZipWriter } = await import('@zip.js/zip.js');\n    const { bookTitle, author, language, identifier } = metadata;\n\n    const zipWriter = new ZipWriter(new BlobWriter('application/epub+zip'), {\n      extendedTimestamp: false,\n    });\n    await zipWriter.add('mimetype', new TextReader('application/epub+zip'), zipWriteOptions);\n\n    // Add META-INF/container.xml\n    const containerXml = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <container xmlns=\"urn:oasis:names:tc:opendocument:xmlns:container\" version=\"1.0\">\n      <rootfiles>\n        <rootfile full-path=\"content.opf\" media-type=\"application/oebps-package+xml\"/>\n      </rootfiles>\n    </container>`.trim();\n\n    await zipWriter.add('META-INF/container.xml', new TextReader(containerXml), zipWriteOptions);\n\n    // Create navigation points for TOC\n    let isNested = false;\n    let navPoints = ``;\n    for (let i = 0; i < chapters.length; i++) {\n      const id = `chapter${i + 1}`;\n      const playOrder = i + 1;\n      if (chapters[i]!.isVolume && isNested) {\n        navPoints += `</navPoint>\\n`;\n        isNested = !isNested;\n      }\n      navPoints +=\n        `<navPoint id=\"navPoint-${id}\" playOrder=\"${playOrder}\">\\n` +\n        `<navLabel><text>${chapters[i]!.title}</text></navLabel>\\n` +\n        `<content src=\"./OEBPS/${id}.xhtml\" />\\n`;\n      if (chapters[i]!.isVolume && !isNested) {\n        isNested = !isNested;\n      } else {\n        navPoints += `</navPoint>\\n`;\n      }\n    }\n    if (isNested) {\n      navPoints += `</navPoint>`;\n    }\n\n    // Add NCX file (table of contents)\n    const tocNcx = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n      <head>\n        <meta name=\"dtb:uid\" content=\"book-id\" />\n        <meta name=\"dtb:depth\" content=\"1\" />\n        <meta name=\"dtb:totalPageCount\" content=\"0\" />\n        <meta name=\"dtb:maxPageNumber\" content=\"0\" />\n      </head>\n      <docTitle>\n        <text>${escapeXml(bookTitle)}</text>\n      </docTitle>\n      <docAuthor>\n        <text>${escapeXml(author)}</text>\n      </docAuthor>\n      <navMap>\n        ${navPoints}\n      </navMap>\n    </ncx>`.trim();\n\n    await zipWriter.add('toc.ncx', new TextReader(tocNcx), zipWriteOptions);\n\n    // Create manifest and spine items\n    const manifest = chapters\n      .map(\n        (_, index) => `\n      <item id=\"chap${index + 1}\" href=\"OEBPS/chapter${index + 1}.xhtml\" media-type=\"application/xhtml+xml\"/>\n    `,\n      )\n      .join('\\n')\n      .trim();\n\n    const spine = chapters\n      .map(\n        (_, index) => `\n      <itemref idref=\"chap${index + 1}\"/>`,\n      )\n      .join('\\n')\n      .trim();\n\n    // Add CSS stylesheet\n    const css = `\n      body { line-height: 1.6; font-size: 1em; font-family: 'Arial', sans-serif; text-align: justify; }\n      p { text-indent: 2em; margin: 0; }\n    `;\n\n    await zipWriter.add('style.css', new TextReader(css), zipWriteOptions);\n\n    // Add chapter files\n    for (let i = 0; i < chapters.length; i++) {\n      const chapter = chapters[i]!;\n      const lang = detectLanguage(chapter.text);\n      const chapterContent = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n        <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"${lang}\" xml:lang=\"${lang}\">\n          <head>\n            <title>${chapter.title}</title>\n            <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\"/>\n          </head>\n          <body>${chapter.content}</body>\n        </html>`.trim();\n\n      await zipWriter.add(\n        `OEBPS/chapter${i + 1}.xhtml`,\n        new TextReader(chapterContent),\n        zipWriteOptions,\n      );\n    }\n\n    const tocManifest = `<item id=\"ncx\" href=\"toc.ncx\" media-type=\"application/x-dtbncx+xml\"/>`;\n    const styleManifest = `<item id=\"css\" href=\"style.css\" media-type=\"text/css\"/>`;\n\n    // Add content.opf file\n    const contentOpf = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <package xmlns=\"http://www.idpf.org/2007/opf\" unique-identifier=\"book-id\" version=\"2.0\">\n        <metadata xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n          <dc:title>${escapeXml(bookTitle)}</dc:title>\n          <dc:language>${language}</dc:language>\n          <dc:creator>${escapeXml(author)}</dc:creator>\n          <dc:identifier id=\"book-id\">${identifier}</dc:identifier>\n        </metadata>\n        <manifest>\n          ${manifest}\n          ${tocManifest}\n          ${styleManifest}\n        </manifest>\n        <spine toc=\"ncx\">\n          ${spine}\n        </spine>\n      </package>`.trim();\n\n    await zipWriter.add('content.opf', new TextReader(contentOpf), zipWriteOptions);\n\n    return await zipWriter.close();\n  }\n\n  private detectEncoding(buffer: ArrayBuffer): string | undefined {\n    try {\n      new TextDecoder('utf-8', { fatal: true }).decode(buffer);\n      return 'utf-8';\n    } catch {\n      const uint8Array = new Uint8Array(buffer);\n      // Try tolerant UTF-8 detection - check if most of it is valid UTF-8\n      let validBytes = 0;\n      let checkedBytes = 0;\n      const sampleSize = Math.min(uint8Array.length, 10000);\n\n      for (let i = 0; i < sampleSize; i++) {\n        try {\n          new TextDecoder('utf-8', { fatal: true }).decode(uint8Array.slice(i, i + 100));\n          validBytes += 100;\n          checkedBytes += 100;\n          i += 99;\n        } catch {\n          checkedBytes++;\n        }\n      }\n\n      const validPercentage = (validBytes / checkedBytes) * 100;\n      console.log(`UTF-8 validity: ${validPercentage.toFixed(2)}%`);\n\n      // If more than 80% is valid UTF-8, consider it UTF-8 with some corruption\n      if (validPercentage > 80) {\n        console.log('Treating as UTF-8 despite some invalid sequences');\n        return 'utf-8';\n      }\n      // If UTF-8 decoding fails, try to detect other encodings\n    }\n\n    const headerBytes = new Uint8Array(buffer.slice(0, 4));\n\n    if (headerBytes[0] === 0xff && headerBytes[1] === 0xfe) {\n      return 'utf-16le';\n    }\n\n    if (headerBytes[0] === 0xfe && headerBytes[1] === 0xff) {\n      return 'utf-16be';\n    }\n\n    if (headerBytes[0] === 0xef && headerBytes[1] === 0xbb && headerBytes[2] === 0xbf) {\n      return 'utf-8';\n    }\n\n    // Analyze a sample of the content to guess between common East Asian encodings\n    // If the content has a high ratio of bytes in the 0x80-0xFF range, it's likely GBK/GB18030\n    const sample = new Uint8Array(buffer.slice(0, Math.min(1024, buffer.byteLength)));\n    let highByteCount = 0;\n\n    for (let i = 0; i < sample.length; i++) {\n      if (sample[i]! >= 0x80) {\n        highByteCount++;\n      }\n    }\n\n    const highByteRatio = highByteCount / sample.length;\n    if (highByteRatio > 0.3) {\n      return 'gbk';\n    }\n\n    if (highByteRatio > 0.1) {\n      let sjisPattern = false;\n      for (let i = 0; i < sample.length - 1; i++) {\n        const b1 = sample[i]!;\n        const b2 = sample[i + 1]!;\n        if (\n          ((b1 >= 0x81 && b1 <= 0x9f) || (b1 >= 0xe0 && b1 <= 0xfc)) &&\n          ((b2 >= 0x40 && b2 <= 0x7e) || (b2 >= 0x80 && b2 <= 0xfc))\n        ) {\n          sjisPattern = true;\n          break;\n        }\n      }\n\n      if (sjisPattern) {\n        return 'shift-jis';\n      }\n\n      return 'gb18030';\n    }\n\n    return 'utf-8';\n  }\n\n  private extractBookTitle(filename: string): string {\n    const match = filename.match(/([^]+)/);\n    return match ? match[1]! : filename.split('.')[0]!;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2481, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/errors.ts"],"sourcesContent":["export const BOOK_FILE_NOT_FOUND_ERROR = 'Book file not found';\n"],"names":[],"mappings":";;;;AAAO,MAAM,4BAA4B"}},
    {"offset": {"line": 2490, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/font.ts"],"sourcesContent":["import { FontStyle } from '@/styles/fonts';\nimport { getUserLang } from './misc';\n\nfunction parseUnicodeString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i += 2) {\n    const charCode = dataView.getUint16(offset + i, false);\n    if (charCode !== 0) {\n      chars.push(String.fromCharCode(charCode));\n    }\n  }\n  return chars.join('');\n}\n\nfunction parseMacintoshString(dataView: DataView, offset: number, length: number): string {\n  const chars: string[] = [];\n  for (let i = 0; i < length; i++) {\n    const charCode = dataView.getUint8(offset + i);\n    chars.push(String.fromCharCode(charCode));\n  }\n  return chars.join('');\n}\n\nconst NO_STYLE_LANGUAGE_IDS = new Set([0x0404, 0x0804, 0x0c04, 0x1004, 19, 33]);\n\nfunction getLanguagePriority(platformID: number, languageID: number, userLanguage: string): number {\n  let priority = 0;\n\n  // Base priority by platform (Unicode/Microsoft preferred)\n  if (platformID === 0)\n    priority += 100; // Unicode\n  else if (platformID === 3)\n    priority += 90; // Microsoft\n  else if (platformID === 1) priority += 50; // Macintosh\n\n  // Language-specific priorities\n  const userLang = userLanguage.toLowerCase();\n\n  if (platformID === 0 || platformID === 3) {\n    if (userLang.startsWith('zh')) {\n      if (languageID === 0x0804)\n        priority += 50; // Simplified Chinese\n      else if (languageID === 0x0404)\n        priority += 45; // Traditional Chinese\n      else if (languageID === 0x0c04)\n        priority += 40; // Traditional Chinese\n      else if (languageID === 0x1004) priority += 35; // Simplified Chinese\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 0x0411) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 0x0412) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0x0409)\n        priority += 50; // English (US)\n      else if (languageID === 0x0809) priority += 45; // English (UK)\n    }\n\n    // Fallback: English\n    if (languageID === 0x0409) priority += 10; // English fallback\n  } else if (platformID === 1) {\n    // Macintosh platform language codes\n    if (userLang.startsWith('zh')) {\n      if (languageID === 33)\n        priority += 50; // Chinese (Simplified)\n      else if (languageID === 19) priority += 45; // Chinese (Traditional)\n    } else if (userLang.startsWith('ja')) {\n      if (languageID === 11) priority += 50; // Japanese\n    } else if (userLang.startsWith('ko')) {\n      if (languageID === 23) priority += 50; // Korean\n    } else if (userLang.startsWith('en')) {\n      if (languageID === 0) priority += 50; // English\n    }\n\n    // Fallback: English\n    if (languageID === 0) priority += 10; // English fallback\n  }\n\n  return priority;\n}\n\nfunction parseOS2Weight(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table usWeightClass is at offset 4\n  return dataView.getUint16(os2TableOffset + 4, false);\n}\n\nfunction parseOS2Selection(dataView: DataView, os2TableOffset: number): number {\n  // OS/2 table fsSelection is at offset 62\n  return dataView.getUint16(os2TableOffset + 62, false);\n}\n\ninterface VariableFontAxis {\n  tag: string;\n  minValue: number;\n  defaultValue: number;\n  maxValue: number;\n  name?: string;\n}\n\nfunction parseVariableFontAxes(dataView: DataView, fvarTableOffset: number): VariableFontAxis[] {\n  try {\n    // fvar table structure:\n    // version (4 bytes) + axisCount (2 bytes) + axisSize (2 bytes) + instanceCount (2 bytes) + instanceSize (2 bytes)\n    const axisCount = dataView.getUint16(fvarTableOffset + 4, false);\n    const axisSize = dataView.getUint16(fvarTableOffset + 6, false);\n\n    const axes: VariableFontAxis[] = [];\n\n    // Each axis record starts at offset 16 from table start\n    let axisOffset = fvarTableOffset + 16;\n\n    for (let i = 0; i < axisCount; i++) {\n      // Axis record structure:\n      // axisTag (4 bytes) + minValue (4 bytes) + defaultValue (4 bytes) + maxValue (4 bytes) + flags (2 bytes) + axisNameID (2 bytes)\n\n      const tag = String.fromCharCode(\n        dataView.getUint8(axisOffset),\n        dataView.getUint8(axisOffset + 1),\n        dataView.getUint8(axisOffset + 2),\n        dataView.getUint8(axisOffset + 3),\n      );\n\n      // Fixed-point values (16.16 format)\n      const minValue = dataView.getInt32(axisOffset + 4, false) / 65536;\n      const defaultValue = dataView.getInt32(axisOffset + 8, false) / 65536;\n      const maxValue = dataView.getInt32(axisOffset + 12, false) / 65536;\n\n      axes.push({\n        tag,\n        minValue,\n        defaultValue,\n        maxValue,\n      });\n\n      axisOffset += axisSize;\n    }\n\n    return axes;\n  } catch (error) {\n    console.warn('Failed to parse fvar table:', error);\n    return [];\n  }\n}\n\nfunction weightClassToCSSWeight(weightClass: number): number {\n  // Map OpenType weight class to CSS weight\n  if (weightClass >= 1 && weightClass <= 100) return 100;\n  if (weightClass >= 101 && weightClass <= 200) return 200;\n  if (weightClass >= 201 && weightClass <= 300) return 300;\n  if (weightClass >= 301 && weightClass <= 400) return 400;\n  if (weightClass >= 401 && weightClass <= 500) return 500;\n  if (weightClass >= 501 && weightClass <= 600) return 600;\n  if (weightClass >= 601 && weightClass <= 700) return 700;\n  if (weightClass >= 701 && weightClass <= 800) return 800;\n  if (weightClass >= 801 && weightClass <= 900) return 900;\n  return 400; // Default to normal weight\n}\n\nfunction inferWeightFromStyleName(styleName: string): number {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check for specific weight keywords\n  if (lowerStyle.includes('thin') || lowerStyle.includes('hairline')) return 100;\n  if (lowerStyle.includes('extralight') || lowerStyle.includes('ultralight')) return 200;\n  if (\n    lowerStyle.includes('light') &&\n    !lowerStyle.includes('extralight') &&\n    !lowerStyle.includes('ultralight')\n  )\n    return 300;\n  if (lowerStyle.includes('medium')) return 500;\n  if (lowerStyle.includes('semibold') || lowerStyle.includes('demibold')) return 600;\n  if (lowerStyle.includes('extrabold') || lowerStyle.includes('ultrabold')) return 800;\n  if (lowerStyle.includes('black') || lowerStyle.includes('heavy')) return 900;\n  if (\n    lowerStyle.includes('bold') &&\n    !lowerStyle.includes('semibold') &&\n    !lowerStyle.includes('extrabold') &&\n    !lowerStyle.includes('ultrabold')\n  )\n    return 700;\n\n  return 400; // Default to normal weight\n}\n\nfunction inferStyleFromName(\n  styleName: string,\n  fsSelection: number,\n): 'normal' | 'italic' | 'oblique' {\n  const lowerStyle = styleName.toLowerCase();\n\n  // Check fsSelection flags first (bit 0 = italic, bit 9 = oblique)\n  if (fsSelection & 0x200) return 'oblique'; // Bit 9\n  if (fsSelection & 0x1) return 'italic'; // Bit 0\n\n  // Fallback to style name analysis\n  if (lowerStyle.includes('oblique')) return 'oblique';\n  if (lowerStyle.includes('italic') || lowerStyle.includes('slant')) return 'italic';\n\n  return 'normal';\n}\n\ntype FontNameType = {\n  name: string;\n  platformID: number;\n  languageID: number;\n  priority: number;\n};\n\nexport const parseFontInfo = (fontData: ArrayBuffer, filename: string) => {\n  const fallbackName = filename.replace(/\\.[^/.]+$/, '');\n  try {\n    const dataView = new DataView(fontData);\n    const signature = dataView.getUint32(0, false);\n    if (signature !== 0x00010000 && signature !== 0x74727565 && signature !== 0x4f54544f) {\n      throw new Error('Unsupported font format');\n    }\n    const numTables = dataView.getUint16(4, false);\n    let nameTableOffset = 0;\n    let os2TableOffset = 0;\n    let fvarTableOffset = 0;\n    for (let i = 0; i < numTables; i++) {\n      const tableOffset = 12 + i * 16;\n      const tag = String.fromCharCode(\n        dataView.getUint8(tableOffset),\n        dataView.getUint8(tableOffset + 1),\n        dataView.getUint8(tableOffset + 2),\n        dataView.getUint8(tableOffset + 3),\n      );\n\n      if (tag === 'name') {\n        nameTableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'OS/2') {\n        os2TableOffset = dataView.getUint32(tableOffset + 8, false);\n      } else if (tag === 'fvar') {\n        fvarTableOffset = dataView.getUint32(tableOffset + 8, false);\n      }\n    }\n\n    if (nameTableOffset === 0) {\n      throw new Error('Name table not found');\n    }\n\n    const count = dataView.getUint16(nameTableOffset + 2, false);\n    const stringOffset = dataView.getUint16(nameTableOffset + 4, false);\n\n    const userLanguage = getUserLang();\n    const fontFamilyNames: Array<FontNameType> = [];\n    const fontStyleNames: Array<FontNameType> = [];\n    const preferredFamilyNames: Array<FontNameType> = [];\n    const preferredStyleNames: Array<FontNameType> = [];\n    for (let i = 0; i < count; i++) {\n      const recordOffset = nameTableOffset + 6 + i * 12;\n      const platformID = dataView.getUint16(recordOffset, false);\n      const languageID = dataView.getUint16(recordOffset + 4, false);\n      const nameID = dataView.getUint16(recordOffset + 6, false);\n      const nameLength = dataView.getUint16(recordOffset + 8, false);\n      const nameOffsetInTable = dataView.getUint16(recordOffset + 10, false);\n\n      // nameID 1 = Font Family name, nameID 2 = Font Subfamily name (style)\n      // nameID 16 = Typographic Family name, nameID 17 = Typographic Subfamily name\n      if (nameID === 1 || nameID === 2 || nameID === 16 || nameID === 17) {\n        const stringStart = nameTableOffset + stringOffset + nameOffsetInTable;\n        let fontName = '';\n\n        if (platformID === 0 || platformID === 3) {\n          // Unicode/Microsoft platform\n          fontName = parseUnicodeString(dataView, stringStart, nameLength);\n        } else if (platformID === 1) {\n          // Macintosh platform\n          fontName = parseMacintoshString(dataView, stringStart, nameLength);\n        }\n\n        if (fontName && fontName.trim()) {\n          const priority = getLanguagePriority(platformID, languageID, userLanguage);\n          const nameEntry = {\n            name: fontName.trim(),\n            platformID,\n            languageID,\n            priority,\n          };\n\n          if (nameID === 1) {\n            fontFamilyNames.push(nameEntry);\n          } else if (nameID === 2) {\n            fontStyleNames.push(nameEntry);\n          } else if (nameID === 16) {\n            preferredFamilyNames.push(nameEntry);\n          } else if (nameID === 17) {\n            preferredStyleNames.push(nameEntry);\n          }\n        }\n      }\n    }\n    if (fontFamilyNames.length === 0) {\n      throw new Error('Font family name not found');\n    }\n    fontFamilyNames.sort((a, b) => b.priority - a.priority);\n    fontStyleNames.sort((a, b) => b.priority - a.priority);\n    preferredFamilyNames.sort((a, b) => b.priority - a.priority);\n    preferredStyleNames.sort((a, b) => b.priority - a.priority);\n\n    // Prefer typographic names if available\n    const familyName = (preferredFamilyNames[0] || fontFamilyNames[0])!.name;\n    const fontStyleName = preferredStyleNames[0] || fontStyleNames[0];\n    const styleName = fontStyleName?.name || '';\n\n    // Parse weight and style information\n    let fontWeight = 400;\n    let fontStyle: FontStyle = 'normal';\n    let fsSelection = 0;\n\n    if (os2TableOffset > 0) {\n      try {\n        const weightClass = parseOS2Weight(dataView, os2TableOffset);\n        fontWeight = weightClassToCSSWeight(weightClass);\n        fsSelection = parseOS2Selection(dataView, os2TableOffset);\n      } catch {\n        console.warn('Failed to parse OS/2 table, falling back to style name analysis');\n      }\n    }\n\n    let isVariable = false;\n    if (fvarTableOffset > 0) {\n      const axes = parseVariableFontAxes(dataView, fvarTableOffset);\n      if (axes && axes.length > 0) {\n        isVariable = true;\n      }\n    }\n\n    // If OS/2 table weight is default (400) or unavailable, try to infer from style name\n    if (fontWeight === 400 && styleName) {\n      const inferredWeight = inferWeightFromStyleName(styleName);\n      if (inferredWeight !== 400) {\n        fontWeight = inferredWeight;\n      }\n    }\n\n    fontStyle = inferStyleFromName(styleName, fsSelection);\n\n    return {\n      name:\n        fontStyleName && !NO_STYLE_LANGUAGE_IDS.has(fontStyleName.languageID)\n          ? `${familyName} ${styleName}`\n          : familyName,\n      family: familyName,\n      weight: fontWeight,\n      style: fontStyle,\n      variable: isVariable,\n    };\n  } catch (error) {\n    console.warn(`Failed to parse font: ${error}`);\n    return {\n      name: fallbackName,\n      family: fallbackName,\n      weight: 400,\n      style: 'normal' as FontStyle,\n      variable: false,\n    };\n  }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2771, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/utils/svg.ts"],"sourcesContent":["function parseSvgLength(value: string) {\n  const n = parseFloat(value);\n  if (!isNaN(n)) return n;\n\n  return undefined;\n}\n\nasync function getSvgSize(\n  svgBlob: Blob,\n  defaultWidth: number = 700,\n  defaultHeight: number = 1050,\n): Promise<{ width: number; height: number }> {\n  const text = await svgBlob.text();\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(text, 'image/svg+xml');\n  const svg = doc.documentElement;\n\n  const widthAttr = svg.getAttribute('width');\n  const heightAttr = svg.getAttribute('height');\n\n  if (widthAttr && heightAttr) {\n    return {\n      width: parseSvgLength(widthAttr) || defaultWidth,\n      height: parseSvgLength(heightAttr) || defaultHeight,\n    };\n  }\n\n  const viewBox = svg.getAttribute('viewBox');\n  if (viewBox) {\n    const parts = viewBox.split(/\\s+/).map(Number);\n    if (parts.length === 4 && !parts.some(isNaN)) {\n      const [, , vbWidth, vbHeight] = parts;\n      return { width: vbWidth || defaultWidth, height: vbHeight || defaultHeight };\n    }\n  }\n\n  return { width: defaultWidth, height: defaultHeight };\n}\n\nexport async function svg2png(svgBlob: Blob, quality: number = 0.9): Promise<Blob> {\n  const svgText = await svgBlob.text();\n\n  const svgUrl = URL.createObjectURL(new Blob([svgText], { type: 'image/svg+xml' }));\n\n  const img = new Image();\n  img.crossOrigin = 'anonymous';\n\n  await new Promise<void>((resolve, reject) => {\n    img.onload = () => resolve();\n    img.onerror = () => reject(new Error('Failed to load SVG'));\n    img.src = svgUrl;\n  });\n\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n  await new Promise((resolve) => requestAnimationFrame(resolve));\n\n  const canvas = document.createElement('canvas');\n  const { width, height } = await getSvgSize(svgBlob);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d')!;\n  ctx.drawImage(img, 0, 0);\n\n  URL.revokeObjectURL(svgUrl);\n\n  return new Promise((resolve) => {\n    canvas.toBlob((blob) => resolve(blob!), 'image/png', quality);\n  });\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,eAAe,KAAa;IACnC,MAAM,IAAI,WAAW;IACrB,IAAI,CAAC,MAAM,IAAI,OAAO;IAEtB,OAAO;AACT;AAEA,eAAe,WACb,OAAa,EACb,eAAuB,GAAG,EAC1B,gBAAwB,IAAI;IAE5B,MAAM,OAAO,MAAM,QAAQ,IAAI;IAC/B,MAAM,SAAS,IAAI;IACnB,MAAM,MAAM,OAAO,eAAe,CAAC,MAAM;IACzC,MAAM,MAAM,IAAI,eAAe;IAE/B,MAAM,YAAY,IAAI,YAAY,CAAC;IACnC,MAAM,aAAa,IAAI,YAAY,CAAC;IAEpC,IAAI,aAAa,YAAY;QAC3B,OAAO;YACL,OAAO,eAAe,cAAc;YACpC,QAAQ,eAAe,eAAe;QACxC;IACF;IAEA,MAAM,UAAU,IAAI,YAAY,CAAC;IACjC,IAAI,SAAS;QACX,MAAM,QAAQ,QAAQ,KAAK,CAAC,OAAO,GAAG,CAAC;QACvC,IAAI,MAAM,MAAM,KAAK,KAAK,CAAC,MAAM,IAAI,CAAC,QAAQ;YAC5C,MAAM,KAAK,SAAS,SAAS,GAAG;YAChC,OAAO;gBAAE,OAAO,WAAW;gBAAc,QAAQ,YAAY;YAAc;QAC7E;IACF;IAEA,OAAO;QAAE,OAAO;QAAc,QAAQ;IAAc;AACtD;AAEO,eAAe,QAAQ,OAAa,EAAE,UAAkB,GAAG;IAChE,MAAM,UAAU,MAAM,QAAQ,IAAI;IAElC,MAAM,SAAS,IAAI,eAAe,CAAC,IAAI,KAAK;QAAC;KAAQ,EAAE;QAAE,MAAM;IAAgB;IAE/E,MAAM,MAAM,IAAI;IAChB,IAAI,WAAW,GAAG;IAElB,MAAM,IAAI,QAAc,CAAC,SAAS;QAChC,IAAI,MAAM,GAAG,IAAM;QACnB,IAAI,OAAO,GAAG,IAAM,OAAO,IAAI,MAAM;QACrC,IAAI,GAAG,GAAG;IACZ;IAEA,MAAM,IAAI,QAAQ,CAAC,UAAY,sBAAsB;IACrD,MAAM,IAAI,QAAQ,CAAC,UAAY,sBAAsB;IAErD,MAAM,SAAS,SAAS,aAAa,CAAC;IACtC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,WAAW;IAC3C,OAAO,KAAK,GAAG;IACf,OAAO,MAAM,GAAG;IAEhB,MAAM,MAAM,OAAO,UAAU,CAAC;IAC9B,IAAI,SAAS,CAAC,KAAK,GAAG;IAEtB,IAAI,eAAe,CAAC;IAEpB,OAAO,IAAI,QAAQ,CAAC;QAClB,OAAO,MAAM,CAAC,CAAC,OAAS,QAAQ,OAAQ,aAAa;IACvD;AACF"}},
    {"offset": {"line": 2842, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/appService.ts"],"sourcesContent":["import { v4 as uuidv4 } from 'uuid';\nimport { SystemSettings } from '@/types/settings';\nimport {\n  AppPlatform,\n  AppService,\n  DistChannel,\n  FileItem,\n  OsPlatform,\n  ResolvedPath,\n  SelectDirectoryMode,\n} from '@/types/system';\nimport { FileSystem, BaseDir, DeleteAction } from '@/types/system';\nimport {\n  Book,\n  BookConfig,\n  BookContent,\n  BookFormat,\n  FIXED_LAYOUT_FORMATS,\n  ViewSettings,\n} from '@/types/book';\nimport {\n  getDir,\n  getLocalBookFilename,\n  getCoverFilename,\n  getConfigFilename,\n  getLibraryFilename,\n  INIT_BOOK_CONFIG,\n  formatTitle,\n  formatAuthors,\n  getPrimaryLanguage,\n  getLibraryBackupFilename,\n} from '@/utils/book';\nimport { md5, partialMD5, md5Fingerprint } from '@/utils/md5';\nimport { getBaseFilename, getFilename } from '@/utils/path';\nimport { BookDoc, DocumentLoader, EXTS } from '@/libs/document';\nimport {\n  DEFAULT_BOOK_LAYOUT,\n  DEFAULT_BOOK_STYLE,\n  DEFAULT_BOOK_FONT,\n  DEFAULT_BOOK_LANGUAGE,\n  DEFAULT_VIEW_CONFIG,\n  DEFAULT_READSETTINGS,\n  SYSTEM_SETTINGS_VERSION,\n  DEFAULT_BOOK_SEARCH_CONFIG,\n  DEFAULT_TTS_CONFIG,\n  DEFAULT_MOBILE_VIEW_SETTINGS,\n  DEFAULT_SYSTEM_SETTINGS,\n  DEFAULT_CJK_VIEW_SETTINGS,\n  DEFAULT_MOBILE_READSETTINGS,\n  DEFAULT_SCREEN_CONFIG,\n  DEFAULT_TRANSLATOR_CONFIG,\n  DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS,\n  SETTINGS_FILENAME,\n  DEFAULT_MOBILE_SYSTEM_SETTINGS,\n  DEFAULT_ANNOTATOR_CONFIG,\n  DEFAULT_EINK_VIEW_SETTINGS,\n} from './constants';\nimport { cachedFetchAsUrl } from '@/utils/cachedFetch';\nimport { fetch as tauriFetch } from '@tauri-apps/plugin-http';\nimport {\n  getOSPlatform,\n  getTargetLang,\n  isCJKEnv,\n  isContentURI,\n  isValidURL,\n  makeSafeFilename,\n} from '@/utils/misc';\nimport { deserializeConfig, serializeConfig } from '@/utils/serializer';\nimport { ClosableFile } from '@/utils/file';\nimport { TxtToEpubConverter } from '@/utils/txt';\nimport { BOOK_FILE_NOT_FOUND_ERROR } from './errors';\nimport { CustomTextureInfo } from '@/styles/textures';\nimport { CustomFont, CustomFontInfo } from '@/styles/fonts';\nimport { parseFontInfo } from '@/utils/font';\nimport { svg2png } from '@/utils/svg';\n\nexport abstract class BaseAppService implements AppService {\n  osPlatform: OsPlatform = getOSPlatform();\n  appPlatform: AppPlatform = 'tauri';\n  localBooksDir = '';\n  isMobile = false;\n  isMacOSApp = false;\n  isLinuxApp = false;\n  isAppDataSandbox = false;\n  isAndroidApp = false;\n  isIOSApp = false;\n  isMobileApp = false;\n  isPortableApp = false;\n  isDesktopApp = false;\n  isEink = false;\n  hasTrafficLight = false;\n  hasWindow = false;\n  hasWindowBar = false;\n  hasContextMenu = false;\n  hasRoundedWindow = false;\n  hasSafeAreaInset = false;\n  hasHaptics = false;\n  hasUpdater = false;\n  hasOrientationLock = false;\n  hasScreenBrightness = false;\n  hasIAP = false;\n  canCustomizeRootDir = false;\n  canReadExternalDir = false;\n  distChannel = 'readest' as DistChannel;\n\n  protected CURRENT_MIGRATION_VERSION = 20260121;\n\n  protected abstract fs: FileSystem;\n  protected abstract resolvePath(fp: string, base: BaseDir): ResolvedPath;\n\n  abstract init(): Promise<void>;\n  abstract setCustomRootDir(customRootDir: string): Promise<void>;\n  abstract selectDirectory(mode: SelectDirectoryMode): Promise<string>;\n  abstract selectFiles(name: string, extensions: string[]): Promise<string[]>;\n  abstract saveFile(\n    filename: string,\n    content: string | ArrayBuffer,\n    filepath: string,\n    mimeType?: string,\n  ): Promise<boolean>;\n\n  protected async runMigrations(lastMigrationVersion: number): Promise<void> {\n    if (lastMigrationVersion < 20251124) {\n      try {\n        await this.migrate20251124();\n      } catch (error) {\n        console.error('Error migrating to version 20251124:', error);\n      }\n    }\n\n    if (lastMigrationVersion < 20260121) {\n      try {\n        await this.migrate20260121();\n      } catch (error) {\n        console.error('Error migrating to version 20260121:', error);\n      }\n    }\n  }\n\n  async prepareBooksDir() {\n    this.localBooksDir = await this.fs.getPrefix('Books');\n    // Initialize configuration files in .readest directory\n    await this.ensureConfigFilesExist();\n  }\n\n  /**\n   * Ensure settings.json and library.json exist in .readest directory\n   * If they don't exist, create them with default values\n   */\n  private async ensureConfigFilesExist(): Promise<void> {\n    try {\n      // Check and create settings.json if needed\n      const settingsExists = await this.fs.exists(SETTINGS_FILENAME, 'Settings');\n      if (!settingsExists) {\n        console.log('[Init] settings.json not found, creating with defaults...');\n        const defaultSettings = {\n          ...DEFAULT_SYSTEM_SETTINGS,\n          ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n          version: SYSTEM_SETTINGS_VERSION,\n          localBooksDir: await this.fs.getPrefix('Books'),\n          globalReadSettings: {\n            ...DEFAULT_READSETTINGS,\n            ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n          },\n          globalViewSettings: this.getDefaultViewSettings(),\n        } as SystemSettings;\n        await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', defaultSettings);\n        console.log('[Init]  settings.json created successfully');\n      }\n\n      // Check and create library.json if needed\n      const libraryFilename = getLibraryFilename();\n      const libraryExists = await this.fs.exists(libraryFilename, 'Books');\n      if (!libraryExists) {\n        console.log('[Init] library.json not found, creating with defaults...');\n        await this.safeSaveJSON(libraryFilename, 'Books', []);\n        console.log('[Init]  library.json created successfully');\n      }\n\n      console.log('[Init]  All configuration files are ready');\n    } catch (error) {\n      console.error('[Init] Error ensuring config files exist:', error);\n      // Don't throw, continue with defaults\n    }\n  }\n\n  async openFile(path: string, base: BaseDir): Promise<File> {\n    return await this.fs.openFile(path, base);\n  }\n\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir): Promise<void> {\n    return await this.fs.copyFile(srcPath, dstPath, base);\n  }\n\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    return await this.fs.readFile(path, base, mode);\n  }\n\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    return await this.fs.writeFile(path, base, content);\n  }\n\n  async createDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.createDir(path, base, recursive);\n  }\n\n  async deleteFile(path: string, base: BaseDir): Promise<void> {\n    return await this.fs.removeFile(path, base);\n  }\n\n  async deleteDir(path: string, base: BaseDir, recursive: boolean = true): Promise<void> {\n    return await this.fs.removeDir(path, base, recursive);\n  }\n\n  async resolveFilePath(path: string, base: BaseDir): Promise<string> {\n    const prefix = await this.fs.getPrefix(base);\n    return path ? `${prefix}/${path}` : prefix;\n  }\n\n  async readDirectory(path: string, base: BaseDir): Promise<FileItem[]> {\n    return await this.fs.readDir(path, base);\n  }\n\n  async exists(path: string, base: BaseDir): Promise<boolean> {\n    return await this.fs.exists(path, base);\n  }\n\n  async getImageURL(path: string): Promise<string> {\n    return await this.fs.getImageURL(path);\n  }\n\n  getCoverImageUrl = (book: Book): string => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n    const resolvedPath = this.fs.resolvePath(coverPath, 'Books');\n    return this.fs.getURL(resolvedPath.fp) || `${this.localBooksDir}/${coverPath}`;\n  };\n\n  getCoverImageBlobUrl = async (book: Book): Promise<string> => {\n    // Use the resolved path from 'Books' base instead of manually prefixing with localBooksDir\n    // This correctly handles both flat (relativePath) and legacy (hash-based) paths\n    const coverPath = getCoverFilename(book);\n\n    //  web  Blob URL\n    if (this.appPlatform === 'web') {\n      try {\n        const coverUrl = this.fs.getURL(this.fs.resolvePath(coverPath, 'Books').fp) ||\n          `${this.localBooksDir}/${coverPath}`;\n\n        //  Blob URL 30 \n        return await cachedFetchAsUrl(coverUrl, {\n          cacheStrategy: 'cache-first',\n          cacheTTL: 30 * 24 * 60 * 60 * 1000, // 30 \n        }).catch(() => {\n          // \n          return `${this.localBooksDir}/${coverPath}`;\n        });\n      } catch {\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    } else {\n      try {\n        return await this.fs.getBlobURL(coverPath, 'Books');\n      } catch {\n        // Fallback to old path if the new path doesn't exist\n        return `${this.localBooksDir}/${coverPath}`;\n      }\n    }\n  };\n\n  async getCachedImageUrl(pathOrUrl: string): Promise<string> {\n    const cachedKey = `img_${md5(pathOrUrl)}`;\n    const cachePrefix = await this.fs.getPrefix('Cache');\n    const cachedPath = `${cachePrefix}/${cachedKey}`;\n    if (await this.fs.exists(cachedPath, 'None')) {\n      return await this.fs.getImageURL(cachedPath);\n    } else {\n      const file = await this.fs.openFile(pathOrUrl, 'None');\n      await this.fs.writeFile(cachedKey, 'Cache', await file.arrayBuffer());\n      return await this.fs.getImageURL(cachedPath);\n    }\n  }\n\n  getDefaultViewSettings(): ViewSettings {\n    return {\n      ...DEFAULT_BOOK_LAYOUT,\n      ...DEFAULT_BOOK_STYLE,\n      ...DEFAULT_BOOK_FONT,\n      ...DEFAULT_BOOK_LANGUAGE,\n      ...(this.isMobile ? DEFAULT_MOBILE_VIEW_SETTINGS : {}),\n      ...(this.isEink ? DEFAULT_EINK_VIEW_SETTINGS : {}),\n      ...(isCJKEnv() ? DEFAULT_CJK_VIEW_SETTINGS : {}),\n      ...DEFAULT_VIEW_CONFIG,\n      ...DEFAULT_TTS_CONFIG,\n      ...DEFAULT_SCREEN_CONFIG,\n      ...DEFAULT_ANNOTATOR_CONFIG,\n      ...{ ...DEFAULT_TRANSLATOR_CONFIG, translateTargetLang: getTargetLang() },\n    };\n  }\n\n  async loadSettings(): Promise<SystemSettings> {\n    const defaultSettings: SystemSettings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      version: SYSTEM_SETTINGS_VERSION,\n      localBooksDir: await this.fs.getPrefix('Books'),\n      koreaderSyncDeviceId: uuidv4(),\n      globalReadSettings: {\n        ...DEFAULT_READSETTINGS,\n        ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      },\n      globalViewSettings: this.getDefaultViewSettings(),\n    } as SystemSettings;\n\n    let settings = await this.safeLoadJSON<SystemSettings>(\n      SETTINGS_FILENAME,\n      'Settings',\n      defaultSettings,\n    );\n\n    const version = settings.version ?? 0;\n    if (this.isAppDataSandbox || version < SYSTEM_SETTINGS_VERSION) {\n      settings.version = SYSTEM_SETTINGS_VERSION;\n    }\n    settings = {\n      ...DEFAULT_SYSTEM_SETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_SYSTEM_SETTINGS : {}),\n      ...settings,\n    };\n    settings.globalReadSettings = {\n      ...DEFAULT_READSETTINGS,\n      ...(this.isMobile ? DEFAULT_MOBILE_READSETTINGS : {}),\n      ...settings.globalReadSettings,\n    };\n    settings.globalViewSettings = {\n      ...this.getDefaultViewSettings(),\n      ...settings.globalViewSettings,\n    };\n\n    settings.localBooksDir = await this.fs.getPrefix('Books');\n\n    if (!settings.kosync.deviceId) {\n      settings.kosync.deviceId = uuidv4();\n      await this.saveSettings(settings);\n    }\n\n    this.localBooksDir = settings.localBooksDir;\n    return settings;\n  }\n\n  async saveSettings(settings: SystemSettings): Promise<void> {\n    await this.safeSaveJSON(SETTINGS_FILENAME, 'Settings', settings);\n  }\n\n  async importFont(file?: string | File): Promise<CustomFontInfo | null> {\n    let fontPath: string;\n    let fontFile: File;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      fontPath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, fontPath, 'Fonts');\n      fontFile = await this.fs.openFile(fontPath, 'Fonts');\n    } else if (file) {\n      fontPath = getFilename(file.name);\n      await this.fs.writeFile(fontPath, 'Fonts', file);\n      fontFile = file;\n    } else {\n      return null;\n    }\n\n    return {\n      path: fontPath,\n      ...parseFontInfo(await fontFile.arrayBuffer(), fontPath),\n    };\n  }\n\n  async deleteFont(font: CustomFont): Promise<void> {\n    await this.fs.removeFile(font.path, 'Fonts');\n  }\n\n  async importImage(file?: string | File): Promise<CustomTextureInfo | null> {\n    let imagePath: string;\n    if (typeof file === 'string') {\n      const filePath = file;\n      const fileobj = await this.fs.openFile(filePath, 'None');\n      imagePath = fileobj.name || getFilename(filePath);\n      await this.fs.copyFile(filePath, imagePath, 'Images');\n    } else if (file) {\n      imagePath = getFilename(file.name);\n      await this.fs.writeFile(imagePath, 'Images', file);\n    } else {\n      return null;\n    }\n\n    return {\n      name: imagePath.replace(/\\.[^/.]+$/, ''),\n      path: imagePath,\n    };\n  }\n\n  async deleteImage(texture: CustomTextureInfo): Promise<void> {\n    await this.fs.removeFile(texture.path, 'Images');\n  }\n\n  async importBook(\n    // file might be:\n    // 1.1 absolute path for local file on Desktop\n    // 1.2 /private/var inbox file path on iOS\n    // 2. remote url\n    // 3. content provider uri\n    // 4. File object from browsers\n    file: string | File,\n    books: Book[],\n    saveBook: boolean = true,\n    saveCover: boolean = true,\n    overwrite: boolean = false,\n    transient: boolean = false,\n    options?: {\n      /** Desired relative path (e.g. \"/.epub\"), only used in local mode */\n      targetRelativePath?: string;\n      /** Desired group name, used to derive path when targetRelativePath is not provided */\n      targetGroupName?: string;\n    },\n  ): Promise<Book | null> {\n    const startTime = Date.now();\n    let filename = '';\n\n    try {\n      let loadedBook: BookDoc;\n      let format: BookFormat;\n      let fileobj: File;\n\n      if (transient && typeof file !== 'string') {\n        throw new Error('Transient import is only supported for file paths');\n      }\n\n      try {\n        if (typeof file === 'string') {\n          fileobj = await this.fs.openFile(file, 'None');\n          filename = fileobj.name || getFilename(file);\n        } else {\n          fileobj = file;\n          filename = file.name;\n        }\n\n        // \n        const fileSizeMB = fileobj.size / (1024 * 1024);\n        console.log(`[importBook] Processing: ${filename}, size: ${fileSizeMB.toFixed(2)} MB`);\n\n        // \n        if (fileobj.size === 0) {\n          throw new Error('Invalid or empty book file');\n        }\n\n        // \n        if (fileobj.size > 100 * 1024 * 1024) {\n          console.warn(`[importBook]  Large file: ${fileSizeMB.toFixed(2)} MB, processing may take longer`);\n        }\n\n        if (/\\.txt$/i.test(filename)) {\n          const txt2epub = new TxtToEpubConverter();\n          ({ file: fileobj } = await txt2epub.convert({ file: fileobj }));\n        }\n\n        console.log(`[importBook] Opening document: ${filename}`);\n        ({ book: loadedBook, format } = await new DocumentLoader(fileobj).open());\n\n        if (!loadedBook) {\n          throw new Error('Unsupported or corrupted book file');\n        }\n        const metadataTitle = formatTitle(loadedBook.metadata.title);\n        if (!metadataTitle || !metadataTitle.trim() || metadataTitle === filename) {\n          loadedBook.metadata.title = getBaseFilename(filename);\n        }\n\n        console.log(`[importBook]  Document opened successfully: ${filename}`);\n      } catch (error) {\n        const errorMsg = (error as Error).message || String(error);\n        console.error(`[importBook]  Failed to open book: ${filename}`, errorMsg);\n        throw new Error(`Failed to open the book: ${errorMsg}`);\n      }\n\n      console.log(`[importBook] Computing hash for: ${filename}`);\n      const hash = await partialMD5(fileobj);\n      const existingBook = books.filter((b) => b.hash === hash)[0];\n      const now = Date.now();\n      if (existingBook) {\n        if (!transient) {\n          existingBook.deletedAt = null;\n        }\n        existingBook.createdAt = now;\n        existingBook.updatedAt = now;\n      }\n\n      const primaryLanguage = getPrimaryLanguage(loadedBook.metadata.language);\n      const book: Book = {\n        hash,\n        format,\n        title: formatTitle(loadedBook.metadata.title),\n        sourceTitle: formatTitle(loadedBook.metadata.title),\n        primaryLanguage,\n        author: formatAuthors(loadedBook.metadata.author, primaryLanguage),\n        createdAt: existingBook ? existingBook.createdAt : now,\n        uploadedAt: existingBook ? existingBook.uploadedAt : (transient ? null : now),\n        deletedAt: transient ? now : null,\n        downloadedAt: now,\n        updatedAt: now,\n      };\n      // update book metadata when reimporting the same book\n      if (existingBook) {\n        existingBook.format = book.format;\n        existingBook.title = existingBook.title.trim() ? existingBook.title.trim() : book.title;\n        existingBook.sourceTitle = existingBook.sourceTitle ?? book.sourceTitle;\n        existingBook.author = existingBook.author ?? book.author;\n        existingBook.primaryLanguage = existingBook.primaryLanguage ?? book.primaryLanguage;\n        existingBook.downloadedAt = Date.now();\n      }\n\n      // Decide whether to use new flat local storage path\n      // Check runtime window.__STORAGE_MODE__ first (set by Providers), then fallback to compile-time env var\n      const isLocalStorageMode =\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') ||\n        process.env['NEXT_PUBLIC_STORAGE_MODE'] === 'local';\n      const shouldUseLocalFlatStorage = this.appPlatform === 'web' && isLocalStorageMode;\n\n      console.log('[ImportBook] appPlatform:', this.appPlatform, 'STORAGE_MODE (runtime):', (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__), 'STORAGE_MODE (env):', process.env['NEXT_PUBLIC_STORAGE_MODE'], 'shouldUseLocalFlatStorage:', shouldUseLocalFlatStorage);\n\n      const fileExt = EXTS[format] || format.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title);\n      const targetGroupName = options?.targetGroupName?.trim();\n\n      // Compute target relative path for local mode\n      if (shouldUseLocalFlatStorage) {\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n\n        if (!derivedRelativePath) {\n          throw new Error('targetRelativePath is required for local storage mode. Please provide a valid relative path.');\n        }\n\n        book.relativePath = derivedRelativePath;\n        console.log('[ImportBook] 5. Setting book.relativePath to:', derivedRelativePath);\n        console.log('[ImportBook] 6. Book hash:', book.hash);\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n        if (targetGroupName && !book.groupName) {\n          book.groupName = targetGroupName;\n          if (existingBook && !existingBook.groupName) {\n            existingBook.groupName = targetGroupName;\n          }\n        }\n      } else if (this.appPlatform === 'web') {\n        // For web platform in remote mode, still require relativePath for consistency\n        const derivedRelativePath = options?.targetRelativePath\n          ? options.targetRelativePath\n          : `${targetGroupName ? `${targetGroupName}/` : ''}${safeBaseName}.${fileExt}`;\n        book.relativePath = derivedRelativePath;\n        if (existingBook) {\n          existingBook.relativePath = derivedRelativePath;\n        }\n      }\n\n      // Ensure destination directories exist (new flat structure or legacy hash-based)\n      await this.ensureLocalBookDirs(book);\n\n      const bookFilename = getLocalBookFilename(book);\n      if (saveBook && !transient && (!(await this.fs.exists(bookFilename, 'Books')) || overwrite)) {\n        if (/\\.txt$/i.test(filename)) {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        } else if (typeof file === 'string' && isContentURI(file)) {\n          await this.fs.copyFile(file, bookFilename, 'Books');\n        } else if (typeof file === 'string' && !isValidURL(file)) {\n          try {\n            // try to copy the file directly first in case of large files to avoid memory issues\n            // on desktop when reading recursively from selected directory the direct copy will fail\n            // due to permission issues, then fallback to read and write files\n            await this.fs.copyFile(file, bookFilename, 'Books');\n          } catch {\n            await this.fs.writeFile(bookFilename, 'Books', await fileobj.arrayBuffer());\n          }\n        } else {\n          await this.fs.writeFile(bookFilename, 'Books', fileobj);\n        }\n      }\n      if (saveCover && (!(await this.fs.exists(getCoverFilename(book), 'Books')) || overwrite)) {\n        console.log('[ImportBook] 7. Preparing to save cover');\n        let cover = await loadedBook.getCover();\n        if (cover?.type === 'image/svg+xml') {\n          try {\n            console.log('[ImportBook] Converting SVG cover to PNG...');\n            cover = await svg2png(cover);\n          } catch { }\n        }\n        if (cover) {\n          const coverFilename = getCoverFilename(book);\n          console.log('[ImportBook] 8. Saving cover with filename:', coverFilename);\n          console.log('[ImportBook] 9. Cover size:', cover.size, 'bytes');\n          await this.fs.writeFile(coverFilename, 'Books', await cover.arrayBuffer());\n          console.log('[ImportBook] 10. Cover saved successfully');\n        }\n      }\n      // Never overwrite the config file only when it's not existed\n      if (!existingBook) {\n        await this.saveBookConfig(book, INIT_BOOK_CONFIG);\n        books.splice(0, 0, book);\n      }\n\n      // update file links with url or path or content uri\n      if (typeof file === 'string') {\n        if (isValidURL(file)) {\n          book.url = file;\n          if (existingBook) existingBook.url = file;\n        }\n        if (transient) {\n          book.filePath = file;\n          if (existingBook) existingBook.filePath = file;\n        }\n      }\n      book.coverImageUrl = await this.generateCoverImageUrl(book);\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n\n      const elapsed = Date.now() - startTime;\n      console.log(`[importBook]  Import completed in ${elapsed}ms: ${filename}`);\n\n      return existingBook || book;\n    } catch (error) {\n      const elapsed = Date.now() - startTime;\n      const errorMsg = (error as Error).message || String(error);\n      const errorStack = (error as Error).stack;\n\n      console.error(`[importBook]  Import failed after ${elapsed}ms`);\n      console.error(`[importBook] File: ${filename || (typeof file === 'string' ? file : 'unknown')}`);\n      console.error(`[importBook] Error: ${errorMsg}`);\n      if (errorStack) {\n        console.error(`[importBook] Stack trace:`, errorStack);\n      }\n\n      // \n      if (errorMsg.includes('memory') || errorMsg.includes('ENOMEM')) {\n        throw new Error(`${errorMsg}`);\n      }\n\n      // \n      if (errorMsg.includes('too large') || errorMsg.includes('Maximum size')) {\n        throw error;\n      }\n\n      throw error;\n    }\n  }\n\n  async importBookFromPath(\n    filePath: string,\n    relativePath: string,\n    books: Book[],\n  ): Promise<Book | null> {\n    try {\n      // Extract directory structure for grouping\n      const directory = relativePath.split('/').slice(0, -1).join('/');\n      const groupName = directory || '';\n\n      // Import the book as transient (don't copy, just reference)\n      const book = await this.importBook(\n        filePath,\n        books,\n        false, // saveBook = false\n        true,  // saveCover = true\n        false, // overwrite = false\n        true,  // transient = true\n        {\n          targetRelativePath: relativePath,\n          targetGroupName: groupName,\n        },\n      );\n\n      return book;\n    } catch (error) {\n      console.error('Error importing book from path:', filePath, error);\n      return null;\n    }\n  }\n\n  /**\n   *  - \n   * \n   */\n  async reclassifyBook(book: Book, newGroupName: string, oldGroupName?: string): Promise<void> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reclassify] ');\n      return;\n    }\n\n    //  relativePath hash-based \n    if (!book.relativePath) {\n      console.log('[Reclassify] :', book.title);\n      return;\n    }\n\n    try {\n      // \n      const settings = await this.loadSettings();\n      const groupDirectories = settings.groupDirectories || {};\n\n      //  relativePath \n      const oldRelativePath = book.relativePath;\n\n      // \n      let filename: string;\n      if (oldGroupName && oldRelativePath.startsWith(`${oldGroupName}/`)) {\n        // \n        filename = oldRelativePath.substring(oldGroupName.length + 1);\n      } else {\n        // relativePath \n        // \n        const parts = oldRelativePath.split('/');\n        filename = parts[parts.length - 1] || '';\n      }\n\n      // \n      // 1.  groupDirectories \n      // 2. \n      let targetDirectory: string;\n      if (newGroupName && groupDirectories[newGroupName]) {\n        targetDirectory = groupDirectories[newGroupName];\n      } else if (newGroupName) {\n        targetDirectory = newGroupName;\n      } else {\n        targetDirectory = '';\n      }\n\n      const newRelativePath = targetDirectory\n        ? `${targetDirectory}/${filename}`\n        : filename;\n\n      // \n      if (oldRelativePath === newRelativePath) {\n        console.log('[Reclassify] ');\n        return;\n      }\n\n      console.log('[Reclassify] ');\n      console.log('  :', oldRelativePath);\n      console.log('  :', newRelativePath);\n      console.log('  :', filename);\n      console.log('  :', newGroupName);\n      console.log('  :', targetDirectory);\n\n      //  API \n      const response = await fetch('/api/storage/reclassify', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          oldPath: oldRelativePath,\n          newPath: newRelativePath,\n        }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reclassify] :', error);\n        throw new Error(`Failed to move book files: ${error}`);\n      }\n\n      const result = await response.json();\n\n      //  book \n      book.relativePath = newRelativePath;\n      book.groupName = newGroupName || undefined;\n      //  API \n      if (result.absolutePath) {\n        book.absolutePath = result.absolutePath;\n      }\n\n      console.log('[Reclassify] :', result);\n    } catch (error) {\n      console.error('[Reclassify] :', error);\n      throw error;\n    }\n  }\n\n  async deleteBook(book: Book, deleteAction: DeleteAction): Promise<void> {\n    console.log('Deleting book with action:', deleteAction, book.title);\n    if (deleteAction === 'local' || deleteAction === 'both') {\n      const localDeleteFps =\n        deleteAction === 'local'\n          ? [getLocalBookFilename(book)]\n          : [getLocalBookFilename(book), getCoverFilename(book)];\n      for (const fp of localDeleteFps) {\n        console.log('Deleting local file:', fp);\n        await this.fs.removeFile(fp, 'Books');\n      }\n      if (deleteAction === 'local') {\n        book.downloadedAt = null;\n      } else {\n        book.deletedAt = Date.now();\n        book.downloadedAt = null;\n        book.coverDownloadedAt = null;\n      }\n    }\n    // Cloud storage delete functionality removed - using local server storage only\n    if ((deleteAction === 'cloud' || deleteAction === 'both') && book.uploadedAt) {\n      console.log('Cloud delete operation skipped - cloud storage removed');\n      book.uploadedAt = null;\n    }\n  }\n\n  // Cloud storage methods removed - using local server storage only\n\n  async exportBook(book: Book): Promise<boolean> {\n    const { file } = await this.loadBookContent(book);\n    const content = await file.arrayBuffer();\n    const filename = `${makeSafeFilename(book.title)}.${book.format.toLowerCase()}`;\n    const filepath = await this.resolveFilePath(getLocalBookFilename(book), 'Books');\n    const fileType = file.type || 'application/octet-stream';\n    return await this.saveFile(filename, content, filepath, fileType);\n  }\n\n  async isBookAvailable(book: Book): Promise<boolean> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      return true;\n    }\n    if (book.filePath) {\n      return await this.fs.exists(book.filePath, 'None');\n    }\n    if (book.url) {\n      return isValidURL(book.url);\n    }\n    return false;\n  }\n\n  async getBookFileSize(book: Book): Promise<number | null> {\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      const file = await this.fs.openFile(fp, 'Books');\n      const size = file.size;\n      const f = file as ClosableFile;\n      if (f && f.close) {\n        await f.close();\n      }\n      return size;\n    }\n    return null;\n  }\n\n  async loadBookContent(book: Book): Promise<BookContent> {\n    let file: File;\n    const fp = getLocalBookFilename(book);\n    if (await this.fs.exists(fp, 'Books')) {\n      file = await this.fs.openFile(fp, 'Books');\n    } else if (book.filePath) {\n      file = await this.fs.openFile(book.filePath, 'None');\n    } else if (book.url) {\n      file = await this.fs.openFile(book.url, 'None');\n    } else {\n      // 0.9.64 has a bug that book.title might be modified but the filename is not updated\n      const bookDir = getDir(book);\n      const files = await this.fs.readDir(getDir(book), 'Books');\n      if (files.length > 0) {\n        const bookFile = files.find((f) => f.path.endsWith(`.${EXTS[book.format]}`));\n        if (bookFile) {\n          file = await this.fs.openFile(`${bookDir}/${bookFile.path}`, 'Books');\n        } else {\n          throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n        }\n      } else {\n        throw new Error(BOOK_FILE_NOT_FOUND_ERROR);\n      }\n    }\n    return { book, file };\n  }\n\n  async loadBookConfig(book: Book, settings: SystemSettings): Promise<BookConfig> {\n    const globalViewSettings = {\n      ...settings.globalViewSettings,\n      ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n    };\n    try {\n      let str = '{}';\n      if (await this.fs.exists(getConfigFilename(book), 'Books')) {\n        str = (await this.fs.readFile(getConfigFilename(book), 'Books', 'text')) as string;\n      }\n      return deserializeConfig(str, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } catch {\n      return deserializeConfig('{}', globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    }\n  }\n\n  async fetchBookDetails(book: Book) {\n    const fp = getLocalBookFilename(book);\n    if (!(await this.fs.exists(fp, 'Books')) && book.uploadedAt) {\n      // Cloud download functionality removed - books should already be stored locally\n      console.warn('Book file not found locally and cloud download is disabled:', book.title);\n      throw new Error('Book file not found locally');\n    }\n    const { file } = await this.loadBookContent(book);\n    const bookDoc = (await new DocumentLoader(file).open()).book;\n    const f = file as ClosableFile;\n    if (f && f.close) {\n      await f.close();\n    }\n    return bookDoc.metadata;\n  }\n\n  async saveBookConfig(book: Book, config: BookConfig, settings?: SystemSettings) {\n    let serializedConfig: string;\n    if (settings) {\n      const globalViewSettings = {\n        ...settings.globalViewSettings,\n        ...(FIXED_LAYOUT_FORMATS.has(book.format) ? DEFAULT_FIXED_LAYOUT_VIEW_SETTINGS : {}),\n      };\n      serializedConfig = serializeConfig(config, globalViewSettings, DEFAULT_BOOK_SEARCH_CONFIG);\n    } else {\n      serializedConfig = JSON.stringify(config);\n    }\n    await this.fs.writeFile(getConfigFilename(book), 'Books', serializedConfig);\n  }\n\n  async generateCoverImageUrl(book: Book): Promise<string> {\n    return this.appPlatform === 'web'\n      ? await this.getCoverImageBlobUrl(book)\n      : this.getCoverImageUrl(book);\n  }\n\n  async loadLibraryBooks(): Promise<Book[]> {\n    console.log('Loading library books...');\n    const libraryFilename = getLibraryFilename();\n\n    if (!(await this.fs.exists('', 'Books'))) {\n      await this.fs.createDir('', 'Books', true);\n    }\n\n    const books = await this.safeLoadJSON<Book[]>(libraryFilename, 'Books', []);\n\n    await Promise.all(\n      books.map(async (book) => {\n        book.coverImageUrl = await this.generateCoverImageUrl(book);\n        book.updatedAt ??= book.lastUpdated || Date.now();\n        return book;\n      }),\n    );\n\n    return books;\n  }\n\n  async saveLibraryBooks(books: Book[]): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const libraryBooks = books.map(({ coverImageUrl, ...rest }) => rest);\n    await this.safeSaveJSON(getLibraryFilename(), 'Books', libraryBooks);\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async reconcileBookPaths(books: Book[]): Promise<any> {\n    // \n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    if (this.appPlatform !== 'web' || (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') !== 'local') {\n      console.log('[Reconcile] ');\n      return { success: false, error: 'Not in local storage mode' };\n    }\n\n    try {\n      console.log('[Reconcile] ', books.length, '');\n\n      // \n      const libraryData = books\n        .filter(book => !book.deletedAt)\n        .map(book => ({\n          hash: book.hash,\n          relativePath: book.relativePath,\n          absolutePath: book.absolutePath,\n          title: book.title,\n          groupName: book.groupName,\n        }));\n\n      const response = await fetch('/api/storage/reconcile', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ library: libraryData }),\n      });\n\n      if (!response.ok) {\n        const error = await response.text();\n        console.error('[Reconcile] :', error);\n        throw new Error(`Failed to reconcile paths: ${error}`);\n      }\n\n      const result = await response.json();\n      console.log('[Reconcile] :', result.summary);\n      return result;\n    } catch (error) {\n      console.error('[Reconcile] :', error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   *  library.json \n   */\n  async applyReconciliation(books: Book[], reconcileResults: any[]): Promise<Book[]> {\n    const updatedBooks = [...books];\n\n    for (const result of reconcileResults) {\n      if (result.status === 'moved') {\n        // \n        const bookIndex = updatedBooks.findIndex(b => b.hash === result.hash);\n        if (bookIndex !== -1) {\n          const book = updatedBooks[bookIndex];\n          if (book) {\n            book.relativePath = result.newRelativePath;\n            book.absolutePath = result.absolutePath;\n            if (result.suggestedGroupName !== undefined) {\n              book.groupName = result.suggestedGroupName;\n              //  groupId\n              book.groupId = result.suggestedGroupName\n                ? md5Fingerprint(result.suggestedGroupName)\n                : '';\n            }\n            book.updatedAt = Date.now();\n            console.log('[Reconcile] :', book.title, ':', book.relativePath);\n          }\n        }\n      }\n    }\n\n    await this.saveLibraryBooks(updatedBooks);\n    return updatedBooks;\n  }\n\n  private imageToArrayBuffer(imageUrl?: string, imageFile?: string): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      if (!imageUrl && !imageFile) {\n        reject(new Error('No image URL or file provided'));\n        return;\n      }\n      if (this.appPlatform === 'web' && imageUrl && imageUrl.startsWith('blob:')) {\n        fetch(imageUrl)\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageFile) {\n        this.fs\n          .openFile(imageFile, 'None')\n          .then((file) => file.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else if (this.appPlatform === 'tauri' && imageUrl) {\n        tauriFetch(imageUrl, { method: 'GET' })\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => resolve(buffer))\n          .catch((error) => reject(error));\n      } else {\n        reject(new Error('Unsupported platform or missing image data'));\n      }\n    });\n  }\n\n  async updateCoverImage(book: Book, imageUrl?: string, imageFile?: string): Promise<void> {\n    if (imageUrl === '_blank') {\n      await this.fs.removeFile(getCoverFilename(book), 'Books');\n    } else if (imageUrl || imageFile) {\n      const arrayBuffer = await this.imageToArrayBuffer(imageUrl, imageFile);\n      await this.fs.writeFile(getCoverFilename(book), 'Books', arrayBuffer);\n    }\n  }\n\n  private async loadJSONFile(\n    path: string,\n    base: BaseDir,\n  ): Promise<{ success: boolean; data?: unknown; error?: unknown }> {\n    try {\n      const txt = await this.fs.readFile(path, base, 'text');\n      if (!txt || typeof txt !== 'string' || txt.trim().length === 0) {\n        return { success: false, error: 'File is empty or invalid' };\n      }\n      try {\n        const data = JSON.parse(txt as string);\n        return { success: true, data };\n      } catch (parseError) {\n        return { success: false, error: `JSON parse error: ${parseError}` };\n      }\n    } catch (error) {\n      return { success: false, error };\n    }\n  }\n\n  /**\n   * Safely loads a JSON file with automatic backup fallback.\n   * If the main file is corrupted, attempts to load from backup.\n   * @param filename - The name of the file to load (without .bak extension)\n   * @param base - The base directory\n   * @param defaultValue - Default value to return if both files fail\n   */\n  private async safeLoadJSON<T>(filename: string, base: BaseDir, defaultValue: T): Promise<T> {\n    const backupFilename = `${filename}.bak`;\n\n    // Try loading main file\n    const mainResult = await this.loadJSONFile(filename, base);\n    if (mainResult.success) {\n      return mainResult.data as T;\n    }\n\n    console.warn(`Failed to load ${filename}, attempting backup...`, mainResult.error);\n\n    // Try loading backup file\n    const backupResult = await this.loadJSONFile(backupFilename, base);\n    if (backupResult.success) {\n      console.warn(`Loaded from backup: ${backupFilename}`);\n      // Restore the main file from backup\n      try {\n        const backupData = JSON.stringify(backupResult.data, null, 2);\n        await this.fs.writeFile(filename, base, backupData);\n        console.log(`Restored ${filename} from backup`);\n      } catch (error) {\n        console.error(`Failed to restore ${filename} from backup:`, error);\n      }\n      return backupResult.data as T;\n    }\n\n    console.error(`Both ${filename} and ${backupFilename} failed to load`);\n    return defaultValue;\n  }\n\n  /**\n   * Safely saves a JSON file with atomic write using backup strategy.\n   * Strategy: write to backup first, then to main file.\n   * This ensures at least one valid copy exists at all times.\n   * @param filename - The name of the file to save (without .bak extension)\n   * @param base - The base directory\n   * @param data - The data to save\n   */\n  private async safeSaveJSON(filename: string, base: BaseDir, data: unknown): Promise<void> {\n    const backupFilename = `${filename}.bak`;\n    const jsonData = JSON.stringify(data, null, 2);\n\n    // Strategy: Always write to backup first, then to main file\n    // This ensures we always have at least one valid copy\n    try {\n      // Step 1: Write to backup file\n      await this.fs.writeFile(backupFilename, base, jsonData);\n\n      // Step 2: Write to main file\n      await this.fs.writeFile(filename, base, jsonData);\n    } catch (error) {\n      console.error(`Failed to save ${filename}:`, error);\n      throw new Error(`Failed to save ${filename}: ${error}`);\n    }\n  }\n\n  /** Ensure necessary directories exist for a book (both legacy hash-based and new flat local paths). */\n  private async ensureLocalBookDirs(book: Book): Promise<void> {\n    if (book.relativePath) {\n      const segments = book.relativePath.split('/');\n      const fileDir = segments.slice(0, -1).join('/');\n      const metadataDir = book.relativePath.replace(/\\.[^.]+$/, '');\n\n      if (fileDir) {\n        await this.fs.createDir(fileDir, 'Books', true);\n      }\n      await this.fs.createDir(metadataDir, 'Books', true);\n      return;\n    }\n\n    // Legacy hash-based storage\n    if (!(await this.fs.exists(getDir(book), 'Books'))) {\n      await this.fs.createDir(getDir(book), 'Books');\n    }\n  }\n\n  private async migrate20251124(): Promise<void> {\n    console.log('Running migration for version 20251124 to rename the backup library file...');\n    const oldBackupFilename = getLibraryBackupFilename();\n    const newBackupFilename = `${getLibraryFilename()}.bak`;\n    if (await this.fs.exists(oldBackupFilename, 'Books')) {\n      try {\n        const content = await this.fs.readFile(oldBackupFilename, 'Books', 'text');\n        await this.fs.writeFile(newBackupFilename, 'Books', content);\n        await this.fs.removeFile(oldBackupFilename, 'Books');\n        console.log('Migration to rename backup library file completed successfully.');\n      } catch (error) {\n        console.error('Error during migration to rename backup library file:', error);\n      }\n    }\n  }\n\n  /**\n   * Migration 20260121: move legacy hash-based local books to flat relativePath layout in local mode.\n   * - Applies only when appPlatform === 'web' and STORAGE_MODE is local\n   * - For any book without relativePath, derive a flat path and move files + metadata\n   */\n  private async migrate20260121(): Promise<void> {\n    // @ts-ignore - NEXT_PUBLIC_STORAGE_MODE is set at build time\n    const isLocalMode = (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'local') === 'local';\n    if (this.appPlatform !== 'web' || !isLocalMode) {\n      console.log('[Migration 20260121] Skip (not web/local mode)');\n      return;\n    }\n\n    console.log('[Migration 20260121] Start migrating legacy hash-based books to flat layout');\n\n    const books = await this.loadLibraryBooks();\n    let migrated = 0;\n\n    for (const book of books) {\n      if (book.relativePath) continue;\n\n      const ext = EXTS[book.format] || book.format?.toLowerCase?.() || 'book';\n      const safeBaseName = makeSafeFilename(book.sourceTitle || book.title || book.hash);\n      const newRelativePath = `${book.groupName ? `${book.groupName}/` : ''}${safeBaseName}.${ext}`;\n\n      // Legacy paths\n      const legacyBookPath = `${book.hash}/${safeBaseName}.${ext}`;\n      const legacyCoverPath = `${book.hash}/cover.png`;\n      const legacyConfigPath = `${book.hash}/config.json`;\n\n      // New paths\n      const newBookPath = newRelativePath;\n      const newCoverPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/cover.png';\n      const newConfigPath = newRelativePath.replace(/\\.[^.]+$/, '') + '/config.json';\n\n      try {\n        // Move book file if present\n        if (await this.fs.exists(legacyBookPath, 'Books')) {\n          await this.ensureLocalBookDirs({ ...book, relativePath: newRelativePath } as Book);\n          const file = await this.fs.openFile(legacyBookPath, 'Books');\n          await this.fs.writeFile(newBookPath, 'Books', file);\n          await this.fs.removeFile(legacyBookPath, 'Books');\n        }\n\n        // Move cover\n        if (await this.fs.exists(legacyCoverPath, 'Books')) {\n          const coverFile = await this.fs.openFile(legacyCoverPath, 'Books');\n          await this.fs.writeFile(newCoverPath, 'Books', coverFile);\n          await this.fs.removeFile(legacyCoverPath, 'Books');\n        }\n\n        // Move config\n        if (await this.fs.exists(legacyConfigPath, 'Books')) {\n          const configContent = await this.fs.readFile(legacyConfigPath, 'Books', 'text');\n          await this.fs.writeFile(newConfigPath, 'Books', configContent);\n          await this.fs.removeFile(legacyConfigPath, 'Books');\n        }\n\n        // Update in-memory book\n        book.relativePath = newRelativePath;\n        migrated++;\n      } catch (error) {\n        console.error('[Migration 20260121] Failed to migrate book:', book.title, error);\n      }\n    }\n\n    if (migrated > 0) {\n      await this.saveLibraryBooks(books);\n      console.log(`[Migration 20260121] Migrated ${migrated} book(s) to flat layout`);\n    } else {\n      console.log('[Migration 20260121] No legacy books to migrate');\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3910, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/apiFileSystem.ts"],"sourcesContent":["import { FileSystem, BaseDir, ResolvedPath, FileItem } from '@/types/system';\nimport { isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { LOCAL_BOOKS_SUBDIR, LOCAL_FONTS_SUBDIR, LOCAL_IMAGES_SUBDIR, DATA_SUBDIR } from './constants';\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n    // Check if we're in local storage mode\n    const isLocalMode = (typeof process !== 'undefined' && process.env?.['NEXT_PUBLIC_STORAGE_MODE'] === 'local') ||\n        (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local');\n\n    if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        console.log('[ResolvePath] Env Check - NEXT_PUBLIC_STORAGE_MODE:', process.env?.['NEXT_PUBLIC_STORAGE_MODE'], 'isLocalMode:', isLocalMode, 'base:', base, 'path:', path);\n    }\n\n    switch (base) {\n        case 'Data':\n            return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n        case 'Settings':\n            // Settings files now stored in .readest directory\n            return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n        case 'Books':\n            // Always use flat storage structure (no Readest/Books/ prefix)\n            // Library metadata files now go to .readest directory\n            if (path === 'library.json' || path === 'library.json.bak' || path === 'library_backup.json') {\n                console.log('[ResolvePath] Books/Library detected, routing to .readest');\n                return { baseDir: 0, basePrefix, fp: `.readest/${path}`, base };\n            }\n            // All book files and metadata use flat structure (no Readest/Books/ prefix)\n            console.log('[ResolvePath]  Books base, flat path (no prefix):', path);\n            console.log('[ResolvePath]  Returning fp:', path);\n            return { baseDir: 0, basePrefix, fp: path, base };\n        case 'Fonts':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n        case 'Images':\n            return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n        case 'None':\n            return { baseDir: 0, basePrefix, fp: path, base };\n        default:\n            return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n    }\n};\n\nexport const apiFileSystem: FileSystem = {\n    resolvePath,\n    async getPrefix(base: BaseDir) {\n        const { basePrefix, fp } = this.resolvePath('', base);\n        const basePath = await basePrefix();\n        const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n        return prefix.replace(/\\/+$/, '');\n    },\n    getURL(path: string) {\n        if (isValidURL(path)) {\n            return path;\n        }\n        return `/api/storage/file?filePath=${encodeURIComponent(path)}`;\n    },\n    async getBlobURL(path: string, base: BaseDir) {\n        try {\n            const content = await this.readFile(path, base, 'binary');\n            return URL.createObjectURL(new Blob([content]));\n        } catch {\n            return path;\n        }\n    },\n    async getImageURL(path: string) {\n        return this.getURL(path);\n    },\n    async openFile(path: string, base: BaseDir, filename?: string) {\n        if (isValidURL(path)) {\n            return await new RemoteFile(path, filename).open();\n        }\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        return new File([await res.arrayBuffer()], filename || path);\n    },\n    async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n        const file = await this.openFile(srcPath, base);\n        await this.writeFile(dstPath, base, file);\n    },\n    async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error(`File not found: ${fp}`);\n        return mode === 'text' ? await res.text() : await res.arrayBuffer();\n    },\n    async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n        const { fp } = this.resolvePath(path, base);\n        console.log('[APIFileSystem.writeFile] 11. Input path:', path);\n        console.log('[APIFileSystem.writeFile] 12. Base:', base);\n        console.log('[APIFileSystem.writeFile] 13. Resolved fp:', fp);\n        let buffer: Buffer;\n        if (content instanceof File) {\n            buffer = Buffer.from(await content.arrayBuffer());\n        } else if (typeof content === 'string') {\n            buffer = Buffer.from(content);\n        } else {\n            buffer = Buffer.from(content);\n        }\n        console.log('[APIFileSystem.writeFile] 14. Calling PUT /api/storage/file with filePath:', fp);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`, {\n            method: 'PUT',\n            body: buffer,\n        });\n        if (!res.ok) throw new Error('Failed to write file');\n    },\n    async removeFile(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/delete?fileKey=${encodeURIComponent(fp)}`, {\n            method: 'DELETE',\n        });\n        if (!res.ok) throw new Error('Failed to delete file');\n    },\n    async createDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async removeDir(path: string, base: BaseDir) {\n        // No-op for API-based file system\n    },\n    async readDir(path: string, base: BaseDir): Promise<FileItem[]> {\n        return [];\n    },\n    async exists(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        return res.ok;\n    },\n    async stats(path: string, base: BaseDir) {\n        const { fp } = this.resolvePath(path, base);\n        const res = await fetch(`/api/storage/file?filePath=${encodeURIComponent(fp)}`);\n        if (!res.ok) throw new Error('File not found');\n        const buffer = await res.arrayBuffer();\n        return {\n            isFile: true,\n            isDirectory: false,\n            size: buffer.byteLength,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n        };\n    },\n};\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;;;;;AAEA,MAAM,aAAa,UAAY;AAE/B,MAAM,cAAc,CAAC,MAAc;IAC/B,uCAAuC;IACvC,MAAM,cAAc,AAAC,OAAO,YAAY,eAAe,8CAA8C,WAChG,kDAAkB,eAAe,AAAC,OAAe,gBAAgB,KAAK;IAE3E,IAAI,kDAAkB,eAAe,OAAO,YAAY,aAAa;QACjE,QAAQ,GAAG,CAAC,kGAAkG,gBAAgB,aAAa,SAAS,MAAM,SAAS;IACvK;IAEA,OAAQ;QACJ,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,8JAAW,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QACxE,KAAK;YACD,kDAAkD;YAClD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,CAAC,SAAS,EAAE,MAAM;gBAAE;YAAK;QAClE,KAAK;YACD,+DAA+D;YAC/D,sDAAsD;YACtD,IAAI,SAAS,kBAAkB,SAAS,sBAAsB,SAAS,uBAAuB;gBAC1F,QAAQ,GAAG,CAAC;gBACZ,OAAO;oBAAE,SAAS;oBAAG;oBAAY,IAAI,CAAC,SAAS,EAAE,MAAM;oBAAE;gBAAK;YAClE;YACA,4EAA4E;YAC5E,QAAQ,GAAG,CAAC,sDAAsD;YAClE,QAAQ,GAAG,CAAC,iCAAiC;YAC7C,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI;gBAAM;YAAK;QACpD,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,qKAAkB,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QAC/E,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,sKAAmB,CAAC,CAAC,EAAE,MAAM;gBAAE;YAAK;QAChF,KAAK;YACD,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI;gBAAM;YAAK;QACpD;YACI,OAAO;gBAAE,SAAS;gBAAG;gBAAY,IAAI,GAAG,KAAK,CAAC,EAAE,MAAM;gBAAE;YAAK;IACrE;AACJ;AAEO,MAAM,gBAA4B;IACrC;IACA,MAAM,WAAU,IAAa;QACzB,MAAM,EAAE,UAAU,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI;QAChD,MAAM,WAAW,MAAM;QACvB,MAAM,SAAS,KAAM,WAAW,GAAG,SAAS,CAAC,EAAE,IAAI,GAAG,KAAM;QAC5D,OAAO,OAAO,OAAO,CAAC,QAAQ;IAClC;IACA,QAAO,IAAY;QACf,IAAI,IAAA,qJAAU,EAAC,OAAO;YAClB,OAAO;QACX;QACA,OAAO,CAAC,2BAA2B,EAAE,mBAAmB,OAAO;IACnE;IACA,MAAM,YAAW,IAAY,EAAE,IAAa;QACxC,IAAI;YACA,MAAM,UAAU,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,MAAM;YAChD,OAAO,IAAI,eAAe,CAAC,IAAI,KAAK;gBAAC;aAAQ;QACjD,EAAE,OAAM;YACJ,OAAO;QACX;IACJ;IACA,MAAM,aAAY,IAAY;QAC1B,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB;IACA,MAAM,UAAS,IAAY,EAAE,IAAa,EAAE,QAAiB;QACzD,IAAI,IAAA,qJAAU,EAAC,OAAO;YAClB,OAAO,MAAM,IAAI,qJAAU,CAAC,MAAM,UAAU,IAAI;QACpD;QACA,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;QAC7B,OAAO,IAAI,KAAK;YAAC,MAAM,IAAI,WAAW;SAAG,EAAE,YAAY;IAC3D;IACA,MAAM,UAAS,OAAe,EAAE,OAAe,EAAE,IAAa;QAC1D,MAAM,OAAO,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS;QAC1C,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,MAAM;IACxC;IACA,MAAM,UAAS,IAAY,EAAE,IAAa,EAAE,IAAuB;QAC/D,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI;QACpD,OAAO,SAAS,SAAS,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,WAAW;IACrE;IACA,MAAM,WAAU,IAAY,EAAE,IAAa,EAAE,OAAoC;QAC7E,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,QAAQ,GAAG,CAAC,6CAA6C;QACzD,QAAQ,GAAG,CAAC,uCAAuC;QACnD,QAAQ,GAAG,CAAC,8CAA8C;QAC1D,IAAI;QACJ,IAAI,mBAAmB,MAAM;YACzB,SAAS,OAAO,IAAI,CAAC,MAAM,QAAQ,WAAW;QAClD,OAAO,IAAI,OAAO,YAAY,UAAU;YACpC,SAAS,OAAO,IAAI,CAAC;QACzB,OAAO;YACH,SAAS,OAAO,IAAI,CAAC;QACzB;QACA,QAAQ,GAAG,CAAC,8EAA8E;QAC1F,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK,EAAE;YAC5E,QAAQ;YACR,MAAM;QACV;QACA,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;IACjC;IACA,MAAM,YAAW,IAAY,EAAE,IAAa;QACxC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,4BAA4B,EAAE,mBAAmB,KAAK,EAAE;YAC7E,QAAQ;QACZ;QACA,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;IACjC;IACA,MAAM,WAAU,IAAY,EAAE,IAAa;IACvC,kCAAkC;IACtC;IACA,MAAM,WAAU,IAAY,EAAE,IAAa;IACvC,kCAAkC;IACtC;IACA,MAAM,SAAQ,IAAY,EAAE,IAAa;QACrC,OAAO,EAAE;IACb;IACA,MAAM,QAAO,IAAY,EAAE,IAAa;QACpC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,OAAO,IAAI,EAAE;IACjB;IACA,MAAM,OAAM,IAAY,EAAE,IAAa;QACnC,MAAM,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM;QACtC,MAAM,MAAM,MAAM,MAAM,CAAC,2BAA2B,EAAE,mBAAmB,KAAK;QAC9E,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;QAC7B,MAAM,SAAS,MAAM,IAAI,WAAW;QACpC,OAAO;YACH,QAAQ;YACR,aAAa;YACb,MAAM,OAAO,UAAU;YACvB,OAAO;YACP,OAAO;YACP,WAAW;QACf;IACJ;AACJ"}},
    {"offset": {"line": 4109, "column": 0}, "map": {"version":3,"sources":["file:///app/readest/apps/readest-app/src/services/webAppService.ts"],"sourcesContent":["import { FileSystem, BaseDir, AppPlatform, ResolvedPath, FileItem } from '@/types/system';\nimport { getOSPlatform, isValidURL } from '@/utils/misc';\nimport { RemoteFile } from '@/utils/file';\nimport { isPWA } from './environment';\nimport { BaseAppService } from './appService';\nimport {\n  DATA_SUBDIR,\n  LOCAL_BOOKS_SUBDIR,\n  LOCAL_FONTS_SUBDIR,\n  LOCAL_IMAGES_SUBDIR,\n} from './constants';\nimport { apiFileSystem } from './apiFileSystem';\n\n// Check storage mode at runtime to support window.__STORAGE_MODE__ set by Providers\nconst getIsLocalStorageMode = (): boolean => {\n  // First check window.__STORAGE_MODE__ (runtime set by Providers)\n  if (typeof window !== 'undefined' && (window as any).__STORAGE_MODE__ === 'local') {\n    return true;\n  }\n  // Fallback to compile-time environment variable\n  return (process.env['NEXT_PUBLIC_STORAGE_MODE'] || 'remote') === 'local';\n};\n\nconst basePrefix = async () => '';\n\nconst resolvePath = (path: string, base: BaseDir): ResolvedPath => {\n  switch (base) {\n    case 'Data':\n      return { baseDir: 0, basePrefix, fp: `${DATA_SUBDIR}/${path}`, base };\n    case 'Books':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_BOOKS_SUBDIR}/${path}`, base };\n    case 'Fonts':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_FONTS_SUBDIR}/${path}`, base };\n    case 'Images':\n      return { baseDir: 0, basePrefix, fp: `${LOCAL_IMAGES_SUBDIR}/${path}`, base };\n    case 'None':\n      return { baseDir: 0, basePrefix, fp: path, base };\n    default:\n      return { baseDir: 0, basePrefix, fp: `${base}/${path}`, base };\n  }\n};\n\nconst dbName = 'AppFileSystem';\nconst dbVersion = 1;\n\nasync function openIndexedDB(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(dbName, dbVersion);\n\n    request.onupgradeneeded = () => {\n      const db = request.result;\n      if (!db.objectStoreNames.contains('files')) {\n        db.createObjectStore('files', { keyPath: 'path' });\n      }\n    };\n\n    request.onsuccess = () => resolve(request.result);\n    request.onerror = () => reject(request.error);\n  });\n}\n\nconst indexedDBFileSystem: FileSystem = {\n  resolvePath,\n  async getPrefix(base: BaseDir) {\n    const { basePrefix, fp } = this.resolvePath('', base);\n    const basePath = await basePrefix();\n    const prefix = fp ? (basePath ? `${basePath}/${fp}` : fp) : basePath;\n    return prefix.replace(/\\/+$/, '');\n  },\n  getURL(path: string) {\n    if (isValidURL(path)) {\n      return path;\n    } else {\n      return URL.createObjectURL(new Blob([path]));\n    }\n  },\n  async getBlobURL(path: string, base: BaseDir) {\n    try {\n      const content = await this.readFile(path, base, 'binary');\n      return URL.createObjectURL(new Blob([content]));\n    } catch {\n      return path;\n    }\n  },\n  async getImageURL(path: string) {\n    return await this.getBlobURL(path, 'None');\n  },\n  async openFile(path: string, base: BaseDir, filename?: string) {\n    if (isValidURL(path)) {\n      return await new RemoteFile(path, filename).open();\n    } else {\n      const content = await this.readFile(path, base, 'binary');\n      return new File([content], filename || path);\n    }\n  },\n  async copyFile(srcPath: string, dstPath: string, base: BaseDir) {\n    const { fp } = this.resolvePath(dstPath, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const getRequest = store.get(srcPath);\n\n      getRequest.onsuccess = () => {\n        const data = getRequest.result;\n        if (data) {\n          store.put({ path: fp, content: data.content });\n          resolve();\n        } else {\n          reject(new Error(`File not found: ${srcPath}`));\n        }\n      };\n\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  },\n  async readFile(path: string, base: BaseDir, mode: 'text' | 'binary') {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<string | ArrayBuffer>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = async () => {\n        if (request.result) {\n          const content = request.result.content;\n          if (mode === 'text') resolve(content);\n          else {\n            if (content instanceof Blob) {\n              const arrayBuffer = await content.arrayBuffer();\n              resolve(arrayBuffer);\n            } else if (content instanceof ArrayBuffer) {\n              resolve(content);\n            } else if (typeof content === 'string') {\n              resolve(new TextEncoder().encode(content).buffer as ArrayBuffer);\n            } else {\n              reject(new Error('Unsupported content type in IndexedDB'));\n            }\n          }\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async writeFile(path: string, base: BaseDir, content: string | ArrayBuffer | File) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    if (content instanceof File) {\n      content = await content.arrayBuffer();\n    }\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.put({ path: fp, content });\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async removeFile(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n\n      store.delete(fp);\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async createDir(path: string, base: BaseDir) {\n    return await this.writeFile(path, base, '');\n  },\n  async removeDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<void>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readwrite');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string }[];\n        files.forEach((file) => {\n          if (file.path.startsWith(fp)) {\n            store.delete(file.path);\n          }\n        });\n      };\n\n      transaction.oncomplete = () => resolve();\n      transaction.onerror = () => reject(transaction.error);\n    });\n  },\n  async readDir(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<FileItem[]>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const files = request.result as { path: string; content: string | ArrayBuffer | Blob }[];\n        resolve(\n          files\n            .filter((file) => file.path.startsWith(fp))\n            .map((file) => ({\n              path: file.path.slice(fp.length + 1),\n              size:\n                file.content instanceof Blob\n                  ? file.content.size\n                  : typeof file.content === 'string'\n                    ? file.content.length\n                    : file.content instanceof ArrayBuffer\n                      ? file.content.byteLength\n                      : 0,\n            })),\n        );\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async exists(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise<boolean>((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => resolve(!!request.result);\n      request.onerror = () => reject(request.error);\n    });\n  },\n  async stats(path: string, base: BaseDir) {\n    const { fp } = this.resolvePath(path, base);\n    const db = await openIndexedDB();\n\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction('files', 'readonly');\n      const store = transaction.objectStore('files');\n      const request = store.get(fp);\n\n      request.onsuccess = () => {\n        const result = request.result;\n        if (result) {\n          const content = result.content;\n          const size =\n            content instanceof Blob\n              ? content.size\n              : typeof content === 'string'\n                ? content.length\n                : content instanceof ArrayBuffer\n                  ? content.byteLength\n                  : 0;\n          resolve({\n            isFile: true,\n            isDirectory: false,\n            size,\n            mtime: null,\n            atime: null,\n            birthtime: null,\n          });\n        } else {\n          reject(new Error(`File not found: ${fp}`));\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  },\n};\n\nexport class WebAppService extends BaseAppService {\n  // Use getter to check storage mode dynamically at runtime\n  get fs(): FileSystem {\n    return getIsLocalStorageMode() ? apiFileSystem : indexedDBFileSystem;\n  }\n  override isMobile = ['android', 'ios'].includes(getOSPlatform());\n  override appPlatform = 'web' as AppPlatform;\n  override hasSafeAreaInset = isPWA();\n\n  override async init() {\n    await this.loadSettings();\n    await this.prepareBooksDir();\n    await this.runMigrations();\n  }\n\n  override async runMigrations() {\n    try {\n      const settings = await this.loadSettings();\n      const lastMigrationVersion = settings.migrationVersion || 0;\n\n      await super.runMigrations(lastMigrationVersion);\n\n      if (lastMigrationVersion < this.CURRENT_MIGRATION_VERSION) {\n        await this.saveSettings({\n          ...settings,\n          migrationVersion: this.CURRENT_MIGRATION_VERSION,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to run migrations:', error);\n    }\n  }\n\n  override resolvePath(fp: string, base: BaseDir): ResolvedPath {\n    return this.fs.resolvePath(fp, base);\n  }\n\n  async setCustomRootDir() {\n    // No-op in web environment\n  }\n\n  async selectDirectory(): Promise<string> {\n    throw new Error('selectDirectory is not supported in browser');\n  }\n\n  async selectFiles(): Promise<string[]> {\n    throw new Error('selectFiles is not supported in browser');\n  }\n\n  async saveFile(filename: string, content: string | ArrayBuffer, mimeType?: string): Promise<boolean> {\n    try {\n      const blob = new Blob([content], { type: mimeType || 'application/octet-stream' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n      return true;\n    } catch (error) {\n      console.error('Failed to save file:', error);\n      return false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}}]
}
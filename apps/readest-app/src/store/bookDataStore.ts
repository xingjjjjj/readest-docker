import { create } from 'zustand';
import { SystemSettings } from '@/types/settings';
import { Book, BookConfig, BookNote } from '@/types/book';
import { EnvConfigType } from '@/services/environment';
import { BookDoc } from '@/libs/document';
import { useLibraryStore } from './libraryStore';

import { OptimizedBookLoader } from '@/services/optimizedBookLoader';

interface BookData {
  /* Persistent data shared with different views of the same book */
  id: string;
  book: Book | null;
  file: File | null;
  config: BookConfig | null;
  bookDoc: BookDoc | null;
  isFixedLayout: boolean;
  loader?: OptimizedBookLoader | null;
}

interface BookDataState {
  booksData: { [id: string]: BookData };
  getConfig: (key: string | null) => BookConfig | null;
  setConfig: (key: string, partialConfig: Partial<BookConfig>) => void;
  saveConfig: (
    envConfig: EnvConfigType,
    bookKey: string,
    config: BookConfig,
    settings: SystemSettings,
  ) => void;
  updateBooknotes: (key: string, booknotes: BookNote[]) => BookConfig | undefined;
  getBookData: (keyOrId: string) => BookData | null;
  clearBookData: (keyOrId: string) => void;
}

export const useBookDataStore = create<BookDataState>((set, get) => ({
  booksData: {},
  getBookData: (keyOrId: string) => {
    const id = keyOrId.split('-')[0]!;
    return get().booksData[id] || null;
  },
  clearBookData: (keyOrId: string) => {
    const id = keyOrId.split('-')[0]!;
    set((state) => {
      const newBooksData = { ...state.booksData };
      delete newBooksData[id];
      return {
        booksData: newBooksData,
      };
    });
  },
  getConfig: (key: string | null) => {
    if (!key) return null;
    const id = key.split('-')[0]!;
    return get().booksData[id]?.config || null;
  },
  setConfig: (key: string, partialConfig: Partial<BookConfig>) => {
    set((state: BookDataState) => {
      const id = key.split('-')[0]!;
      const config = (state.booksData[id]?.config || null) as BookConfig;
      if (!config) {
        console.warn('No config found for book', id);
        return state;
      }
      Object.assign(config, partialConfig);
      return {
        booksData: {
          ...state.booksData,
          [id]: {
            ...state.booksData[id]!,
            config,
          },
        },
      };
    });
  },
  saveConfig: async (
    envConfig: EnvConfigType,
    bookKey: string,
    config: BookConfig,
    settings: SystemSettings,
  ) => {
    const appService = await envConfig.getAppService();
    const { library, setLibrary } = useLibraryStore.getState();
    const bookIndex = library.findIndex((b) => b.hash === bookKey.split('-')[0]);
    if (bookIndex == -1) return;
    const book = library.splice(bookIndex, 1)[0]!;
    book.progress = config.progress;
    const now = Date.now();

    // Update reading metadata in library.json
    // - lastReadAt: latest activity timestamp
    // - totalReadTimeMs: approximate reading time based on progress-change intervals
    //   (cap the delta to avoid counting idle time)
    // - readingDays: track number of unique days with reading activity
    // - readDates: array of timestamps for each reading day
    const prevLastReadAt = book.lastReadAt || 0;
    const delta = prevLastReadAt ? now - prevLastReadAt : 0;
    const maxCountedDeltaMs = 10 * 60 * 1000; // 10 minutes
    if (delta > 0 && delta <= maxCountedDeltaMs) {
      book.totalReadTimeMs = (book.totalReadTimeMs || 0) + delta;
    }
    book.lastReadAt = now;

    // Track reading days
    const today = new Date(now);
    today.setHours(0, 0, 0, 0);
    const todayTimestamp = today.getTime();

    if (!book.readDates) {
      book.readDates = [];
    }

    // Check if today is already recorded
    const lastRecordedDate = book.readDates.length > 0
      ? book.readDates[book.readDates.length - 1]
      : 0;
    const lastDate = new Date(lastRecordedDate!);
    lastDate.setHours(0, 0, 0, 0);

    if (lastDate.getTime() !== todayTimestamp) {
      book.readDates.push(todayTimestamp);
      book.readingDays = book.readDates.length;
    }

    // Finished detection
    if (config.progress && config.progress[1] > 0 && config.progress[0] >= config.progress[1]) {
      book.finishedAt = book.finishedAt || now;
    }

    book.updatedAt = now;
    book.downloadedAt = book.downloadedAt || Date.now();
    library.unshift(book);
    setLibrary([...library]);
    config.updatedAt = now;
    // Avoid persisting booknotes into per-book config; notes are stored in centralized notes file
    const { booknotes: _booknotes, ...cleanConfig } = config;
    await appService.saveBookConfig(book, cleanConfig as BookConfig, settings);
    await appService.saveLibraryBooks(library);
  },
  updateBooknotes: (key: string, booknotes: BookNote[]) => {
    let updatedConfig: BookConfig | undefined;
    set((state) => {
      const id = key.split('-')[0]!;
      const book = state.booksData[id];
      if (!book) return state;
      const dedupedBooknotes = Array.from(
        new Map(booknotes.map((item) => [`${item.id}-${item.type}-${item.cfi}`, item])).values(),
      );
      updatedConfig = {
        ...book.config,
        updatedAt: Date.now(),
        booknotes: dedupedBooknotes,
      };
      return {
        booksData: {
          ...state.booksData,
          [id]: {
            ...book,
            config: {
              ...book.config,
              updatedAt: Date.now(),
              booknotes: dedupedBooknotes,
            },
          },
        },
      };
    });
    return updatedConfig;
  },
}));
